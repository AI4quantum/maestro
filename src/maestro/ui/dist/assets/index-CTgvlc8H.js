const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/dagre-5GWH7T2D-BMBbZLgK.js","assets/graph-BtjjCyfS.js","assets/_baseUniq-o7e9QmIE.js","assets/layout-l28xhgRZ.js","assets/_basePickBy-UWsuIbv6.js","assets/clone-CEDDMd2u.js","assets/cose-bilkent-S5V4N54A-BN6UDCHq.js","assets/cytoscape.esm-DtBltrT8.js","assets/c4Diagram-FPNF74CW-DuluuK2U.js","assets/chunk-TZMSLE5B-YNuB0O4r.js","assets/flowDiagram-PVAE7QVJ-C30bQQiE.js","assets/chunk-FMBD7UC4-MUrOfgVf.js","assets/chunk-55IACEB6-D1tq2uLy.js","assets/chunk-QN33PNHL-CGhG7p2a.js","assets/channel-B440EG6p.js","assets/erDiagram-AWTI2OKA-BQnN4uid.js","assets/gitGraphDiagram-NY62KEGX-DYHTqPbW.js","assets/chunk-4BX2VUAB-HC4hRP6X.js","assets/chunk-QZHKN3VN-CWhFkF1R.js","assets/treemap-75Q7IDZK-BYqNGg4h.js","assets/ganttDiagram-OWAHRB6G-CS3lCdvA.js","assets/linear-DE0zFP14.js","assets/init-Gi6I4Gst.js","assets/defaultLocale-C4B-KCzX.js","assets/infoDiagram-STP46IZ2-58lAvSvK.js","assets/pieDiagram-ADFJNKIX-C9GZZgA3.js","assets/arc-CmKg8NsT.js","assets/ordinal-Cboi1Yqb.js","assets/quadrantDiagram-LMRXKWRM-UPRoinb8.js","assets/xychartDiagram-6GGTOJPD-D7vcgLJd.js","assets/requirementDiagram-4UW4RH46-DSfmKJty.js","assets/sequenceDiagram-C3RYC4MD-CorXJhN6.js","assets/classDiagram-KNZD7YFC-BXauZT2J.js","assets/chunk-K7UQS3LO-BorfOMhP.js","assets/classDiagram-v2-RKCZMP56-BXauZT2J.js","assets/stateDiagram-KXAO66HF-CCGvXDza.js","assets/chunk-TVAH2DTR-DlynSx04.js","assets/stateDiagram-v2-UMBNRL4Z-Uy3D9xC-.js","assets/journeyDiagram-BIP6EPQ6-DRM6TPn8.js","assets/timeline-definition-XQNQX7LJ-BvZySmlk.js","assets/mindmap-definition-Q6HEUPPD-DW5BEfvJ.js","assets/kanban-definition-6OIFK2YF-UP2RNqUs.js","assets/sankeyDiagram-GR3RE2ED-DTLA6Z8n.js","assets/diagram-S2PKOQOG-D95U7Eg2.js","assets/diagram-QEK2KX5R-COm1ZZfD.js","assets/blockDiagram-QIGZ2CNN-AMClBncs.js","assets/architectureDiagram-W76B3OCA-CJxIfoJw.js","assets/diagram-N5W7TBWH-C6wYlEUW.js"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
let i2, no, _A, UE, Pg, Xe, Gx, b4, vL, Jb, k5, rE, _l, fz, yh, t2, ug, f1, hL, uu, y4, To, ME, wo, mt, wt, c4, v, $E, D_, sL, O1, L1, Cz, bz, _z, vz, mz, hl, Cg, n4, QO, KD, Ng, Ex, OR, oL, hz, aA, Oo, BR, MR, xg, Aa, T1, U3, fo, Cn, l4, P_, fh, mh, Yu, W_, I_, ND, vt, Sz, yz, Tz, wz, xz, r6, ew, Bz, E5, Ee, $a, $g, AS, kn, J_, Lt, yr, W6, Mz, Lz, Az, xt, Ez, M6, T6, w6, RE, gi, R3, bg, m2, Ao, x2, gz, vA, a4, QD, rg, s4, gh, Wt, FO, zg, OD, o4, Bo, Bl, Hu, YD, m8, Mo, ju, zD, F_, UO, jO, cn, Q1, YO, Fg, HO, GO, Ll, Ra, G1, qg, H_, Pt, jt, e2, ke, zE, Qr, ji, R5, El, it, eS, dz, Dz, FE, qE, Oz, NE, A5, tr, _6, _4, kz, DE, pz;
let __tla = (async () => {
  var _a, _b, _c, _d, _e, _f, _g2, _h2, _i, _j;
  (function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload")) return;
    for (const l of document.querySelectorAll('link[rel="modulepreload"]')) n(l);
    new MutationObserver((l) => {
      for (const o of l) if (o.type === "childList") for (const h of o.addedNodes) h.tagName === "LINK" && h.rel === "modulepreload" && n(h);
    }).observe(document, {
      childList: true,
      subtree: true
    });
    function a(l) {
      const o = {};
      return l.integrity && (o.integrity = l.integrity), l.referrerPolicy && (o.referrerPolicy = l.referrerPolicy), l.crossOrigin === "use-credentials" ? o.credentials = "include" : l.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o;
    }
    function n(l) {
      if (l.ep) return;
      l.ep = true;
      const o = a(l);
      fetch(l.href, o);
    }
  })();
  aA = function(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
  };
  var zd = {
    exports: {}
  }, $s = {};
  var jb;
  function nA() {
    if (jb) return $s;
    jb = 1;
    var t = Symbol.for("react.transitional.element"), e = Symbol.for("react.fragment");
    function a(n, l, o) {
      var h = null;
      if (o !== void 0 && (h = "" + o), l.key !== void 0 && (h = "" + l.key), "key" in l) {
        o = {};
        for (var u in l) u !== "key" && (o[u] = l[u]);
      } else o = l;
      return l = o.ref, {
        $$typeof: t,
        type: n,
        key: h,
        ref: l !== void 0 ? l : null,
        props: o
      };
    }
    return $s.Fragment = e, $s.jsx = a, $s.jsxs = a, $s;
  }
  var Yb;
  function lA() {
    return Yb || (Yb = 1, zd.exports = nA()), zd.exports;
  }
  var Ai = lA(), Fd = {
    exports: {}
  }, Ot = {};
  var Ib;
  function sA() {
    if (Ib) return Ot;
    Ib = 1;
    var t = Symbol.for("react.transitional.element"), e = Symbol.for("react.portal"), a = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), l = Symbol.for("react.profiler"), o = Symbol.for("react.consumer"), h = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), d = Symbol.for("react.suspense"), f = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), m = Symbol.iterator;
    function b(M) {
      return M === null || typeof M != "object" ? null : (M = m && M[m] || M["@@iterator"], typeof M == "function" ? M : null);
    }
    var x = {
      isMounted: function() {
        return false;
      },
      enqueueForceUpdate: function() {
      },
      enqueueReplaceState: function() {
      },
      enqueueSetState: function() {
      }
    }, _ = Object.assign, S = {};
    function w(M, Y, K) {
      this.props = M, this.context = Y, this.refs = S, this.updater = K || x;
    }
    w.prototype.isReactComponent = {}, w.prototype.setState = function(M, Y) {
      if (typeof M != "object" && typeof M != "function" && M != null) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, M, Y, "setState");
    }, w.prototype.forceUpdate = function(M) {
      this.updater.enqueueForceUpdate(this, M, "forceUpdate");
    };
    function k() {
    }
    k.prototype = w.prototype;
    function A(M, Y, K) {
      this.props = M, this.context = Y, this.refs = S, this.updater = K || x;
    }
    var L = A.prototype = new k();
    L.constructor = A, _(L, w.prototype), L.isPureReactComponent = true;
    var $ = Array.isArray, O = {
      H: null,
      A: null,
      T: null,
      S: null,
      V: null
    }, W = Object.prototype.hasOwnProperty;
    function j(M, Y, K, Z, ct, ut) {
      return K = ut.ref, {
        $$typeof: t,
        type: M,
        key: Y,
        ref: K !== void 0 ? K : null,
        props: ut
      };
    }
    function et(M, Y) {
      return j(M.type, Y, void 0, void 0, void 0, M.props);
    }
    function nt(M) {
      return typeof M == "object" && M !== null && M.$$typeof === t;
    }
    function lt(M) {
      var Y = {
        "=": "=0",
        ":": "=2"
      };
      return "$" + M.replace(/[=:]/g, function(K) {
        return Y[K];
      });
    }
    var X = /\/+/g;
    function at(M, Y) {
      return typeof M == "object" && M !== null && M.key != null ? lt("" + M.key) : Y.toString(36);
    }
    function rt() {
    }
    function V(M) {
      switch (M.status) {
        case "fulfilled":
          return M.value;
        case "rejected":
          throw M.reason;
        default:
          switch (typeof M.status == "string" ? M.then(rt, rt) : (M.status = "pending", M.then(function(Y) {
            M.status === "pending" && (M.status = "fulfilled", M.value = Y);
          }, function(Y) {
            M.status === "pending" && (M.status = "rejected", M.reason = Y);
          })), M.status) {
            case "fulfilled":
              return M.value;
            case "rejected":
              throw M.reason;
          }
      }
      throw M;
    }
    function G(M, Y, K, Z, ct) {
      var ut = typeof M;
      (ut === "undefined" || ut === "boolean") && (M = null);
      var pt = false;
      if (M === null) pt = true;
      else switch (ut) {
        case "bigint":
        case "string":
        case "number":
          pt = true;
          break;
        case "object":
          switch (M.$$typeof) {
            case t:
            case e:
              pt = true;
              break;
            case p:
              return pt = M._init, G(pt(M._payload), Y, K, Z, ct);
          }
      }
      if (pt) return ct = ct(M), pt = Z === "" ? "." + at(M, 0) : Z, $(ct) ? (K = "", pt != null && (K = pt.replace(X, "$&/") + "/"), G(ct, Y, K, "", function(he) {
        return he;
      })) : ct != null && (nt(ct) && (ct = et(ct, K + (ct.key == null || M && M.key === ct.key ? "" : ("" + ct.key).replace(X, "$&/") + "/") + pt)), Y.push(ct)), 1;
      pt = 0;
      var Ht = Z === "" ? "." : Z + ":";
      if ($(M)) for (var qt = 0; qt < M.length; qt++) Z = M[qt], ut = Ht + at(Z, qt), pt += G(Z, Y, K, ut, ct);
      else if (qt = b(M), typeof qt == "function") for (M = qt.call(M), qt = 0; !(Z = M.next()).done; ) Z = Z.value, ut = Ht + at(Z, qt++), pt += G(Z, Y, K, ut, ct);
      else if (ut === "object") {
        if (typeof M.then == "function") return G(V(M), Y, K, Z, ct);
        throw Y = String(M), Error("Objects are not valid as a React child (found: " + (Y === "[object Object]" ? "object with keys {" + Object.keys(M).join(", ") + "}" : Y) + "). If you meant to render a collection of children, use an array instead.");
      }
      return pt;
    }
    function E(M, Y, K) {
      if (M == null) return M;
      var Z = [], ct = 0;
      return G(M, Z, "", "", function(ut) {
        return Y.call(K, ut, ct++);
      }), Z;
    }
    function N(M) {
      if (M._status === -1) {
        var Y = M._result;
        Y = Y(), Y.then(function(K) {
          (M._status === 0 || M._status === -1) && (M._status = 1, M._result = K);
        }, function(K) {
          (M._status === 0 || M._status === -1) && (M._status = 2, M._result = K);
        }), M._status === -1 && (M._status = 0, M._result = Y);
      }
      if (M._status === 1) return M._result.default;
      throw M._result;
    }
    var F = typeof reportError == "function" ? reportError : function(M) {
      if (typeof window == "object" && typeof window.ErrorEvent == "function") {
        var Y = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: typeof M == "object" && M !== null && typeof M.message == "string" ? String(M.message) : String(M),
          error: M
        });
        if (!window.dispatchEvent(Y)) return;
      } else if (typeof process == "object" && typeof process.emit == "function") {
        process.emit("uncaughtException", M);
        return;
      }
      console.error(M);
    };
    function ot() {
    }
    return Ot.Children = {
      map: E,
      forEach: function(M, Y, K) {
        E(M, function() {
          Y.apply(this, arguments);
        }, K);
      },
      count: function(M) {
        var Y = 0;
        return E(M, function() {
          Y++;
        }), Y;
      },
      toArray: function(M) {
        return E(M, function(Y) {
          return Y;
        }) || [];
      },
      only: function(M) {
        if (!nt(M)) throw Error("React.Children.only expected to receive a single React element child.");
        return M;
      }
    }, Ot.Component = w, Ot.Fragment = a, Ot.Profiler = l, Ot.PureComponent = A, Ot.StrictMode = n, Ot.Suspense = d, Ot.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = O, Ot.__COMPILER_RUNTIME = {
      __proto__: null,
      c: function(M) {
        return O.H.useMemoCache(M);
      }
    }, Ot.cache = function(M) {
      return function() {
        return M.apply(null, arguments);
      };
    }, Ot.cloneElement = function(M, Y, K) {
      if (M == null) throw Error("The argument must be a React element, but you passed " + M + ".");
      var Z = _({}, M.props), ct = M.key, ut = void 0;
      if (Y != null) for (pt in Y.ref !== void 0 && (ut = void 0), Y.key !== void 0 && (ct = "" + Y.key), Y) !W.call(Y, pt) || pt === "key" || pt === "__self" || pt === "__source" || pt === "ref" && Y.ref === void 0 || (Z[pt] = Y[pt]);
      var pt = arguments.length - 2;
      if (pt === 1) Z.children = K;
      else if (1 < pt) {
        for (var Ht = Array(pt), qt = 0; qt < pt; qt++) Ht[qt] = arguments[qt + 2];
        Z.children = Ht;
      }
      return j(M.type, ct, void 0, void 0, ut, Z);
    }, Ot.createContext = function(M) {
      return M = {
        $$typeof: h,
        _currentValue: M,
        _currentValue2: M,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      }, M.Provider = M, M.Consumer = {
        $$typeof: o,
        _context: M
      }, M;
    }, Ot.createElement = function(M, Y, K) {
      var Z, ct = {}, ut = null;
      if (Y != null) for (Z in Y.key !== void 0 && (ut = "" + Y.key), Y) W.call(Y, Z) && Z !== "key" && Z !== "__self" && Z !== "__source" && (ct[Z] = Y[Z]);
      var pt = arguments.length - 2;
      if (pt === 1) ct.children = K;
      else if (1 < pt) {
        for (var Ht = Array(pt), qt = 0; qt < pt; qt++) Ht[qt] = arguments[qt + 2];
        ct.children = Ht;
      }
      if (M && M.defaultProps) for (Z in pt = M.defaultProps, pt) ct[Z] === void 0 && (ct[Z] = pt[Z]);
      return j(M, ut, void 0, void 0, null, ct);
    }, Ot.createRef = function() {
      return {
        current: null
      };
    }, Ot.forwardRef = function(M) {
      return {
        $$typeof: u,
        render: M
      };
    }, Ot.isValidElement = nt, Ot.lazy = function(M) {
      return {
        $$typeof: p,
        _payload: {
          _status: -1,
          _result: M
        },
        _init: N
      };
    }, Ot.memo = function(M, Y) {
      return {
        $$typeof: f,
        type: M,
        compare: Y === void 0 ? null : Y
      };
    }, Ot.startTransition = function(M) {
      var Y = O.T, K = {};
      O.T = K;
      try {
        var Z = M(), ct = O.S;
        ct !== null && ct(K, Z), typeof Z == "object" && Z !== null && typeof Z.then == "function" && Z.then(ot, F);
      } catch (ut) {
        F(ut);
      } finally {
        O.T = Y;
      }
    }, Ot.unstable_useCacheRefresh = function() {
      return O.H.useCacheRefresh();
    }, Ot.use = function(M) {
      return O.H.use(M);
    }, Ot.useActionState = function(M, Y, K) {
      return O.H.useActionState(M, Y, K);
    }, Ot.useCallback = function(M, Y) {
      return O.H.useCallback(M, Y);
    }, Ot.useContext = function(M) {
      return O.H.useContext(M);
    }, Ot.useDebugValue = function() {
    }, Ot.useDeferredValue = function(M, Y) {
      return O.H.useDeferredValue(M, Y);
    }, Ot.useEffect = function(M, Y, K) {
      var Z = O.H;
      if (typeof K == "function") throw Error("useEffect CRUD overload is not enabled in this build of React.");
      return Z.useEffect(M, Y);
    }, Ot.useId = function() {
      return O.H.useId();
    }, Ot.useImperativeHandle = function(M, Y, K) {
      return O.H.useImperativeHandle(M, Y, K);
    }, Ot.useInsertionEffect = function(M, Y) {
      return O.H.useInsertionEffect(M, Y);
    }, Ot.useLayoutEffect = function(M, Y) {
      return O.H.useLayoutEffect(M, Y);
    }, Ot.useMemo = function(M, Y) {
      return O.H.useMemo(M, Y);
    }, Ot.useOptimistic = function(M, Y) {
      return O.H.useOptimistic(M, Y);
    }, Ot.useReducer = function(M, Y, K) {
      return O.H.useReducer(M, Y, K);
    }, Ot.useRef = function(M) {
      return O.H.useRef(M);
    }, Ot.useState = function(M) {
      return O.H.useState(M);
    }, Ot.useSyncExternalStore = function(M, Y, K) {
      return O.H.useSyncExternalStore(M, Y, K);
    }, Ot.useTransition = function() {
      return O.H.useTransition();
    }, Ot.version = "19.1.1", Ot;
  }
  var Pb;
  function sg() {
    return Pb || (Pb = 1, Fd.exports = sA()), Fd.exports;
  }
  var Qi = sg(), qd = {
    exports: {}
  }, Ns = {}, Hd = {
    exports: {}
  }, Ud = {};
  var Gb;
  function oA() {
    return Gb || (Gb = 1, (function(t) {
      function e(E, N) {
        var F = E.length;
        E.push(N);
        t: for (; 0 < F; ) {
          var ot = F - 1 >>> 1, M = E[ot];
          if (0 < l(M, N)) E[ot] = N, E[F] = M, F = ot;
          else break t;
        }
      }
      function a(E) {
        return E.length === 0 ? null : E[0];
      }
      function n(E) {
        if (E.length === 0) return null;
        var N = E[0], F = E.pop();
        if (F !== N) {
          E[0] = F;
          t: for (var ot = 0, M = E.length, Y = M >>> 1; ot < Y; ) {
            var K = 2 * (ot + 1) - 1, Z = E[K], ct = K + 1, ut = E[ct];
            if (0 > l(Z, F)) ct < M && 0 > l(ut, Z) ? (E[ot] = ut, E[ct] = F, ot = ct) : (E[ot] = Z, E[K] = F, ot = K);
            else if (ct < M && 0 > l(ut, F)) E[ot] = ut, E[ct] = F, ot = ct;
            else break t;
          }
        }
        return N;
      }
      function l(E, N) {
        var F = E.sortIndex - N.sortIndex;
        return F !== 0 ? F : E.id - N.id;
      }
      if (t.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
        var o = performance;
        t.unstable_now = function() {
          return o.now();
        };
      } else {
        var h = Date, u = h.now();
        t.unstable_now = function() {
          return h.now() - u;
        };
      }
      var d = [], f = [], p = 1, m = null, b = 3, x = false, _ = false, S = false, w = false, k = typeof setTimeout == "function" ? setTimeout : null, A = typeof clearTimeout == "function" ? clearTimeout : null, L = typeof setImmediate < "u" ? setImmediate : null;
      function $(E) {
        for (var N = a(f); N !== null; ) {
          if (N.callback === null) n(f);
          else if (N.startTime <= E) n(f), N.sortIndex = N.expirationTime, e(d, N);
          else break;
          N = a(f);
        }
      }
      function O(E) {
        if (S = false, $(E), !_) if (a(d) !== null) _ = true, W || (W = true, at());
        else {
          var N = a(f);
          N !== null && G(O, N.startTime - E);
        }
      }
      var W = false, j = -1, et = 5, nt = -1;
      function lt() {
        return w ? true : !(t.unstable_now() - nt < et);
      }
      function X() {
        if (w = false, W) {
          var E = t.unstable_now();
          nt = E;
          var N = true;
          try {
            t: {
              _ = false, S && (S = false, A(j), j = -1), x = true;
              var F = b;
              try {
                e: {
                  for ($(E), m = a(d); m !== null && !(m.expirationTime > E && lt()); ) {
                    var ot = m.callback;
                    if (typeof ot == "function") {
                      m.callback = null, b = m.priorityLevel;
                      var M = ot(m.expirationTime <= E);
                      if (E = t.unstable_now(), typeof M == "function") {
                        m.callback = M, $(E), N = true;
                        break e;
                      }
                      m === a(d) && n(d), $(E);
                    } else n(d);
                    m = a(d);
                  }
                  if (m !== null) N = true;
                  else {
                    var Y = a(f);
                    Y !== null && G(O, Y.startTime - E), N = false;
                  }
                }
                break t;
              } finally {
                m = null, b = F, x = false;
              }
              N = void 0;
            }
          } finally {
            N ? at() : W = false;
          }
        }
      }
      var at;
      if (typeof L == "function") at = function() {
        L(X);
      };
      else if (typeof MessageChannel < "u") {
        var rt = new MessageChannel(), V = rt.port2;
        rt.port1.onmessage = X, at = function() {
          V.postMessage(null);
        };
      } else at = function() {
        k(X, 0);
      };
      function G(E, N) {
        j = k(function() {
          E(t.unstable_now());
        }, N);
      }
      t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function(E) {
        E.callback = null;
      }, t.unstable_forceFrameRate = function(E) {
        0 > E || 125 < E ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : et = 0 < E ? Math.floor(1e3 / E) : 5;
      }, t.unstable_getCurrentPriorityLevel = function() {
        return b;
      }, t.unstable_next = function(E) {
        switch (b) {
          case 1:
          case 2:
          case 3:
            var N = 3;
            break;
          default:
            N = b;
        }
        var F = b;
        b = N;
        try {
          return E();
        } finally {
          b = F;
        }
      }, t.unstable_requestPaint = function() {
        w = true;
      }, t.unstable_runWithPriority = function(E, N) {
        switch (E) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            E = 3;
        }
        var F = b;
        b = E;
        try {
          return N();
        } finally {
          b = F;
        }
      }, t.unstable_scheduleCallback = function(E, N, F) {
        var ot = t.unstable_now();
        switch (typeof F == "object" && F !== null ? (F = F.delay, F = typeof F == "number" && 0 < F ? ot + F : ot) : F = ot, E) {
          case 1:
            var M = -1;
            break;
          case 2:
            M = 250;
            break;
          case 5:
            M = 1073741823;
            break;
          case 4:
            M = 1e4;
            break;
          default:
            M = 5e3;
        }
        return M = F + M, E = {
          id: p++,
          callback: N,
          priorityLevel: E,
          startTime: F,
          expirationTime: M,
          sortIndex: -1
        }, F > ot ? (E.sortIndex = F, e(f, E), a(d) === null && E === a(f) && (S ? (A(j), j = -1) : S = true, G(O, F - ot))) : (E.sortIndex = M, e(d, E), _ || x || (_ = true, W || (W = true, at()))), E;
      }, t.unstable_shouldYield = lt, t.unstable_wrapCallback = function(E) {
        var N = b;
        return function() {
          var F = b;
          b = N;
          try {
            return E.apply(this, arguments);
          } finally {
            b = F;
          }
        };
      };
    })(Ud)), Ud;
  }
  var Wb;
  function cA() {
    return Wb || (Wb = 1, Hd.exports = oA()), Hd.exports;
  }
  var jd = {
    exports: {}
  }, Ge = {};
  var Xb;
  function uA() {
    if (Xb) return Ge;
    Xb = 1;
    var t = sg();
    function e(d) {
      var f = "https://react.dev/errors/" + d;
      if (1 < arguments.length) {
        f += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var p = 2; p < arguments.length; p++) f += "&args[]=" + encodeURIComponent(arguments[p]);
      }
      return "Minified React error #" + d + "; visit " + f + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    function a() {
    }
    var n = {
      d: {
        f: a,
        r: function() {
          throw Error(e(522));
        },
        D: a,
        C: a,
        L: a,
        m: a,
        X: a,
        S: a,
        M: a
      },
      p: 0,
      findDOMNode: null
    }, l = Symbol.for("react.portal");
    function o(d, f, p) {
      var m = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return {
        $$typeof: l,
        key: m == null ? null : "" + m,
        children: d,
        containerInfo: f,
        implementation: p
      };
    }
    var h = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    function u(d, f) {
      if (d === "font") return "";
      if (typeof f == "string") return f === "use-credentials" ? f : "";
    }
    return Ge.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = n, Ge.createPortal = function(d, f) {
      var p = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!f || f.nodeType !== 1 && f.nodeType !== 9 && f.nodeType !== 11) throw Error(e(299));
      return o(d, f, null, p);
    }, Ge.flushSync = function(d) {
      var f = h.T, p = n.p;
      try {
        if (h.T = null, n.p = 2, d) return d();
      } finally {
        h.T = f, n.p = p, n.d.f();
      }
    }, Ge.preconnect = function(d, f) {
      typeof d == "string" && (f ? (f = f.crossOrigin, f = typeof f == "string" ? f === "use-credentials" ? f : "" : void 0) : f = null, n.d.C(d, f));
    }, Ge.prefetchDNS = function(d) {
      typeof d == "string" && n.d.D(d);
    }, Ge.preinit = function(d, f) {
      if (typeof d == "string" && f && typeof f.as == "string") {
        var p = f.as, m = u(p, f.crossOrigin), b = typeof f.integrity == "string" ? f.integrity : void 0, x = typeof f.fetchPriority == "string" ? f.fetchPriority : void 0;
        p === "style" ? n.d.S(d, typeof f.precedence == "string" ? f.precedence : void 0, {
          crossOrigin: m,
          integrity: b,
          fetchPriority: x
        }) : p === "script" && n.d.X(d, {
          crossOrigin: m,
          integrity: b,
          fetchPriority: x,
          nonce: typeof f.nonce == "string" ? f.nonce : void 0
        });
      }
    }, Ge.preinitModule = function(d, f) {
      if (typeof d == "string") if (typeof f == "object" && f !== null) {
        if (f.as == null || f.as === "script") {
          var p = u(f.as, f.crossOrigin);
          n.d.M(d, {
            crossOrigin: p,
            integrity: typeof f.integrity == "string" ? f.integrity : void 0,
            nonce: typeof f.nonce == "string" ? f.nonce : void 0
          });
        }
      } else f == null && n.d.M(d);
    }, Ge.preload = function(d, f) {
      if (typeof d == "string" && typeof f == "object" && f !== null && typeof f.as == "string") {
        var p = f.as, m = u(p, f.crossOrigin);
        n.d.L(d, p, {
          crossOrigin: m,
          integrity: typeof f.integrity == "string" ? f.integrity : void 0,
          nonce: typeof f.nonce == "string" ? f.nonce : void 0,
          type: typeof f.type == "string" ? f.type : void 0,
          fetchPriority: typeof f.fetchPriority == "string" ? f.fetchPriority : void 0,
          referrerPolicy: typeof f.referrerPolicy == "string" ? f.referrerPolicy : void 0,
          imageSrcSet: typeof f.imageSrcSet == "string" ? f.imageSrcSet : void 0,
          imageSizes: typeof f.imageSizes == "string" ? f.imageSizes : void 0,
          media: typeof f.media == "string" ? f.media : void 0
        });
      }
    }, Ge.preloadModule = function(d, f) {
      if (typeof d == "string") if (f) {
        var p = u(f.as, f.crossOrigin);
        n.d.m(d, {
          as: typeof f.as == "string" && f.as !== "script" ? f.as : void 0,
          crossOrigin: p,
          integrity: typeof f.integrity == "string" ? f.integrity : void 0
        });
      } else n.d.m(d);
    }, Ge.requestFormReset = function(d) {
      n.d.r(d);
    }, Ge.unstable_batchedUpdates = function(d, f) {
      return d(f);
    }, Ge.useFormState = function(d, f, p) {
      return h.H.useFormState(d, f, p);
    }, Ge.useFormStatus = function() {
      return h.H.useHostTransitionStatus();
    }, Ge.version = "19.1.1", Ge;
  }
  var Vb;
  function hA() {
    if (Vb) return jd.exports;
    Vb = 1;
    function t() {
      if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t);
      } catch (e) {
        console.error(e);
      }
    }
    return t(), jd.exports = uA(), jd.exports;
  }
  var Zb;
  function fA() {
    if (Zb) return Ns;
    Zb = 1;
    var t = cA(), e = sg(), a = hA();
    function n(i) {
      var r = "https://react.dev/errors/" + i;
      if (1 < arguments.length) {
        r += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var s = 2; s < arguments.length; s++) r += "&args[]=" + encodeURIComponent(arguments[s]);
      }
      return "Minified React error #" + i + "; visit " + r + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    function l(i) {
      return !(!i || i.nodeType !== 1 && i.nodeType !== 9 && i.nodeType !== 11);
    }
    function o(i) {
      var r = i, s = i;
      if (i.alternate) for (; r.return; ) r = r.return;
      else {
        i = r;
        do
          r = i, (r.flags & 4098) !== 0 && (s = r.return), i = r.return;
        while (i);
      }
      return r.tag === 3 ? s : null;
    }
    function h(i) {
      if (i.tag === 13) {
        var r = i.memoizedState;
        if (r === null && (i = i.alternate, i !== null && (r = i.memoizedState)), r !== null) return r.dehydrated;
      }
      return null;
    }
    function u(i) {
      if (o(i) !== i) throw Error(n(188));
    }
    function d(i) {
      var r = i.alternate;
      if (!r) {
        if (r = o(i), r === null) throw Error(n(188));
        return r !== i ? null : i;
      }
      for (var s = i, c = r; ; ) {
        var g = s.return;
        if (g === null) break;
        var y = g.alternate;
        if (y === null) {
          if (c = g.return, c !== null) {
            s = c;
            continue;
          }
          break;
        }
        if (g.child === y.child) {
          for (y = g.child; y; ) {
            if (y === s) return u(g), i;
            if (y === c) return u(g), r;
            y = y.sibling;
          }
          throw Error(n(188));
        }
        if (s.return !== c.return) s = g, c = y;
        else {
          for (var C = false, T = g.child; T; ) {
            if (T === s) {
              C = true, s = g, c = y;
              break;
            }
            if (T === c) {
              C = true, c = g, s = y;
              break;
            }
            T = T.sibling;
          }
          if (!C) {
            for (T = y.child; T; ) {
              if (T === s) {
                C = true, s = y, c = g;
                break;
              }
              if (T === c) {
                C = true, c = y, s = g;
                break;
              }
              T = T.sibling;
            }
            if (!C) throw Error(n(189));
          }
        }
        if (s.alternate !== c) throw Error(n(190));
      }
      if (s.tag !== 3) throw Error(n(188));
      return s.stateNode.current === s ? i : r;
    }
    function f(i) {
      var r = i.tag;
      if (r === 5 || r === 26 || r === 27 || r === 6) return i;
      for (i = i.child; i !== null; ) {
        if (r = f(i), r !== null) return r;
        i = i.sibling;
      }
      return null;
    }
    var p = Object.assign, m = Symbol.for("react.element"), b = Symbol.for("react.transitional.element"), x = Symbol.for("react.portal"), _ = Symbol.for("react.fragment"), S = Symbol.for("react.strict_mode"), w = Symbol.for("react.profiler"), k = Symbol.for("react.provider"), A = Symbol.for("react.consumer"), L = Symbol.for("react.context"), $ = Symbol.for("react.forward_ref"), O = Symbol.for("react.suspense"), W = Symbol.for("react.suspense_list"), j = Symbol.for("react.memo"), et = Symbol.for("react.lazy"), nt = Symbol.for("react.activity"), lt = Symbol.for("react.memo_cache_sentinel"), X = Symbol.iterator;
    function at(i) {
      return i === null || typeof i != "object" ? null : (i = X && i[X] || i["@@iterator"], typeof i == "function" ? i : null);
    }
    var rt = Symbol.for("react.client.reference");
    function V(i) {
      if (i == null) return null;
      if (typeof i == "function") return i.$$typeof === rt ? null : i.displayName || i.name || null;
      if (typeof i == "string") return i;
      switch (i) {
        case _:
          return "Fragment";
        case w:
          return "Profiler";
        case S:
          return "StrictMode";
        case O:
          return "Suspense";
        case W:
          return "SuspenseList";
        case nt:
          return "Activity";
      }
      if (typeof i == "object") switch (i.$$typeof) {
        case x:
          return "Portal";
        case L:
          return (i.displayName || "Context") + ".Provider";
        case A:
          return (i._context.displayName || "Context") + ".Consumer";
        case $:
          var r = i.render;
          return i = i.displayName, i || (i = r.displayName || r.name || "", i = i !== "" ? "ForwardRef(" + i + ")" : "ForwardRef"), i;
        case j:
          return r = i.displayName || null, r !== null ? r : V(i.type) || "Memo";
        case et:
          r = i._payload, i = i._init;
          try {
            return V(i(r));
          } catch {
          }
      }
      return null;
    }
    var G = Array.isArray, E = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, N = a.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, F = {
      pending: false,
      data: null,
      method: null,
      action: null
    }, ot = [], M = -1;
    function Y(i) {
      return {
        current: i
      };
    }
    function K(i) {
      0 > M || (i.current = ot[M], ot[M] = null, M--);
    }
    function Z(i, r) {
      M++, ot[M] = i.current, i.current = r;
    }
    var ct = Y(null), ut = Y(null), pt = Y(null), Ht = Y(null);
    function qt(i, r) {
      switch (Z(pt, r), Z(ut, i), Z(ct, null), r.nodeType) {
        case 9:
        case 11:
          i = (i = r.documentElement) && (i = i.namespaceURI) ? mb(i) : 0;
          break;
        default:
          if (i = r.tagName, r = r.namespaceURI) r = mb(r), i = yb(r, i);
          else switch (i) {
            case "svg":
              i = 1;
              break;
            case "math":
              i = 2;
              break;
            default:
              i = 0;
          }
      }
      K(ct), Z(ct, i);
    }
    function he() {
      K(ct), K(ut), K(pt);
    }
    function re(i) {
      i.memoizedState !== null && Z(Ht, i);
      var r = ct.current, s = yb(r, i.type);
      r !== s && (Z(ut, i), Z(ct, s));
    }
    function qe(i) {
      ut.current === i && (K(ct), K(ut)), Ht.current === i && (K(Ht), Bs._currentValue = F);
    }
    var He = Object.prototype.hasOwnProperty, mi = t.unstable_scheduleCallback, Ii = t.unstable_cancelCallback, Rl = t.unstable_shouldYield, $l = t.unstable_requestPaint, Oe = t.unstable_now, En = t.unstable_getCurrentPriorityLevel, Fa = t.unstable_ImmediatePriority, Nl = t.unstable_UserBlockingPriority, qa = t.unstable_NormalPriority, Eh = t.unstable_LowPriority, Mn = t.unstable_IdlePriority, Ha = t.log, ta = t.unstable_setDisableYieldValue, Mi = null, Ue = null;
    function Pi(i) {
      if (typeof Ha == "function" && ta(i), Ue && typeof Ue.setStrictMode == "function") try {
        Ue.setStrictMode(Mi, i);
      } catch {
      }
    }
    var je = Math.clz32 ? Math.clz32 : Bn, zl = Math.log, Ro = Math.LN2;
    function Bn(i) {
      return i >>>= 0, i === 0 ? 32 : 31 - (zl(i) / Ro | 0) | 0;
    }
    var _r = 256, ni = 4194304;
    function li(i) {
      var r = i & 42;
      if (r !== 0) return r;
      switch (i & -i) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
          return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return i & 4194048;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return i & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return i;
      }
    }
    function ea(i, r, s) {
      var c = i.pendingLanes;
      if (c === 0) return 0;
      var g = 0, y = i.suspendedLanes, C = i.pingedLanes;
      i = i.warmLanes;
      var T = c & 134217727;
      return T !== 0 ? (c = T & ~y, c !== 0 ? g = li(c) : (C &= T, C !== 0 ? g = li(C) : s || (s = T & ~i, s !== 0 && (g = li(s))))) : (T = c & ~y, T !== 0 ? g = li(T) : C !== 0 ? g = li(C) : s || (s = c & ~i, s !== 0 && (g = li(s)))), g === 0 ? 0 : r !== 0 && r !== g && (r & y) === 0 && (y = g & -g, s = r & -r, y >= s || y === 32 && (s & 4194048) !== 0) ? r : g;
    }
    function Sr(i, r) {
      return (i.pendingLanes & ~(i.suspendedLanes & ~i.pingedLanes) & r) === 0;
    }
    function Mh(i, r) {
      switch (i) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return r + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return r + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function Ua() {
      var i = _r;
      return _r <<= 1, (_r & 4194048) === 0 && (_r = 256), i;
    }
    function ja() {
      var i = ni;
      return ni <<= 1, (ni & 62914560) === 0 && (ni = 4194304), i;
    }
    function Fl(i) {
      for (var r = [], s = 0; 31 > s; s++) r.push(i);
      return r;
    }
    function Gi(i, r) {
      i.pendingLanes |= r, r !== 268435456 && (i.suspendedLanes = 0, i.pingedLanes = 0, i.warmLanes = 0);
    }
    function Bh(i, r, s, c, g, y) {
      var C = i.pendingLanes;
      i.pendingLanes = s, i.suspendedLanes = 0, i.pingedLanes = 0, i.warmLanes = 0, i.expiredLanes &= s, i.entangledLanes &= s, i.errorRecoveryDisabledLanes &= s, i.shellSuspendCounter = 0;
      var T = i.entanglements, B = i.expirationTimes, U = i.hiddenUpdates;
      for (s = C & ~s; 0 < s; ) {
        var Q = 31 - je(s), tt = 1 << Q;
        T[Q] = 0, B[Q] = -1;
        var I = U[Q];
        if (I !== null) for (U[Q] = null, Q = 0; Q < I.length; Q++) {
          var P = I[Q];
          P !== null && (P.lane &= -536870913);
        }
        s &= ~tt;
      }
      c !== 0 && $o(i, c, 0), y !== 0 && g === 0 && i.tag !== 0 && (i.suspendedLanes |= y & ~(C & ~r));
    }
    function $o(i, r, s) {
      i.pendingLanes |= r, i.suspendedLanes &= ~r;
      var c = 31 - je(r);
      i.entangledLanes |= r, i.entanglements[c] = i.entanglements[c] | 1073741824 | s & 4194090;
    }
    function fe(i, r) {
      var s = i.entangledLanes |= r;
      for (i = i.entanglements; s; ) {
        var c = 31 - je(s), g = 1 << c;
        g & r | i[c] & r && (i[c] |= r), s &= ~g;
      }
    }
    function ar(i) {
      switch (i) {
        case 2:
          i = 1;
          break;
        case 8:
          i = 4;
          break;
        case 32:
          i = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          i = 128;
          break;
        case 268435456:
          i = 134217728;
          break;
        default:
          i = 0;
      }
      return i;
    }
    function ql(i) {
      return i &= -i, 2 < i ? 8 < i ? (i & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
    }
    function Hl() {
      var i = N.p;
      return i !== 0 ? i : (i = window.event, i === void 0 ? 32 : Nb(i.type));
    }
    function Ul(i, r) {
      var s = N.p;
      try {
        return N.p = i, r();
      } finally {
        N.p = s;
      }
    }
    var Wi = Math.random().toString(36).slice(2), _e2 = "__reactFiber$" + Wi, Ye = "__reactProps$" + Wi, De = "__reactContainer$" + Wi, nr = "__reactEvents$" + Wi, No = "__reactListeners$" + Wi, zo = "__reactHandles$" + Wi, Ln = "__reactResources$" + Wi, ia = "__reactMarker$" + Wi;
    function yi(i) {
      delete i[_e2], delete i[Ye], delete i[nr], delete i[No], delete i[zo];
    }
    function Cr(i) {
      var r = i[_e2];
      if (r) return r;
      for (var s = i.parentNode; s; ) {
        if (r = s[De] || s[_e2]) {
          if (s = r.alternate, r.child !== null || s !== null && s.child !== null) for (i = _b2(i); i !== null; ) {
            if (s = i[_e2]) return s;
            i = _b2(i);
          }
          return r;
        }
        i = s, s = i.parentNode;
      }
      return null;
    }
    function wr(i) {
      if (i = i[_e2] || i[De]) {
        var r = i.tag;
        if (r === 5 || r === 6 || r === 13 || r === 26 || r === 27 || r === 3) return i;
      }
      return null;
    }
    function ra(i) {
      var r = i.tag;
      if (r === 5 || r === 26 || r === 27 || r === 6) return i.stateNode;
      throw Error(n(33));
    }
    function Tr(i) {
      var r = i[Ln];
      return r || (r = i[Ln] = {
        hoistableStyles: /* @__PURE__ */ new Map(),
        hoistableScripts: /* @__PURE__ */ new Map()
      }), r;
    }
    function me(i) {
      i[ia] = true;
    }
    var _t = /* @__PURE__ */ new Set(), R = {};
    function st(i, r) {
      dt(i, r), dt(i + "Capture", r);
    }
    function dt(i, r) {
      for (R[i] = r, i = 0; i < r.length; i++) _t.add(r[i]);
    }
    var ee = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), Se = {}, oe = {};
    function Ie(i) {
      return He.call(oe, i) ? true : He.call(Se, i) ? false : ee.test(i) ? oe[i] = true : (Se[i] = true, false);
    }
    function si(i, r, s) {
      if (Ie(r)) if (s === null) i.removeAttribute(r);
      else {
        switch (typeof s) {
          case "undefined":
          case "function":
          case "symbol":
            i.removeAttribute(r);
            return;
          case "boolean":
            var c = r.toLowerCase().slice(0, 5);
            if (c !== "data-" && c !== "aria-") {
              i.removeAttribute(r);
              return;
            }
        }
        i.setAttribute(r, "" + s);
      }
    }
    function lr(i, r, s) {
      if (s === null) i.removeAttribute(r);
      else {
        switch (typeof s) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            i.removeAttribute(r);
            return;
        }
        i.setAttribute(r, "" + s);
      }
    }
    function bi(i, r, s, c) {
      if (c === null) i.removeAttribute(s);
      else {
        switch (typeof c) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            i.removeAttribute(s);
            return;
        }
        i.setAttributeNS(r, s, "" + c);
      }
    }
    var ye, jl;
    function kr(i) {
      if (ye === void 0) try {
        throw Error();
      } catch (s) {
        var r = s.stack.trim().match(/\n( *(at )?)/);
        ye = r && r[1] || "", jl = -1 < s.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < s.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
      return `
` + ye + i + jl;
    }
    var Lh = false;
    function Oh(i, r) {
      if (!i || Lh) return "";
      Lh = true;
      var s = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        var c = {
          DetermineComponentFrameRoot: function() {
            try {
              if (r) {
                var tt = function() {
                  throw Error();
                };
                if (Object.defineProperty(tt.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                }), typeof Reflect == "object" && Reflect.construct) {
                  try {
                    Reflect.construct(tt, []);
                  } catch (P) {
                    var I = P;
                  }
                  Reflect.construct(i, [], tt);
                } else {
                  try {
                    tt.call();
                  } catch (P) {
                    I = P;
                  }
                  i.call(tt.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (P) {
                  I = P;
                }
                (tt = i()) && typeof tt.catch == "function" && tt.catch(function() {
                });
              }
            } catch (P) {
              if (P && I && typeof P.stack == "string") return [
                P.stack,
                I.stack
              ];
            }
            return [
              null,
              null
            ];
          }
        };
        c.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var g = Object.getOwnPropertyDescriptor(c.DetermineComponentFrameRoot, "name");
        g && g.configurable && Object.defineProperty(c.DetermineComponentFrameRoot, "name", {
          value: "DetermineComponentFrameRoot"
        });
        var y = c.DetermineComponentFrameRoot(), C = y[0], T = y[1];
        if (C && T) {
          var B = C.split(`
`), U = T.split(`
`);
          for (g = c = 0; c < B.length && !B[c].includes("DetermineComponentFrameRoot"); ) c++;
          for (; g < U.length && !U[g].includes("DetermineComponentFrameRoot"); ) g++;
          if (c === B.length || g === U.length) for (c = B.length - 1, g = U.length - 1; 1 <= c && 0 <= g && B[c] !== U[g]; ) g--;
          for (; 1 <= c && 0 <= g; c--, g--) if (B[c] !== U[g]) {
            if (c !== 1 || g !== 1) do
              if (c--, g--, 0 > g || B[c] !== U[g]) {
                var Q = `
` + B[c].replace(" at new ", " at ");
                return i.displayName && Q.includes("<anonymous>") && (Q = Q.replace("<anonymous>", i.displayName)), Q;
              }
            while (1 <= c && 0 <= g);
            break;
          }
        }
      } finally {
        Lh = false, Error.prepareStackTrace = s;
      }
      return (s = i ? i.displayName || i.name : "") ? kr(s) : "";
    }
    function Kw(i) {
      switch (i.tag) {
        case 26:
        case 27:
        case 5:
          return kr(i.type);
        case 16:
          return kr("Lazy");
        case 13:
          return kr("Suspense");
        case 19:
          return kr("SuspenseList");
        case 0:
        case 15:
          return Oh(i.type, false);
        case 11:
          return Oh(i.type.render, false);
        case 1:
          return Oh(i.type, true);
        case 31:
          return kr("Activity");
        default:
          return "";
      }
    }
    function u0(i) {
      try {
        var r = "";
        do
          r += Kw(i), i = i.return;
        while (i);
        return r;
      } catch (s) {
        return `
Error generating stack: ` + s.message + `
` + s.stack;
      }
    }
    function Bi(i) {
      switch (typeof i) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return i;
        case "object":
          return i;
        default:
          return "";
      }
    }
    function h0(i) {
      var r = i.type;
      return (i = i.nodeName) && i.toLowerCase() === "input" && (r === "checkbox" || r === "radio");
    }
    function Jw(i) {
      var r = h0(i) ? "checked" : "value", s = Object.getOwnPropertyDescriptor(i.constructor.prototype, r), c = "" + i[r];
      if (!i.hasOwnProperty(r) && typeof s < "u" && typeof s.get == "function" && typeof s.set == "function") {
        var g = s.get, y = s.set;
        return Object.defineProperty(i, r, {
          configurable: true,
          get: function() {
            return g.call(this);
          },
          set: function(C) {
            c = "" + C, y.call(this, C);
          }
        }), Object.defineProperty(i, r, {
          enumerable: s.enumerable
        }), {
          getValue: function() {
            return c;
          },
          setValue: function(C) {
            c = "" + C;
          },
          stopTracking: function() {
            i._valueTracker = null, delete i[r];
          }
        };
      }
    }
    function Fo(i) {
      i._valueTracker || (i._valueTracker = Jw(i));
    }
    function f0(i) {
      if (!i) return false;
      var r = i._valueTracker;
      if (!r) return true;
      var s = r.getValue(), c = "";
      return i && (c = h0(i) ? i.checked ? "true" : "false" : i.value), i = c, i !== s ? (r.setValue(i), true) : false;
    }
    function qo(i) {
      if (i = i || (typeof document < "u" ? document : void 0), typeof i > "u") return null;
      try {
        return i.activeElement || i.body;
      } catch {
        return i.body;
      }
    }
    var tT = /[\n"\\]/g;
    function Li(i) {
      return i.replace(tT, function(r) {
        return "\\" + r.charCodeAt(0).toString(16) + " ";
      });
    }
    function Dh(i, r, s, c, g, y, C, T) {
      i.name = "", C != null && typeof C != "function" && typeof C != "symbol" && typeof C != "boolean" ? i.type = C : i.removeAttribute("type"), r != null ? C === "number" ? (r === 0 && i.value === "" || i.value != r) && (i.value = "" + Bi(r)) : i.value !== "" + Bi(r) && (i.value = "" + Bi(r)) : C !== "submit" && C !== "reset" || i.removeAttribute("value"), r != null ? Rh(i, C, Bi(r)) : s != null ? Rh(i, C, Bi(s)) : c != null && i.removeAttribute("value"), g == null && y != null && (i.defaultChecked = !!y), g != null && (i.checked = g && typeof g != "function" && typeof g != "symbol"), T != null && typeof T != "function" && typeof T != "symbol" && typeof T != "boolean" ? i.name = "" + Bi(T) : i.removeAttribute("name");
    }
    function d0(i, r, s, c, g, y, C, T) {
      if (y != null && typeof y != "function" && typeof y != "symbol" && typeof y != "boolean" && (i.type = y), r != null || s != null) {
        if (!(y !== "submit" && y !== "reset" || r != null)) return;
        s = s != null ? "" + Bi(s) : "", r = r != null ? "" + Bi(r) : s, T || r === i.value || (i.value = r), i.defaultValue = r;
      }
      c = c ?? g, c = typeof c != "function" && typeof c != "symbol" && !!c, i.checked = T ? i.checked : !!c, i.defaultChecked = !!c, C != null && typeof C != "function" && typeof C != "symbol" && typeof C != "boolean" && (i.name = C);
    }
    function Rh(i, r, s) {
      r === "number" && qo(i.ownerDocument) === i || i.defaultValue === "" + s || (i.defaultValue = "" + s);
    }
    function On(i, r, s, c) {
      if (i = i.options, r) {
        r = {};
        for (var g = 0; g < s.length; g++) r["$" + s[g]] = true;
        for (s = 0; s < i.length; s++) g = r.hasOwnProperty("$" + i[s].value), i[s].selected !== g && (i[s].selected = g), g && c && (i[s].defaultSelected = true);
      } else {
        for (s = "" + Bi(s), r = null, g = 0; g < i.length; g++) {
          if (i[g].value === s) {
            i[g].selected = true, c && (i[g].defaultSelected = true);
            return;
          }
          r !== null || i[g].disabled || (r = i[g]);
        }
        r !== null && (r.selected = true);
      }
    }
    function p0(i, r, s) {
      if (r != null && (r = "" + Bi(r), r !== i.value && (i.value = r), s == null)) {
        i.defaultValue !== r && (i.defaultValue = r);
        return;
      }
      i.defaultValue = s != null ? "" + Bi(s) : "";
    }
    function g0(i, r, s, c) {
      if (r == null) {
        if (c != null) {
          if (s != null) throw Error(n(92));
          if (G(c)) {
            if (1 < c.length) throw Error(n(93));
            c = c[0];
          }
          s = c;
        }
        s == null && (s = ""), r = s;
      }
      s = Bi(r), i.defaultValue = s, c = i.textContent, c === s && c !== "" && c !== null && (i.value = c);
    }
    function Dn(i, r) {
      if (r) {
        var s = i.firstChild;
        if (s && s === i.lastChild && s.nodeType === 3) {
          s.nodeValue = r;
          return;
        }
      }
      i.textContent = r;
    }
    var eT = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
    function m0(i, r, s) {
      var c = r.indexOf("--") === 0;
      s == null || typeof s == "boolean" || s === "" ? c ? i.setProperty(r, "") : r === "float" ? i.cssFloat = "" : i[r] = "" : c ? i.setProperty(r, s) : typeof s != "number" || s === 0 || eT.has(r) ? r === "float" ? i.cssFloat = s : i[r] = ("" + s).trim() : i[r] = s + "px";
    }
    function y0(i, r, s) {
      if (r != null && typeof r != "object") throw Error(n(62));
      if (i = i.style, s != null) {
        for (var c in s) !s.hasOwnProperty(c) || r != null && r.hasOwnProperty(c) || (c.indexOf("--") === 0 ? i.setProperty(c, "") : c === "float" ? i.cssFloat = "" : i[c] = "");
        for (var g in r) c = r[g], r.hasOwnProperty(g) && s[g] !== c && m0(i, g, c);
      } else for (var y in r) r.hasOwnProperty(y) && m0(i, y, r[y]);
    }
    function $h(i) {
      if (i.indexOf("-") === -1) return false;
      switch (i) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var iT = /* @__PURE__ */ new Map([
      [
        "acceptCharset",
        "accept-charset"
      ],
      [
        "htmlFor",
        "for"
      ],
      [
        "httpEquiv",
        "http-equiv"
      ],
      [
        "crossOrigin",
        "crossorigin"
      ],
      [
        "accentHeight",
        "accent-height"
      ],
      [
        "alignmentBaseline",
        "alignment-baseline"
      ],
      [
        "arabicForm",
        "arabic-form"
      ],
      [
        "baselineShift",
        "baseline-shift"
      ],
      [
        "capHeight",
        "cap-height"
      ],
      [
        "clipPath",
        "clip-path"
      ],
      [
        "clipRule",
        "clip-rule"
      ],
      [
        "colorInterpolation",
        "color-interpolation"
      ],
      [
        "colorInterpolationFilters",
        "color-interpolation-filters"
      ],
      [
        "colorProfile",
        "color-profile"
      ],
      [
        "colorRendering",
        "color-rendering"
      ],
      [
        "dominantBaseline",
        "dominant-baseline"
      ],
      [
        "enableBackground",
        "enable-background"
      ],
      [
        "fillOpacity",
        "fill-opacity"
      ],
      [
        "fillRule",
        "fill-rule"
      ],
      [
        "floodColor",
        "flood-color"
      ],
      [
        "floodOpacity",
        "flood-opacity"
      ],
      [
        "fontFamily",
        "font-family"
      ],
      [
        "fontSize",
        "font-size"
      ],
      [
        "fontSizeAdjust",
        "font-size-adjust"
      ],
      [
        "fontStretch",
        "font-stretch"
      ],
      [
        "fontStyle",
        "font-style"
      ],
      [
        "fontVariant",
        "font-variant"
      ],
      [
        "fontWeight",
        "font-weight"
      ],
      [
        "glyphName",
        "glyph-name"
      ],
      [
        "glyphOrientationHorizontal",
        "glyph-orientation-horizontal"
      ],
      [
        "glyphOrientationVertical",
        "glyph-orientation-vertical"
      ],
      [
        "horizAdvX",
        "horiz-adv-x"
      ],
      [
        "horizOriginX",
        "horiz-origin-x"
      ],
      [
        "imageRendering",
        "image-rendering"
      ],
      [
        "letterSpacing",
        "letter-spacing"
      ],
      [
        "lightingColor",
        "lighting-color"
      ],
      [
        "markerEnd",
        "marker-end"
      ],
      [
        "markerMid",
        "marker-mid"
      ],
      [
        "markerStart",
        "marker-start"
      ],
      [
        "overlinePosition",
        "overline-position"
      ],
      [
        "overlineThickness",
        "overline-thickness"
      ],
      [
        "paintOrder",
        "paint-order"
      ],
      [
        "panose-1",
        "panose-1"
      ],
      [
        "pointerEvents",
        "pointer-events"
      ],
      [
        "renderingIntent",
        "rendering-intent"
      ],
      [
        "shapeRendering",
        "shape-rendering"
      ],
      [
        "stopColor",
        "stop-color"
      ],
      [
        "stopOpacity",
        "stop-opacity"
      ],
      [
        "strikethroughPosition",
        "strikethrough-position"
      ],
      [
        "strikethroughThickness",
        "strikethrough-thickness"
      ],
      [
        "strokeDasharray",
        "stroke-dasharray"
      ],
      [
        "strokeDashoffset",
        "stroke-dashoffset"
      ],
      [
        "strokeLinecap",
        "stroke-linecap"
      ],
      [
        "strokeLinejoin",
        "stroke-linejoin"
      ],
      [
        "strokeMiterlimit",
        "stroke-miterlimit"
      ],
      [
        "strokeOpacity",
        "stroke-opacity"
      ],
      [
        "strokeWidth",
        "stroke-width"
      ],
      [
        "textAnchor",
        "text-anchor"
      ],
      [
        "textDecoration",
        "text-decoration"
      ],
      [
        "textRendering",
        "text-rendering"
      ],
      [
        "transformOrigin",
        "transform-origin"
      ],
      [
        "underlinePosition",
        "underline-position"
      ],
      [
        "underlineThickness",
        "underline-thickness"
      ],
      [
        "unicodeBidi",
        "unicode-bidi"
      ],
      [
        "unicodeRange",
        "unicode-range"
      ],
      [
        "unitsPerEm",
        "units-per-em"
      ],
      [
        "vAlphabetic",
        "v-alphabetic"
      ],
      [
        "vHanging",
        "v-hanging"
      ],
      [
        "vIdeographic",
        "v-ideographic"
      ],
      [
        "vMathematical",
        "v-mathematical"
      ],
      [
        "vectorEffect",
        "vector-effect"
      ],
      [
        "vertAdvY",
        "vert-adv-y"
      ],
      [
        "vertOriginX",
        "vert-origin-x"
      ],
      [
        "vertOriginY",
        "vert-origin-y"
      ],
      [
        "wordSpacing",
        "word-spacing"
      ],
      [
        "writingMode",
        "writing-mode"
      ],
      [
        "xmlnsXlink",
        "xmlns:xlink"
      ],
      [
        "xHeight",
        "x-height"
      ]
    ]), rT = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
    function Ho(i) {
      return rT.test("" + i) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : i;
    }
    var Nh = null;
    function zh(i) {
      return i = i.target || i.srcElement || window, i.correspondingUseElement && (i = i.correspondingUseElement), i.nodeType === 3 ? i.parentNode : i;
    }
    var Rn = null, $n = null;
    function b0(i) {
      var r = wr(i);
      if (r && (i = r.stateNode)) {
        var s = i[Ye] || null;
        t: switch (i = r.stateNode, r.type) {
          case "input":
            if (Dh(i, s.value, s.defaultValue, s.defaultValue, s.checked, s.defaultChecked, s.type, s.name), r = s.name, s.type === "radio" && r != null) {
              for (s = i; s.parentNode; ) s = s.parentNode;
              for (s = s.querySelectorAll('input[name="' + Li("" + r) + '"][type="radio"]'), r = 0; r < s.length; r++) {
                var c = s[r];
                if (c !== i && c.form === i.form) {
                  var g = c[Ye] || null;
                  if (!g) throw Error(n(90));
                  Dh(c, g.value, g.defaultValue, g.defaultValue, g.checked, g.defaultChecked, g.type, g.name);
                }
              }
              for (r = 0; r < s.length; r++) c = s[r], c.form === i.form && f0(c);
            }
            break t;
          case "textarea":
            p0(i, s.value, s.defaultValue);
            break t;
          case "select":
            r = s.value, r != null && On(i, !!s.multiple, r, false);
        }
      }
    }
    var Fh = false;
    function x0(i, r, s) {
      if (Fh) return i(r, s);
      Fh = true;
      try {
        var c = i(r);
        return c;
      } finally {
        if (Fh = false, (Rn !== null || $n !== null) && (Tc(), Rn && (r = Rn, i = $n, $n = Rn = null, b0(r), i))) for (r = 0; r < i.length; r++) b0(i[r]);
      }
    }
    function Yl(i, r) {
      var s = i.stateNode;
      if (s === null) return null;
      var c = s[Ye] || null;
      if (c === null) return null;
      s = c[r];
      t: switch (r) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (c = !c.disabled) || (i = i.type, c = !(i === "button" || i === "input" || i === "select" || i === "textarea")), i = !c;
          break t;
        default:
          i = false;
      }
      if (i) return null;
      if (s && typeof s != "function") throw Error(n(231, r, typeof s));
      return s;
    }
    var Ar = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), qh = false;
    if (Ar) try {
      var Il = {};
      Object.defineProperty(Il, "passive", {
        get: function() {
          qh = true;
        }
      }), window.addEventListener("test", Il, Il), window.removeEventListener("test", Il, Il);
    } catch {
      qh = false;
    }
    var aa = null, Hh = null, Uo = null;
    function v0() {
      if (Uo) return Uo;
      var i, r = Hh, s = r.length, c, g = "value" in aa ? aa.value : aa.textContent, y = g.length;
      for (i = 0; i < s && r[i] === g[i]; i++) ;
      var C = s - i;
      for (c = 1; c <= C && r[s - c] === g[y - c]; c++) ;
      return Uo = g.slice(i, 1 < c ? 1 - c : void 0);
    }
    function jo(i) {
      var r = i.keyCode;
      return "charCode" in i ? (i = i.charCode, i === 0 && r === 13 && (i = 13)) : i = r, i === 10 && (i = 13), 32 <= i || i === 13 ? i : 0;
    }
    function Yo() {
      return true;
    }
    function _0() {
      return false;
    }
    function oi(i) {
      function r(s, c, g, y, C) {
        this._reactName = s, this._targetInst = g, this.type = c, this.nativeEvent = y, this.target = C, this.currentTarget = null;
        for (var T in i) i.hasOwnProperty(T) && (s = i[T], this[T] = s ? s(y) : y[T]);
        return this.isDefaultPrevented = (y.defaultPrevented != null ? y.defaultPrevented : y.returnValue === false) ? Yo : _0, this.isPropagationStopped = _0, this;
      }
      return p(r.prototype, {
        preventDefault: function() {
          this.defaultPrevented = true;
          var s = this.nativeEvent;
          s && (s.preventDefault ? s.preventDefault() : typeof s.returnValue != "unknown" && (s.returnValue = false), this.isDefaultPrevented = Yo);
        },
        stopPropagation: function() {
          var s = this.nativeEvent;
          s && (s.stopPropagation ? s.stopPropagation() : typeof s.cancelBubble != "unknown" && (s.cancelBubble = true), this.isPropagationStopped = Yo);
        },
        persist: function() {
        },
        isPersistent: Yo
      }), r;
    }
    var Ya = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(i) {
        return i.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, Io = oi(Ya), Pl = p({}, Ya, {
      view: 0,
      detail: 0
    }), aT = oi(Pl), Uh, jh, Gl, Po = p({}, Pl, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Ih,
      button: 0,
      buttons: 0,
      relatedTarget: function(i) {
        return i.relatedTarget === void 0 ? i.fromElement === i.srcElement ? i.toElement : i.fromElement : i.relatedTarget;
      },
      movementX: function(i) {
        return "movementX" in i ? i.movementX : (i !== Gl && (Gl && i.type === "mousemove" ? (Uh = i.screenX - Gl.screenX, jh = i.screenY - Gl.screenY) : jh = Uh = 0, Gl = i), Uh);
      },
      movementY: function(i) {
        return "movementY" in i ? i.movementY : jh;
      }
    }), S0 = oi(Po), nT = p({}, Po, {
      dataTransfer: 0
    }), lT = oi(nT), sT = p({}, Pl, {
      relatedTarget: 0
    }), Yh = oi(sT), oT = p({}, Ya, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), cT = oi(oT), uT = p({}, Ya, {
      clipboardData: function(i) {
        return "clipboardData" in i ? i.clipboardData : window.clipboardData;
      }
    }), hT = oi(uT), fT = p({}, Ya, {
      data: 0
    }), C0 = oi(fT), dT = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, pT = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, gT = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function mT(i) {
      var r = this.nativeEvent;
      return r.getModifierState ? r.getModifierState(i) : (i = gT[i]) ? !!r[i] : false;
    }
    function Ih() {
      return mT;
    }
    var yT = p({}, Pl, {
      key: function(i) {
        if (i.key) {
          var r = dT[i.key] || i.key;
          if (r !== "Unidentified") return r;
        }
        return i.type === "keypress" ? (i = jo(i), i === 13 ? "Enter" : String.fromCharCode(i)) : i.type === "keydown" || i.type === "keyup" ? pT[i.keyCode] || "Unidentified" : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Ih,
      charCode: function(i) {
        return i.type === "keypress" ? jo(i) : 0;
      },
      keyCode: function(i) {
        return i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0;
      },
      which: function(i) {
        return i.type === "keypress" ? jo(i) : i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0;
      }
    }), bT = oi(yT), xT = p({}, Po, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), w0 = oi(xT), vT = p({}, Pl, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Ih
    }), _T = oi(vT), ST = p({}, Ya, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), CT = oi(ST), wT = p({}, Po, {
      deltaX: function(i) {
        return "deltaX" in i ? i.deltaX : "wheelDeltaX" in i ? -i.wheelDeltaX : 0;
      },
      deltaY: function(i) {
        return "deltaY" in i ? i.deltaY : "wheelDeltaY" in i ? -i.wheelDeltaY : "wheelDelta" in i ? -i.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), TT = oi(wT), kT = p({}, Ya, {
      newState: 0,
      oldState: 0
    }), AT = oi(kT), ET = [
      9,
      13,
      27,
      32
    ], Ph = Ar && "CompositionEvent" in window, Wl = null;
    Ar && "documentMode" in document && (Wl = document.documentMode);
    var MT = Ar && "TextEvent" in window && !Wl, T0 = Ar && (!Ph || Wl && 8 < Wl && 11 >= Wl), k0 = " ", A0 = false;
    function E0(i, r) {
      switch (i) {
        case "keyup":
          return ET.indexOf(r.keyCode) !== -1;
        case "keydown":
          return r.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function M0(i) {
      return i = i.detail, typeof i == "object" && "data" in i ? i.data : null;
    }
    var Nn = false;
    function BT(i, r) {
      switch (i) {
        case "compositionend":
          return M0(r);
        case "keypress":
          return r.which !== 32 ? null : (A0 = true, k0);
        case "textInput":
          return i = r.data, i === k0 && A0 ? null : i;
        default:
          return null;
      }
    }
    function LT(i, r) {
      if (Nn) return i === "compositionend" || !Ph && E0(i, r) ? (i = v0(), Uo = Hh = aa = null, Nn = false, i) : null;
      switch (i) {
        case "paste":
          return null;
        case "keypress":
          if (!(r.ctrlKey || r.altKey || r.metaKey) || r.ctrlKey && r.altKey) {
            if (r.char && 1 < r.char.length) return r.char;
            if (r.which) return String.fromCharCode(r.which);
          }
          return null;
        case "compositionend":
          return T0 && r.locale !== "ko" ? null : r.data;
        default:
          return null;
      }
    }
    var OT = {
      color: true,
      date: true,
      datetime: true,
      "datetime-local": true,
      email: true,
      month: true,
      number: true,
      password: true,
      range: true,
      search: true,
      tel: true,
      text: true,
      time: true,
      url: true,
      week: true
    };
    function B0(i) {
      var r = i && i.nodeName && i.nodeName.toLowerCase();
      return r === "input" ? !!OT[i.type] : r === "textarea";
    }
    function L0(i, r, s, c) {
      Rn ? $n ? $n.push(c) : $n = [
        c
      ] : Rn = c, r = Lc(r, "onChange"), 0 < r.length && (s = new Io("onChange", "change", null, s, c), i.push({
        event: s,
        listeners: r
      }));
    }
    var Xl = null, Vl = null;
    function DT(i) {
      hb(i, 0);
    }
    function Go(i) {
      var r = ra(i);
      if (f0(r)) return i;
    }
    function O0(i, r) {
      if (i === "change") return r;
    }
    var D0 = false;
    if (Ar) {
      var Gh;
      if (Ar) {
        var Wh = "oninput" in document;
        if (!Wh) {
          var R0 = document.createElement("div");
          R0.setAttribute("oninput", "return;"), Wh = typeof R0.oninput == "function";
        }
        Gh = Wh;
      } else Gh = false;
      D0 = Gh && (!document.documentMode || 9 < document.documentMode);
    }
    function $0() {
      Xl && (Xl.detachEvent("onpropertychange", N0), Vl = Xl = null);
    }
    function N0(i) {
      if (i.propertyName === "value" && Go(Vl)) {
        var r = [];
        L0(r, Vl, i, zh(i)), x0(DT, r);
      }
    }
    function RT(i, r, s) {
      i === "focusin" ? ($0(), Xl = r, Vl = s, Xl.attachEvent("onpropertychange", N0)) : i === "focusout" && $0();
    }
    function $T(i) {
      if (i === "selectionchange" || i === "keyup" || i === "keydown") return Go(Vl);
    }
    function NT(i, r) {
      if (i === "click") return Go(r);
    }
    function zT(i, r) {
      if (i === "input" || i === "change") return Go(r);
    }
    function FT(i, r) {
      return i === r && (i !== 0 || 1 / i === 1 / r) || i !== i && r !== r;
    }
    var xi = typeof Object.is == "function" ? Object.is : FT;
    function Zl(i, r) {
      if (xi(i, r)) return true;
      if (typeof i != "object" || i === null || typeof r != "object" || r === null) return false;
      var s = Object.keys(i), c = Object.keys(r);
      if (s.length !== c.length) return false;
      for (c = 0; c < s.length; c++) {
        var g = s[c];
        if (!He.call(r, g) || !xi(i[g], r[g])) return false;
      }
      return true;
    }
    function z0(i) {
      for (; i && i.firstChild; ) i = i.firstChild;
      return i;
    }
    function F0(i, r) {
      var s = z0(i);
      i = 0;
      for (var c; s; ) {
        if (s.nodeType === 3) {
          if (c = i + s.textContent.length, i <= r && c >= r) return {
            node: s,
            offset: r - i
          };
          i = c;
        }
        t: {
          for (; s; ) {
            if (s.nextSibling) {
              s = s.nextSibling;
              break t;
            }
            s = s.parentNode;
          }
          s = void 0;
        }
        s = z0(s);
      }
    }
    function q0(i, r) {
      return i && r ? i === r ? true : i && i.nodeType === 3 ? false : r && r.nodeType === 3 ? q0(i, r.parentNode) : "contains" in i ? i.contains(r) : i.compareDocumentPosition ? !!(i.compareDocumentPosition(r) & 16) : false : false;
    }
    function H0(i) {
      i = i != null && i.ownerDocument != null && i.ownerDocument.defaultView != null ? i.ownerDocument.defaultView : window;
      for (var r = qo(i.document); r instanceof i.HTMLIFrameElement; ) {
        try {
          var s = typeof r.contentWindow.location.href == "string";
        } catch {
          s = false;
        }
        if (s) i = r.contentWindow;
        else break;
        r = qo(i.document);
      }
      return r;
    }
    function Xh(i) {
      var r = i && i.nodeName && i.nodeName.toLowerCase();
      return r && (r === "input" && (i.type === "text" || i.type === "search" || i.type === "tel" || i.type === "url" || i.type === "password") || r === "textarea" || i.contentEditable === "true");
    }
    var qT = Ar && "documentMode" in document && 11 >= document.documentMode, zn = null, Vh = null, Ql = null, Zh = false;
    function U0(i, r, s) {
      var c = s.window === s ? s.document : s.nodeType === 9 ? s : s.ownerDocument;
      Zh || zn == null || zn !== qo(c) || (c = zn, "selectionStart" in c && Xh(c) ? c = {
        start: c.selectionStart,
        end: c.selectionEnd
      } : (c = (c.ownerDocument && c.ownerDocument.defaultView || window).getSelection(), c = {
        anchorNode: c.anchorNode,
        anchorOffset: c.anchorOffset,
        focusNode: c.focusNode,
        focusOffset: c.focusOffset
      }), Ql && Zl(Ql, c) || (Ql = c, c = Lc(Vh, "onSelect"), 0 < c.length && (r = new Io("onSelect", "select", null, r, s), i.push({
        event: r,
        listeners: c
      }), r.target = zn)));
    }
    function Ia(i, r) {
      var s = {};
      return s[i.toLowerCase()] = r.toLowerCase(), s["Webkit" + i] = "webkit" + r, s["Moz" + i] = "moz" + r, s;
    }
    var Fn = {
      animationend: Ia("Animation", "AnimationEnd"),
      animationiteration: Ia("Animation", "AnimationIteration"),
      animationstart: Ia("Animation", "AnimationStart"),
      transitionrun: Ia("Transition", "TransitionRun"),
      transitionstart: Ia("Transition", "TransitionStart"),
      transitioncancel: Ia("Transition", "TransitionCancel"),
      transitionend: Ia("Transition", "TransitionEnd")
    }, Qh = {}, j0 = {};
    Ar && (j0 = document.createElement("div").style, "AnimationEvent" in window || (delete Fn.animationend.animation, delete Fn.animationiteration.animation, delete Fn.animationstart.animation), "TransitionEvent" in window || delete Fn.transitionend.transition);
    function Pa(i) {
      if (Qh[i]) return Qh[i];
      if (!Fn[i]) return i;
      var r = Fn[i], s;
      for (s in r) if (r.hasOwnProperty(s) && s in j0) return Qh[i] = r[s];
      return i;
    }
    var Y0 = Pa("animationend"), I0 = Pa("animationiteration"), P0 = Pa("animationstart"), HT = Pa("transitionrun"), UT = Pa("transitionstart"), jT = Pa("transitioncancel"), G0 = Pa("transitionend"), W0 = /* @__PURE__ */ new Map(), Kh = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    Kh.push("scrollEnd");
    function Xi(i, r) {
      W0.set(i, r), st(r, [
        i
      ]);
    }
    var X0 = /* @__PURE__ */ new WeakMap();
    function Oi(i, r) {
      if (typeof i == "object" && i !== null) {
        var s = X0.get(i);
        return s !== void 0 ? s : (r = {
          value: i,
          source: r,
          stack: u0(r)
        }, X0.set(i, r), r);
      }
      return {
        value: i,
        source: r,
        stack: u0(r)
      };
    }
    var Di = [], qn = 0, Jh = 0;
    function Wo() {
      for (var i = qn, r = Jh = qn = 0; r < i; ) {
        var s = Di[r];
        Di[r++] = null;
        var c = Di[r];
        Di[r++] = null;
        var g = Di[r];
        Di[r++] = null;
        var y = Di[r];
        if (Di[r++] = null, c !== null && g !== null) {
          var C = c.pending;
          C === null ? g.next = g : (g.next = C.next, C.next = g), c.pending = g;
        }
        y !== 0 && V0(s, g, y);
      }
    }
    function Xo(i, r, s, c) {
      Di[qn++] = i, Di[qn++] = r, Di[qn++] = s, Di[qn++] = c, Jh |= c, i.lanes |= c, i = i.alternate, i !== null && (i.lanes |= c);
    }
    function tf(i, r, s, c) {
      return Xo(i, r, s, c), Vo(i);
    }
    function Hn(i, r) {
      return Xo(i, null, null, r), Vo(i);
    }
    function V0(i, r, s) {
      i.lanes |= s;
      var c = i.alternate;
      c !== null && (c.lanes |= s);
      for (var g = false, y = i.return; y !== null; ) y.childLanes |= s, c = y.alternate, c !== null && (c.childLanes |= s), y.tag === 22 && (i = y.stateNode, i === null || i._visibility & 1 || (g = true)), i = y, y = y.return;
      return i.tag === 3 ? (y = i.stateNode, g && r !== null && (g = 31 - je(s), i = y.hiddenUpdates, c = i[g], c === null ? i[g] = [
        r
      ] : c.push(r), r.lane = s | 536870912), y) : null;
    }
    function Vo(i) {
      if (50 < Ss) throw Ss = 0, sd = null, Error(n(185));
      for (var r = i.return; r !== null; ) i = r, r = i.return;
      return i.tag === 3 ? i.stateNode : null;
    }
    var Un = {};
    function YT(i, r, s, c) {
      this.tag = i, this.key = s, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = r, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = c, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
    }
    function vi(i, r, s, c) {
      return new YT(i, r, s, c);
    }
    function ef(i) {
      return i = i.prototype, !(!i || !i.isReactComponent);
    }
    function Er(i, r) {
      var s = i.alternate;
      return s === null ? (s = vi(i.tag, r, i.key, i.mode), s.elementType = i.elementType, s.type = i.type, s.stateNode = i.stateNode, s.alternate = i, i.alternate = s) : (s.pendingProps = r, s.type = i.type, s.flags = 0, s.subtreeFlags = 0, s.deletions = null), s.flags = i.flags & 65011712, s.childLanes = i.childLanes, s.lanes = i.lanes, s.child = i.child, s.memoizedProps = i.memoizedProps, s.memoizedState = i.memoizedState, s.updateQueue = i.updateQueue, r = i.dependencies, s.dependencies = r === null ? null : {
        lanes: r.lanes,
        firstContext: r.firstContext
      }, s.sibling = i.sibling, s.index = i.index, s.ref = i.ref, s.refCleanup = i.refCleanup, s;
    }
    function Z0(i, r) {
      i.flags &= 65011714;
      var s = i.alternate;
      return s === null ? (i.childLanes = 0, i.lanes = r, i.child = null, i.subtreeFlags = 0, i.memoizedProps = null, i.memoizedState = null, i.updateQueue = null, i.dependencies = null, i.stateNode = null) : (i.childLanes = s.childLanes, i.lanes = s.lanes, i.child = s.child, i.subtreeFlags = 0, i.deletions = null, i.memoizedProps = s.memoizedProps, i.memoizedState = s.memoizedState, i.updateQueue = s.updateQueue, i.type = s.type, r = s.dependencies, i.dependencies = r === null ? null : {
        lanes: r.lanes,
        firstContext: r.firstContext
      }), i;
    }
    function Zo(i, r, s, c, g, y) {
      var C = 0;
      if (c = i, typeof i == "function") ef(i) && (C = 1);
      else if (typeof i == "string") C = Pk(i, s, ct.current) ? 26 : i === "html" || i === "head" || i === "body" ? 27 : 5;
      else t: switch (i) {
        case nt:
          return i = vi(31, s, r, g), i.elementType = nt, i.lanes = y, i;
        case _:
          return Ga(s.children, g, y, r);
        case S:
          C = 8, g |= 24;
          break;
        case w:
          return i = vi(12, s, r, g | 2), i.elementType = w, i.lanes = y, i;
        case O:
          return i = vi(13, s, r, g), i.elementType = O, i.lanes = y, i;
        case W:
          return i = vi(19, s, r, g), i.elementType = W, i.lanes = y, i;
        default:
          if (typeof i == "object" && i !== null) switch (i.$$typeof) {
            case k:
            case L:
              C = 10;
              break t;
            case A:
              C = 9;
              break t;
            case $:
              C = 11;
              break t;
            case j:
              C = 14;
              break t;
            case et:
              C = 16, c = null;
              break t;
          }
          C = 29, s = Error(n(130, i === null ? "null" : typeof i, "")), c = null;
      }
      return r = vi(C, s, r, g), r.elementType = i, r.type = c, r.lanes = y, r;
    }
    function Ga(i, r, s, c) {
      return i = vi(7, i, c, r), i.lanes = s, i;
    }
    function rf(i, r, s) {
      return i = vi(6, i, null, r), i.lanes = s, i;
    }
    function af(i, r, s) {
      return r = vi(4, i.children !== null ? i.children : [], i.key, r), r.lanes = s, r.stateNode = {
        containerInfo: i.containerInfo,
        pendingChildren: null,
        implementation: i.implementation
      }, r;
    }
    var jn = [], Yn = 0, Qo = null, Ko = 0, Ri = [], $i = 0, Wa = null, Mr = 1, Br = "";
    function Xa(i, r) {
      jn[Yn++] = Ko, jn[Yn++] = Qo, Qo = i, Ko = r;
    }
    function Q0(i, r, s) {
      Ri[$i++] = Mr, Ri[$i++] = Br, Ri[$i++] = Wa, Wa = i;
      var c = Mr;
      i = Br;
      var g = 32 - je(c) - 1;
      c &= ~(1 << g), s += 1;
      var y = 32 - je(r) + g;
      if (30 < y) {
        var C = g - g % 5;
        y = (c & (1 << C) - 1).toString(32), c >>= C, g -= C, Mr = 1 << 32 - je(r) + g | s << g | c, Br = y + i;
      } else Mr = 1 << y | s << g | c, Br = i;
    }
    function nf(i) {
      i.return !== null && (Xa(i, 1), Q0(i, 1, 0));
    }
    function lf(i) {
      for (; i === Qo; ) Qo = jn[--Yn], jn[Yn] = null, Ko = jn[--Yn], jn[Yn] = null;
      for (; i === Wa; ) Wa = Ri[--$i], Ri[$i] = null, Br = Ri[--$i], Ri[$i] = null, Mr = Ri[--$i], Ri[$i] = null;
    }
    var Ke = null, ce = null, It = false, Va = null, sr = false, sf = Error(n(519));
    function Za(i) {
      var r = Error(n(418, ""));
      throw ts(Oi(r, i)), sf;
    }
    function K0(i) {
      var r = i.stateNode, s = i.type, c = i.memoizedProps;
      switch (r[_e2] = i, r[Ye] = c, s) {
        case "dialog":
          Nt("cancel", r), Nt("close", r);
          break;
        case "iframe":
        case "object":
        case "embed":
          Nt("load", r);
          break;
        case "video":
        case "audio":
          for (s = 0; s < ws.length; s++) Nt(ws[s], r);
          break;
        case "source":
          Nt("error", r);
          break;
        case "img":
        case "image":
        case "link":
          Nt("error", r), Nt("load", r);
          break;
        case "details":
          Nt("toggle", r);
          break;
        case "input":
          Nt("invalid", r), d0(r, c.value, c.defaultValue, c.checked, c.defaultChecked, c.type, c.name, true), Fo(r);
          break;
        case "select":
          Nt("invalid", r);
          break;
        case "textarea":
          Nt("invalid", r), g0(r, c.value, c.defaultValue, c.children), Fo(r);
      }
      s = c.children, typeof s != "string" && typeof s != "number" && typeof s != "bigint" || r.textContent === "" + s || c.suppressHydrationWarning === true || gb(r.textContent, s) ? (c.popover != null && (Nt("beforetoggle", r), Nt("toggle", r)), c.onScroll != null && Nt("scroll", r), c.onScrollEnd != null && Nt("scrollend", r), c.onClick != null && (r.onclick = Oc), r = true) : r = false, r || Za(i);
    }
    function J0(i) {
      for (Ke = i.return; Ke; ) switch (Ke.tag) {
        case 5:
        case 13:
          sr = false;
          return;
        case 27:
        case 3:
          sr = true;
          return;
        default:
          Ke = Ke.return;
      }
    }
    function Kl(i) {
      if (i !== Ke) return false;
      if (!It) return J0(i), It = true, false;
      var r = i.tag, s;
      if ((s = r !== 3 && r !== 27) && ((s = r === 5) && (s = i.type, s = !(s !== "form" && s !== "button") || Cd(i.type, i.memoizedProps)), s = !s), s && ce && Za(i), J0(i), r === 13) {
        if (i = i.memoizedState, i = i !== null ? i.dehydrated : null, !i) throw Error(n(317));
        t: {
          for (i = i.nextSibling, r = 0; i; ) {
            if (i.nodeType === 8) if (s = i.data, s === "/$") {
              if (r === 0) {
                ce = Zi(i.nextSibling);
                break t;
              }
              r--;
            } else s !== "$" && s !== "$!" && s !== "$?" || r++;
            i = i.nextSibling;
          }
          ce = null;
        }
      } else r === 27 ? (r = ce, va(i.type) ? (i = Ad, Ad = null, ce = i) : ce = r) : ce = Ke ? Zi(i.stateNode.nextSibling) : null;
      return true;
    }
    function Jl() {
      ce = Ke = null, It = false;
    }
    function tm() {
      var i = Va;
      return i !== null && (hi === null ? hi = i : hi.push.apply(hi, i), Va = null), i;
    }
    function ts(i) {
      Va === null ? Va = [
        i
      ] : Va.push(i);
    }
    var of = Y(null), Qa = null, Lr = null;
    function na(i, r, s) {
      Z(of, r._currentValue), r._currentValue = s;
    }
    function Or(i) {
      i._currentValue = of.current, K(of);
    }
    function cf(i, r, s) {
      for (; i !== null; ) {
        var c = i.alternate;
        if ((i.childLanes & r) !== r ? (i.childLanes |= r, c !== null && (c.childLanes |= r)) : c !== null && (c.childLanes & r) !== r && (c.childLanes |= r), i === s) break;
        i = i.return;
      }
    }
    function uf(i, r, s, c) {
      var g = i.child;
      for (g !== null && (g.return = i); g !== null; ) {
        var y = g.dependencies;
        if (y !== null) {
          var C = g.child;
          y = y.firstContext;
          t: for (; y !== null; ) {
            var T = y;
            y = g;
            for (var B = 0; B < r.length; B++) if (T.context === r[B]) {
              y.lanes |= s, T = y.alternate, T !== null && (T.lanes |= s), cf(y.return, s, i), c || (C = null);
              break t;
            }
            y = T.next;
          }
        } else if (g.tag === 18) {
          if (C = g.return, C === null) throw Error(n(341));
          C.lanes |= s, y = C.alternate, y !== null && (y.lanes |= s), cf(C, s, i), C = null;
        } else C = g.child;
        if (C !== null) C.return = g;
        else for (C = g; C !== null; ) {
          if (C === i) {
            C = null;
            break;
          }
          if (g = C.sibling, g !== null) {
            g.return = C.return, C = g;
            break;
          }
          C = C.return;
        }
        g = C;
      }
    }
    function es(i, r, s, c) {
      i = null;
      for (var g = r, y = false; g !== null; ) {
        if (!y) {
          if ((g.flags & 524288) !== 0) y = true;
          else if ((g.flags & 262144) !== 0) break;
        }
        if (g.tag === 10) {
          var C = g.alternate;
          if (C === null) throw Error(n(387));
          if (C = C.memoizedProps, C !== null) {
            var T = g.type;
            xi(g.pendingProps.value, C.value) || (i !== null ? i.push(T) : i = [
              T
            ]);
          }
        } else if (g === Ht.current) {
          if (C = g.alternate, C === null) throw Error(n(387));
          C.memoizedState.memoizedState !== g.memoizedState.memoizedState && (i !== null ? i.push(Bs) : i = [
            Bs
          ]);
        }
        g = g.return;
      }
      i !== null && uf(r, i, s, c), r.flags |= 262144;
    }
    function Jo(i) {
      for (i = i.firstContext; i !== null; ) {
        if (!xi(i.context._currentValue, i.memoizedValue)) return true;
        i = i.next;
      }
      return false;
    }
    function Ka(i) {
      Qa = i, Lr = null, i = i.dependencies, i !== null && (i.firstContext = null);
    }
    function Pe(i) {
      return em(Qa, i);
    }
    function tc(i, r) {
      return Qa === null && Ka(i), em(i, r);
    }
    function em(i, r) {
      var s = r._currentValue;
      if (r = {
        context: r,
        memoizedValue: s,
        next: null
      }, Lr === null) {
        if (i === null) throw Error(n(308));
        Lr = r, i.dependencies = {
          lanes: 0,
          firstContext: r
        }, i.flags |= 524288;
      } else Lr = Lr.next = r;
      return s;
    }
    var IT = typeof AbortController < "u" ? AbortController : function() {
      var i = [], r = this.signal = {
        aborted: false,
        addEventListener: function(s, c) {
          i.push(c);
        }
      };
      this.abort = function() {
        r.aborted = true, i.forEach(function(s) {
          return s();
        });
      };
    }, PT = t.unstable_scheduleCallback, GT = t.unstable_NormalPriority, Ce = {
      $$typeof: L,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0
    };
    function hf() {
      return {
        controller: new IT(),
        data: /* @__PURE__ */ new Map(),
        refCount: 0
      };
    }
    function is(i) {
      i.refCount--, i.refCount === 0 && PT(GT, function() {
        i.controller.abort();
      });
    }
    var rs = null, ff = 0, In = 0, Pn = null;
    function WT(i, r) {
      if (rs === null) {
        var s = rs = [];
        ff = 0, In = pd(), Pn = {
          status: "pending",
          value: void 0,
          then: function(c) {
            s.push(c);
          }
        };
      }
      return ff++, r.then(im, im), r;
    }
    function im() {
      if (--ff === 0 && rs !== null) {
        Pn !== null && (Pn.status = "fulfilled");
        var i = rs;
        rs = null, In = 0, Pn = null;
        for (var r = 0; r < i.length; r++) (0, i[r])();
      }
    }
    function XT(i, r) {
      var s = [], c = {
        status: "pending",
        value: null,
        reason: null,
        then: function(g) {
          s.push(g);
        }
      };
      return i.then(function() {
        c.status = "fulfilled", c.value = r;
        for (var g = 0; g < s.length; g++) (0, s[g])(r);
      }, function(g) {
        for (c.status = "rejected", c.reason = g, g = 0; g < s.length; g++) (0, s[g])(void 0);
      }), c;
    }
    var rm = E.S;
    E.S = function(i, r) {
      typeof r == "object" && r !== null && typeof r.then == "function" && WT(i, r), rm !== null && rm(i, r);
    };
    var Ja = Y(null);
    function df() {
      var i = Ja.current;
      return i !== null ? i : ie.pooledCache;
    }
    function ec(i, r) {
      r === null ? Z(Ja, Ja.current) : Z(Ja, r.pool);
    }
    function am() {
      var i = df();
      return i === null ? null : {
        parent: Ce._currentValue,
        pool: i
      };
    }
    var as = Error(n(460)), nm = Error(n(474)), ic = Error(n(542)), pf = {
      then: function() {
      }
    };
    function lm(i) {
      return i = i.status, i === "fulfilled" || i === "rejected";
    }
    function rc() {
    }
    function sm(i, r, s) {
      switch (s = i[s], s === void 0 ? i.push(r) : s !== r && (r.then(rc, rc), r = s), r.status) {
        case "fulfilled":
          return r.value;
        case "rejected":
          throw i = r.reason, cm(i), i;
        default:
          if (typeof r.status == "string") r.then(rc, rc);
          else {
            if (i = ie, i !== null && 100 < i.shellSuspendCounter) throw Error(n(482));
            i = r, i.status = "pending", i.then(function(c) {
              if (r.status === "pending") {
                var g = r;
                g.status = "fulfilled", g.value = c;
              }
            }, function(c) {
              if (r.status === "pending") {
                var g = r;
                g.status = "rejected", g.reason = c;
              }
            });
          }
          switch (r.status) {
            case "fulfilled":
              return r.value;
            case "rejected":
              throw i = r.reason, cm(i), i;
          }
          throw ns = r, as;
      }
    }
    var ns = null;
    function om() {
      if (ns === null) throw Error(n(459));
      var i = ns;
      return ns = null, i;
    }
    function cm(i) {
      if (i === as || i === ic) throw Error(n(483));
    }
    var la = false;
    function gf(i) {
      i.updateQueue = {
        baseState: i.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          lanes: 0,
          hiddenCallbacks: null
        },
        callbacks: null
      };
    }
    function mf(i, r) {
      i = i.updateQueue, r.updateQueue === i && (r.updateQueue = {
        baseState: i.baseState,
        firstBaseUpdate: i.firstBaseUpdate,
        lastBaseUpdate: i.lastBaseUpdate,
        shared: i.shared,
        callbacks: null
      });
    }
    function sa(i) {
      return {
        lane: i,
        tag: 0,
        payload: null,
        callback: null,
        next: null
      };
    }
    function oa(i, r, s) {
      var c = i.updateQueue;
      if (c === null) return null;
      if (c = c.shared, (Vt & 2) !== 0) {
        var g = c.pending;
        return g === null ? r.next = r : (r.next = g.next, g.next = r), c.pending = r, r = Vo(i), V0(i, null, s), r;
      }
      return Xo(i, c, r, s), Vo(i);
    }
    function ls(i, r, s) {
      if (r = r.updateQueue, r !== null && (r = r.shared, (s & 4194048) !== 0)) {
        var c = r.lanes;
        c &= i.pendingLanes, s |= c, r.lanes = s, fe(i, s);
      }
    }
    function yf(i, r) {
      var s = i.updateQueue, c = i.alternate;
      if (c !== null && (c = c.updateQueue, s === c)) {
        var g = null, y = null;
        if (s = s.firstBaseUpdate, s !== null) {
          do {
            var C = {
              lane: s.lane,
              tag: s.tag,
              payload: s.payload,
              callback: null,
              next: null
            };
            y === null ? g = y = C : y = y.next = C, s = s.next;
          } while (s !== null);
          y === null ? g = y = r : y = y.next = r;
        } else g = y = r;
        s = {
          baseState: c.baseState,
          firstBaseUpdate: g,
          lastBaseUpdate: y,
          shared: c.shared,
          callbacks: c.callbacks
        }, i.updateQueue = s;
        return;
      }
      i = s.lastBaseUpdate, i === null ? s.firstBaseUpdate = r : i.next = r, s.lastBaseUpdate = r;
    }
    var bf = false;
    function ss() {
      if (bf) {
        var i = Pn;
        if (i !== null) throw i;
      }
    }
    function os(i, r, s, c) {
      bf = false;
      var g = i.updateQueue;
      la = false;
      var y = g.firstBaseUpdate, C = g.lastBaseUpdate, T = g.shared.pending;
      if (T !== null) {
        g.shared.pending = null;
        var B = T, U = B.next;
        B.next = null, C === null ? y = U : C.next = U, C = B;
        var Q = i.alternate;
        Q !== null && (Q = Q.updateQueue, T = Q.lastBaseUpdate, T !== C && (T === null ? Q.firstBaseUpdate = U : T.next = U, Q.lastBaseUpdate = B));
      }
      if (y !== null) {
        var tt = g.baseState;
        C = 0, Q = U = B = null, T = y;
        do {
          var I = T.lane & -536870913, P = I !== T.lane;
          if (P ? (Ut & I) === I : (c & I) === I) {
            I !== 0 && I === In && (bf = true), Q !== null && (Q = Q.next = {
              lane: 0,
              tag: T.tag,
              payload: T.payload,
              callback: null,
              next: null
            });
            t: {
              var Bt = i, kt = T;
              I = r;
              var Jt = s;
              switch (kt.tag) {
                case 1:
                  if (Bt = kt.payload, typeof Bt == "function") {
                    tt = Bt.call(Jt, tt, I);
                    break t;
                  }
                  tt = Bt;
                  break t;
                case 3:
                  Bt.flags = Bt.flags & -65537 | 128;
                case 0:
                  if (Bt = kt.payload, I = typeof Bt == "function" ? Bt.call(Jt, tt, I) : Bt, I == null) break t;
                  tt = p({}, tt, I);
                  break t;
                case 2:
                  la = true;
              }
            }
            I = T.callback, I !== null && (i.flags |= 64, P && (i.flags |= 8192), P = g.callbacks, P === null ? g.callbacks = [
              I
            ] : P.push(I));
          } else P = {
            lane: I,
            tag: T.tag,
            payload: T.payload,
            callback: T.callback,
            next: null
          }, Q === null ? (U = Q = P, B = tt) : Q = Q.next = P, C |= I;
          if (T = T.next, T === null) {
            if (T = g.shared.pending, T === null) break;
            P = T, T = P.next, P.next = null, g.lastBaseUpdate = P, g.shared.pending = null;
          }
        } while (true);
        Q === null && (B = tt), g.baseState = B, g.firstBaseUpdate = U, g.lastBaseUpdate = Q, y === null && (g.shared.lanes = 0), ma |= C, i.lanes = C, i.memoizedState = tt;
      }
    }
    function um(i, r) {
      if (typeof i != "function") throw Error(n(191, i));
      i.call(r);
    }
    function hm(i, r) {
      var s = i.callbacks;
      if (s !== null) for (i.callbacks = null, i = 0; i < s.length; i++) um(s[i], r);
    }
    var Gn = Y(null), ac = Y(0);
    function fm(i, r) {
      i = qr, Z(ac, i), Z(Gn, r), qr = i | r.baseLanes;
    }
    function xf() {
      Z(ac, qr), Z(Gn, Gn.current);
    }
    function vf() {
      qr = ac.current, K(Gn), K(ac);
    }
    var ca = 0, Dt = null, Qt = null, be = null, nc = false, Wn = false, tn = false, lc = 0, cs = 0, Xn = null, VT = 0;
    function de() {
      throw Error(n(321));
    }
    function _f2(i, r) {
      if (r === null) return false;
      for (var s = 0; s < r.length && s < i.length; s++) if (!xi(i[s], r[s])) return false;
      return true;
    }
    function Sf(i, r, s, c, g, y) {
      return ca = y, Dt = r, r.memoizedState = null, r.updateQueue = null, r.lanes = 0, E.H = i === null || i.memoizedState === null ? Vm : Zm, tn = false, y = s(c, g), tn = false, Wn && (y = pm(r, s, c, g)), dm(i), y;
    }
    function dm(i) {
      E.H = fc;
      var r = Qt !== null && Qt.next !== null;
      if (ca = 0, be = Qt = Dt = null, nc = false, cs = 0, Xn = null, r) throw Error(n(300));
      i === null || Me || (i = i.dependencies, i !== null && Jo(i) && (Me = true));
    }
    function pm(i, r, s, c) {
      Dt = i;
      var g = 0;
      do {
        if (Wn && (Xn = null), cs = 0, Wn = false, 25 <= g) throw Error(n(301));
        if (g += 1, be = Qt = null, i.updateQueue != null) {
          var y = i.updateQueue;
          y.lastEffect = null, y.events = null, y.stores = null, y.memoCache != null && (y.memoCache.index = 0);
        }
        E.H = ik, y = r(s, c);
      } while (Wn);
      return y;
    }
    function ZT() {
      var i = E.H, r = i.useState()[0];
      return r = typeof r.then == "function" ? us(r) : r, i = i.useState()[0], (Qt !== null ? Qt.memoizedState : null) !== i && (Dt.flags |= 1024), r;
    }
    function Cf() {
      var i = lc !== 0;
      return lc = 0, i;
    }
    function wf(i, r, s) {
      r.updateQueue = i.updateQueue, r.flags &= -2053, i.lanes &= ~s;
    }
    function Tf(i) {
      if (nc) {
        for (i = i.memoizedState; i !== null; ) {
          var r = i.queue;
          r !== null && (r.pending = null), i = i.next;
        }
        nc = false;
      }
      ca = 0, be = Qt = Dt = null, Wn = false, cs = lc = 0, Xn = null;
    }
    function ci() {
      var i = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return be === null ? Dt.memoizedState = be = i : be = be.next = i, be;
    }
    function xe() {
      if (Qt === null) {
        var i = Dt.alternate;
        i = i !== null ? i.memoizedState : null;
      } else i = Qt.next;
      var r = be === null ? Dt.memoizedState : be.next;
      if (r !== null) be = r, Qt = i;
      else {
        if (i === null) throw Dt.alternate === null ? Error(n(467)) : Error(n(310));
        Qt = i, i = {
          memoizedState: Qt.memoizedState,
          baseState: Qt.baseState,
          baseQueue: Qt.baseQueue,
          queue: Qt.queue,
          next: null
        }, be === null ? Dt.memoizedState = be = i : be = be.next = i;
      }
      return be;
    }
    function kf() {
      return {
        lastEffect: null,
        events: null,
        stores: null,
        memoCache: null
      };
    }
    function us(i) {
      var r = cs;
      return cs += 1, Xn === null && (Xn = []), i = sm(Xn, i, r), r = Dt, (be === null ? r.memoizedState : be.next) === null && (r = r.alternate, E.H = r === null || r.memoizedState === null ? Vm : Zm), i;
    }
    function sc(i) {
      if (i !== null && typeof i == "object") {
        if (typeof i.then == "function") return us(i);
        if (i.$$typeof === L) return Pe(i);
      }
      throw Error(n(438, String(i)));
    }
    function Af(i) {
      var r = null, s = Dt.updateQueue;
      if (s !== null && (r = s.memoCache), r == null) {
        var c = Dt.alternate;
        c !== null && (c = c.updateQueue, c !== null && (c = c.memoCache, c != null && (r = {
          data: c.data.map(function(g) {
            return g.slice();
          }),
          index: 0
        })));
      }
      if (r == null && (r = {
        data: [],
        index: 0
      }), s === null && (s = kf(), Dt.updateQueue = s), s.memoCache = r, s = r.data[r.index], s === void 0) for (s = r.data[r.index] = Array(i), c = 0; c < i; c++) s[c] = lt;
      return r.index++, s;
    }
    function Dr(i, r) {
      return typeof r == "function" ? r(i) : r;
    }
    function oc(i) {
      var r = xe();
      return Ef(r, Qt, i);
    }
    function Ef(i, r, s) {
      var c = i.queue;
      if (c === null) throw Error(n(311));
      c.lastRenderedReducer = s;
      var g = i.baseQueue, y = c.pending;
      if (y !== null) {
        if (g !== null) {
          var C = g.next;
          g.next = y.next, y.next = C;
        }
        r.baseQueue = g = y, c.pending = null;
      }
      if (y = i.baseState, g === null) i.memoizedState = y;
      else {
        r = g.next;
        var T = C = null, B = null, U = r, Q = false;
        do {
          var tt = U.lane & -536870913;
          if (tt !== U.lane ? (Ut & tt) === tt : (ca & tt) === tt) {
            var I = U.revertLane;
            if (I === 0) B !== null && (B = B.next = {
              lane: 0,
              revertLane: 0,
              action: U.action,
              hasEagerState: U.hasEagerState,
              eagerState: U.eagerState,
              next: null
            }), tt === In && (Q = true);
            else if ((ca & I) === I) {
              U = U.next, I === In && (Q = true);
              continue;
            } else tt = {
              lane: 0,
              revertLane: U.revertLane,
              action: U.action,
              hasEagerState: U.hasEagerState,
              eagerState: U.eagerState,
              next: null
            }, B === null ? (T = B = tt, C = y) : B = B.next = tt, Dt.lanes |= I, ma |= I;
            tt = U.action, tn && s(y, tt), y = U.hasEagerState ? U.eagerState : s(y, tt);
          } else I = {
            lane: tt,
            revertLane: U.revertLane,
            action: U.action,
            hasEagerState: U.hasEagerState,
            eagerState: U.eagerState,
            next: null
          }, B === null ? (T = B = I, C = y) : B = B.next = I, Dt.lanes |= tt, ma |= tt;
          U = U.next;
        } while (U !== null && U !== r);
        if (B === null ? C = y : B.next = T, !xi(y, i.memoizedState) && (Me = true, Q && (s = Pn, s !== null))) throw s;
        i.memoizedState = y, i.baseState = C, i.baseQueue = B, c.lastRenderedState = y;
      }
      return g === null && (c.lanes = 0), [
        i.memoizedState,
        c.dispatch
      ];
    }
    function Mf(i) {
      var r = xe(), s = r.queue;
      if (s === null) throw Error(n(311));
      s.lastRenderedReducer = i;
      var c = s.dispatch, g = s.pending, y = r.memoizedState;
      if (g !== null) {
        s.pending = null;
        var C = g = g.next;
        do
          y = i(y, C.action), C = C.next;
        while (C !== g);
        xi(y, r.memoizedState) || (Me = true), r.memoizedState = y, r.baseQueue === null && (r.baseState = y), s.lastRenderedState = y;
      }
      return [
        y,
        c
      ];
    }
    function gm(i, r, s) {
      var c = Dt, g = xe(), y = It;
      if (y) {
        if (s === void 0) throw Error(n(407));
        s = s();
      } else s = r();
      var C = !xi((Qt || g).memoizedState, s);
      C && (g.memoizedState = s, Me = true), g = g.queue;
      var T = bm.bind(null, c, g, i);
      if (hs(2048, 8, T, [
        i
      ]), g.getSnapshot !== r || C || be !== null && be.memoizedState.tag & 1) {
        if (c.flags |= 2048, Vn(9, cc(), ym.bind(null, c, g, s, r), null), ie === null) throw Error(n(349));
        y || (ca & 124) !== 0 || mm(c, r, s);
      }
      return s;
    }
    function mm(i, r, s) {
      i.flags |= 16384, i = {
        getSnapshot: r,
        value: s
      }, r = Dt.updateQueue, r === null ? (r = kf(), Dt.updateQueue = r, r.stores = [
        i
      ]) : (s = r.stores, s === null ? r.stores = [
        i
      ] : s.push(i));
    }
    function ym(i, r, s, c) {
      r.value = s, r.getSnapshot = c, xm(r) && vm(i);
    }
    function bm(i, r, s) {
      return s(function() {
        xm(r) && vm(i);
      });
    }
    function xm(i) {
      var r = i.getSnapshot;
      i = i.value;
      try {
        var s = r();
        return !xi(i, s);
      } catch {
        return true;
      }
    }
    function vm(i) {
      var r = Hn(i, 2);
      r !== null && Ti(r, i, 2);
    }
    function Bf(i) {
      var r = ci();
      if (typeof i == "function") {
        var s = i;
        if (i = s(), tn) {
          Pi(true);
          try {
            s();
          } finally {
            Pi(false);
          }
        }
      }
      return r.memoizedState = r.baseState = i, r.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Dr,
        lastRenderedState: i
      }, r;
    }
    function _m(i, r, s, c) {
      return i.baseState = s, Ef(i, Qt, typeof c == "function" ? c : Dr);
    }
    function QT(i, r, s, c, g) {
      if (hc(i)) throw Error(n(485));
      if (i = r.action, i !== null) {
        var y = {
          payload: g,
          action: i,
          next: null,
          isTransition: true,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function(C) {
            y.listeners.push(C);
          }
        };
        E.T !== null ? s(true) : y.isTransition = false, c(y), s = r.pending, s === null ? (y.next = r.pending = y, Sm(r, y)) : (y.next = s.next, r.pending = s.next = y);
      }
    }
    function Sm(i, r) {
      var s = r.action, c = r.payload, g = i.state;
      if (r.isTransition) {
        var y = E.T, C = {};
        E.T = C;
        try {
          var T = s(g, c), B = E.S;
          B !== null && B(C, T), Cm(i, r, T);
        } catch (U) {
          Lf(i, r, U);
        } finally {
          E.T = y;
        }
      } else try {
        y = s(g, c), Cm(i, r, y);
      } catch (U) {
        Lf(i, r, U);
      }
    }
    function Cm(i, r, s) {
      s !== null && typeof s == "object" && typeof s.then == "function" ? s.then(function(c) {
        wm(i, r, c);
      }, function(c) {
        return Lf(i, r, c);
      }) : wm(i, r, s);
    }
    function wm(i, r, s) {
      r.status = "fulfilled", r.value = s, Tm(r), i.state = s, r = i.pending, r !== null && (s = r.next, s === r ? i.pending = null : (s = s.next, r.next = s, Sm(i, s)));
    }
    function Lf(i, r, s) {
      var c = i.pending;
      if (i.pending = null, c !== null) {
        c = c.next;
        do
          r.status = "rejected", r.reason = s, Tm(r), r = r.next;
        while (r !== c);
      }
      i.action = null;
    }
    function Tm(i) {
      i = i.listeners;
      for (var r = 0; r < i.length; r++) (0, i[r])();
    }
    function km(i, r) {
      return r;
    }
    function Am(i, r) {
      if (It) {
        var s = ie.formState;
        if (s !== null) {
          t: {
            var c = Dt;
            if (It) {
              if (ce) {
                e: {
                  for (var g = ce, y = sr; g.nodeType !== 8; ) {
                    if (!y) {
                      g = null;
                      break e;
                    }
                    if (g = Zi(g.nextSibling), g === null) {
                      g = null;
                      break e;
                    }
                  }
                  y = g.data, g = y === "F!" || y === "F" ? g : null;
                }
                if (g) {
                  ce = Zi(g.nextSibling), c = g.data === "F!";
                  break t;
                }
              }
              Za(c);
            }
            c = false;
          }
          c && (r = s[0]);
        }
      }
      return s = ci(), s.memoizedState = s.baseState = r, c = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: km,
        lastRenderedState: r
      }, s.queue = c, s = Gm.bind(null, Dt, c), c.dispatch = s, c = Bf(false), y = Nf.bind(null, Dt, false, c.queue), c = ci(), g = {
        state: r,
        dispatch: null,
        action: i,
        pending: null
      }, c.queue = g, s = QT.bind(null, Dt, g, y, s), g.dispatch = s, c.memoizedState = i, [
        r,
        s,
        false
      ];
    }
    function Em(i) {
      var r = xe();
      return Mm(r, Qt, i);
    }
    function Mm(i, r, s) {
      if (r = Ef(i, r, km)[0], i = oc(Dr)[0], typeof r == "object" && r !== null && typeof r.then == "function") try {
        var c = us(r);
      } catch (C) {
        throw C === as ? ic : C;
      }
      else c = r;
      r = xe();
      var g = r.queue, y = g.dispatch;
      return s !== r.memoizedState && (Dt.flags |= 2048, Vn(9, cc(), KT.bind(null, g, s), null)), [
        c,
        y,
        i
      ];
    }
    function KT(i, r) {
      i.action = r;
    }
    function Bm(i) {
      var r = xe(), s = Qt;
      if (s !== null) return Mm(r, s, i);
      xe(), r = r.memoizedState, s = xe();
      var c = s.queue.dispatch;
      return s.memoizedState = i, [
        r,
        c,
        false
      ];
    }
    function Vn(i, r, s, c) {
      return i = {
        tag: i,
        create: s,
        deps: c,
        inst: r,
        next: null
      }, r = Dt.updateQueue, r === null && (r = kf(), Dt.updateQueue = r), s = r.lastEffect, s === null ? r.lastEffect = i.next = i : (c = s.next, s.next = i, i.next = c, r.lastEffect = i), i;
    }
    function cc() {
      return {
        destroy: void 0,
        resource: void 0
      };
    }
    function Lm() {
      return xe().memoizedState;
    }
    function uc(i, r, s, c) {
      var g = ci();
      c = c === void 0 ? null : c, Dt.flags |= i, g.memoizedState = Vn(1 | r, cc(), s, c);
    }
    function hs(i, r, s, c) {
      var g = xe();
      c = c === void 0 ? null : c;
      var y = g.memoizedState.inst;
      Qt !== null && c !== null && _f2(c, Qt.memoizedState.deps) ? g.memoizedState = Vn(r, y, s, c) : (Dt.flags |= i, g.memoizedState = Vn(1 | r, y, s, c));
    }
    function Om(i, r) {
      uc(8390656, 8, i, r);
    }
    function Dm(i, r) {
      hs(2048, 8, i, r);
    }
    function Rm(i, r) {
      return hs(4, 2, i, r);
    }
    function $m(i, r) {
      return hs(4, 4, i, r);
    }
    function Nm(i, r) {
      if (typeof r == "function") {
        i = i();
        var s = r(i);
        return function() {
          typeof s == "function" ? s() : r(null);
        };
      }
      if (r != null) return i = i(), r.current = i, function() {
        r.current = null;
      };
    }
    function zm(i, r, s) {
      s = s != null ? s.concat([
        i
      ]) : null, hs(4, 4, Nm.bind(null, r, i), s);
    }
    function Of() {
    }
    function Fm(i, r) {
      var s = xe();
      r = r === void 0 ? null : r;
      var c = s.memoizedState;
      return r !== null && _f2(r, c[1]) ? c[0] : (s.memoizedState = [
        i,
        r
      ], i);
    }
    function qm(i, r) {
      var s = xe();
      r = r === void 0 ? null : r;
      var c = s.memoizedState;
      if (r !== null && _f2(r, c[1])) return c[0];
      if (c = i(), tn) {
        Pi(true);
        try {
          i();
        } finally {
          Pi(false);
        }
      }
      return s.memoizedState = [
        c,
        r
      ], c;
    }
    function Df(i, r, s) {
      return s === void 0 || (ca & 1073741824) !== 0 ? i.memoizedState = r : (i.memoizedState = s, i = jy(), Dt.lanes |= i, ma |= i, s);
    }
    function Hm(i, r, s, c) {
      return xi(s, r) ? s : Gn.current !== null ? (i = Df(i, s, c), xi(i, r) || (Me = true), i) : (ca & 42) === 0 ? (Me = true, i.memoizedState = s) : (i = jy(), Dt.lanes |= i, ma |= i, r);
    }
    function Um(i, r, s, c, g) {
      var y = N.p;
      N.p = y !== 0 && 8 > y ? y : 8;
      var C = E.T, T = {};
      E.T = T, Nf(i, false, r, s);
      try {
        var B = g(), U = E.S;
        if (U !== null && U(T, B), B !== null && typeof B == "object" && typeof B.then == "function") {
          var Q = XT(B, c);
          fs(i, r, Q, wi(i));
        } else fs(i, r, c, wi(i));
      } catch (tt) {
        fs(i, r, {
          then: function() {
          },
          status: "rejected",
          reason: tt
        }, wi());
      } finally {
        N.p = y, E.T = C;
      }
    }
    function JT() {
    }
    function Rf(i, r, s, c) {
      if (i.tag !== 5) throw Error(n(476));
      var g = jm(i).queue;
      Um(i, g, r, F, s === null ? JT : function() {
        return Ym(i), s(c);
      });
    }
    function jm(i) {
      var r = i.memoizedState;
      if (r !== null) return r;
      r = {
        memoizedState: F,
        baseState: F,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: Dr,
          lastRenderedState: F
        },
        next: null
      };
      var s = {};
      return r.next = {
        memoizedState: s,
        baseState: s,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: Dr,
          lastRenderedState: s
        },
        next: null
      }, i.memoizedState = r, i = i.alternate, i !== null && (i.memoizedState = r), r;
    }
    function Ym(i) {
      var r = jm(i).next.queue;
      fs(i, r, {}, wi());
    }
    function $f() {
      return Pe(Bs);
    }
    function Im() {
      return xe().memoizedState;
    }
    function Pm() {
      return xe().memoizedState;
    }
    function tk(i) {
      for (var r = i.return; r !== null; ) {
        switch (r.tag) {
          case 24:
          case 3:
            var s = wi();
            i = sa(s);
            var c = oa(r, i, s);
            c !== null && (Ti(c, r, s), ls(c, r, s)), r = {
              cache: hf()
            }, i.payload = r;
            return;
        }
        r = r.return;
      }
    }
    function ek(i, r, s) {
      var c = wi();
      s = {
        lane: c,
        revertLane: 0,
        action: s,
        hasEagerState: false,
        eagerState: null,
        next: null
      }, hc(i) ? Wm(r, s) : (s = tf(i, r, s, c), s !== null && (Ti(s, i, c), Xm(s, r, c)));
    }
    function Gm(i, r, s) {
      var c = wi();
      fs(i, r, s, c);
    }
    function fs(i, r, s, c) {
      var g = {
        lane: c,
        revertLane: 0,
        action: s,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      if (hc(i)) Wm(r, g);
      else {
        var y = i.alternate;
        if (i.lanes === 0 && (y === null || y.lanes === 0) && (y = r.lastRenderedReducer, y !== null)) try {
          var C = r.lastRenderedState, T = y(C, s);
          if (g.hasEagerState = true, g.eagerState = T, xi(T, C)) return Xo(i, r, g, 0), ie === null && Wo(), false;
        } catch {
        } finally {
        }
        if (s = tf(i, r, g, c), s !== null) return Ti(s, i, c), Xm(s, r, c), true;
      }
      return false;
    }
    function Nf(i, r, s, c) {
      if (c = {
        lane: 2,
        revertLane: pd(),
        action: c,
        hasEagerState: false,
        eagerState: null,
        next: null
      }, hc(i)) {
        if (r) throw Error(n(479));
      } else r = tf(i, s, c, 2), r !== null && Ti(r, i, 2);
    }
    function hc(i) {
      var r = i.alternate;
      return i === Dt || r !== null && r === Dt;
    }
    function Wm(i, r) {
      Wn = nc = true;
      var s = i.pending;
      s === null ? r.next = r : (r.next = s.next, s.next = r), i.pending = r;
    }
    function Xm(i, r, s) {
      if ((s & 4194048) !== 0) {
        var c = r.lanes;
        c &= i.pendingLanes, s |= c, r.lanes = s, fe(i, s);
      }
    }
    var fc = {
      readContext: Pe,
      use: sc,
      useCallback: de,
      useContext: de,
      useEffect: de,
      useImperativeHandle: de,
      useLayoutEffect: de,
      useInsertionEffect: de,
      useMemo: de,
      useReducer: de,
      useRef: de,
      useState: de,
      useDebugValue: de,
      useDeferredValue: de,
      useTransition: de,
      useSyncExternalStore: de,
      useId: de,
      useHostTransitionStatus: de,
      useFormState: de,
      useActionState: de,
      useOptimistic: de,
      useMemoCache: de,
      useCacheRefresh: de
    }, Vm = {
      readContext: Pe,
      use: sc,
      useCallback: function(i, r) {
        return ci().memoizedState = [
          i,
          r === void 0 ? null : r
        ], i;
      },
      useContext: Pe,
      useEffect: Om,
      useImperativeHandle: function(i, r, s) {
        s = s != null ? s.concat([
          i
        ]) : null, uc(4194308, 4, Nm.bind(null, r, i), s);
      },
      useLayoutEffect: function(i, r) {
        return uc(4194308, 4, i, r);
      },
      useInsertionEffect: function(i, r) {
        uc(4, 2, i, r);
      },
      useMemo: function(i, r) {
        var s = ci();
        r = r === void 0 ? null : r;
        var c = i();
        if (tn) {
          Pi(true);
          try {
            i();
          } finally {
            Pi(false);
          }
        }
        return s.memoizedState = [
          c,
          r
        ], c;
      },
      useReducer: function(i, r, s) {
        var c = ci();
        if (s !== void 0) {
          var g = s(r);
          if (tn) {
            Pi(true);
            try {
              s(r);
            } finally {
              Pi(false);
            }
          }
        } else g = r;
        return c.memoizedState = c.baseState = g, i = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: i,
          lastRenderedState: g
        }, c.queue = i, i = i.dispatch = ek.bind(null, Dt, i), [
          c.memoizedState,
          i
        ];
      },
      useRef: function(i) {
        var r = ci();
        return i = {
          current: i
        }, r.memoizedState = i;
      },
      useState: function(i) {
        i = Bf(i);
        var r = i.queue, s = Gm.bind(null, Dt, r);
        return r.dispatch = s, [
          i.memoizedState,
          s
        ];
      },
      useDebugValue: Of,
      useDeferredValue: function(i, r) {
        var s = ci();
        return Df(s, i, r);
      },
      useTransition: function() {
        var i = Bf(false);
        return i = Um.bind(null, Dt, i.queue, true, false), ci().memoizedState = i, [
          false,
          i
        ];
      },
      useSyncExternalStore: function(i, r, s) {
        var c = Dt, g = ci();
        if (It) {
          if (s === void 0) throw Error(n(407));
          s = s();
        } else {
          if (s = r(), ie === null) throw Error(n(349));
          (Ut & 124) !== 0 || mm(c, r, s);
        }
        g.memoizedState = s;
        var y = {
          value: s,
          getSnapshot: r
        };
        return g.queue = y, Om(bm.bind(null, c, y, i), [
          i
        ]), c.flags |= 2048, Vn(9, cc(), ym.bind(null, c, y, s, r), null), s;
      },
      useId: function() {
        var i = ci(), r = ie.identifierPrefix;
        if (It) {
          var s = Br, c = Mr;
          s = (c & ~(1 << 32 - je(c) - 1)).toString(32) + s, r = "\xAB" + r + "R" + s, s = lc++, 0 < s && (r += "H" + s.toString(32)), r += "\xBB";
        } else s = VT++, r = "\xAB" + r + "r" + s.toString(32) + "\xBB";
        return i.memoizedState = r;
      },
      useHostTransitionStatus: $f,
      useFormState: Am,
      useActionState: Am,
      useOptimistic: function(i) {
        var r = ci();
        r.memoizedState = r.baseState = i;
        var s = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null
        };
        return r.queue = s, r = Nf.bind(null, Dt, true, s), s.dispatch = r, [
          i,
          r
        ];
      },
      useMemoCache: Af,
      useCacheRefresh: function() {
        return ci().memoizedState = tk.bind(null, Dt);
      }
    }, Zm = {
      readContext: Pe,
      use: sc,
      useCallback: Fm,
      useContext: Pe,
      useEffect: Dm,
      useImperativeHandle: zm,
      useInsertionEffect: Rm,
      useLayoutEffect: $m,
      useMemo: qm,
      useReducer: oc,
      useRef: Lm,
      useState: function() {
        return oc(Dr);
      },
      useDebugValue: Of,
      useDeferredValue: function(i, r) {
        var s = xe();
        return Hm(s, Qt.memoizedState, i, r);
      },
      useTransition: function() {
        var i = oc(Dr)[0], r = xe().memoizedState;
        return [
          typeof i == "boolean" ? i : us(i),
          r
        ];
      },
      useSyncExternalStore: gm,
      useId: Im,
      useHostTransitionStatus: $f,
      useFormState: Em,
      useActionState: Em,
      useOptimistic: function(i, r) {
        var s = xe();
        return _m(s, Qt, i, r);
      },
      useMemoCache: Af,
      useCacheRefresh: Pm
    }, ik = {
      readContext: Pe,
      use: sc,
      useCallback: Fm,
      useContext: Pe,
      useEffect: Dm,
      useImperativeHandle: zm,
      useInsertionEffect: Rm,
      useLayoutEffect: $m,
      useMemo: qm,
      useReducer: Mf,
      useRef: Lm,
      useState: function() {
        return Mf(Dr);
      },
      useDebugValue: Of,
      useDeferredValue: function(i, r) {
        var s = xe();
        return Qt === null ? Df(s, i, r) : Hm(s, Qt.memoizedState, i, r);
      },
      useTransition: function() {
        var i = Mf(Dr)[0], r = xe().memoizedState;
        return [
          typeof i == "boolean" ? i : us(i),
          r
        ];
      },
      useSyncExternalStore: gm,
      useId: Im,
      useHostTransitionStatus: $f,
      useFormState: Bm,
      useActionState: Bm,
      useOptimistic: function(i, r) {
        var s = xe();
        return Qt !== null ? _m(s, Qt, i, r) : (s.baseState = i, [
          i,
          s.queue.dispatch
        ]);
      },
      useMemoCache: Af,
      useCacheRefresh: Pm
    }, Zn = null, ds = 0;
    function dc(i) {
      var r = ds;
      return ds += 1, Zn === null && (Zn = []), sm(Zn, i, r);
    }
    function ps(i, r) {
      r = r.props.ref, i.ref = r !== void 0 ? r : null;
    }
    function pc(i, r) {
      throw r.$$typeof === m ? Error(n(525)) : (i = Object.prototype.toString.call(r), Error(n(31, i === "[object Object]" ? "object with keys {" + Object.keys(r).join(", ") + "}" : i)));
    }
    function Qm(i) {
      var r = i._init;
      return r(i._payload);
    }
    function Km(i) {
      function r(z, D) {
        if (i) {
          var H = z.deletions;
          H === null ? (z.deletions = [
            D
          ], z.flags |= 16) : H.push(D);
        }
      }
      function s(z, D) {
        if (!i) return null;
        for (; D !== null; ) r(z, D), D = D.sibling;
        return null;
      }
      function c(z) {
        for (var D = /* @__PURE__ */ new Map(); z !== null; ) z.key !== null ? D.set(z.key, z) : D.set(z.index, z), z = z.sibling;
        return D;
      }
      function g(z, D) {
        return z = Er(z, D), z.index = 0, z.sibling = null, z;
      }
      function y(z, D, H) {
        return z.index = H, i ? (H = z.alternate, H !== null ? (H = H.index, H < D ? (z.flags |= 67108866, D) : H) : (z.flags |= 67108866, D)) : (z.flags |= 1048576, D);
      }
      function C(z) {
        return i && z.alternate === null && (z.flags |= 67108866), z;
      }
      function T(z, D, H, J) {
        return D === null || D.tag !== 6 ? (D = rf(H, z.mode, J), D.return = z, D) : (D = g(D, H), D.return = z, D);
      }
      function B(z, D, H, J) {
        var gt = H.type;
        return gt === _ ? Q(z, D, H.props.children, J, H.key) : D !== null && (D.elementType === gt || typeof gt == "object" && gt !== null && gt.$$typeof === et && Qm(gt) === D.type) ? (D = g(D, H.props), ps(D, H), D.return = z, D) : (D = Zo(H.type, H.key, H.props, null, z.mode, J), ps(D, H), D.return = z, D);
      }
      function U(z, D, H, J) {
        return D === null || D.tag !== 4 || D.stateNode.containerInfo !== H.containerInfo || D.stateNode.implementation !== H.implementation ? (D = af(H, z.mode, J), D.return = z, D) : (D = g(D, H.children || []), D.return = z, D);
      }
      function Q(z, D, H, J, gt) {
        return D === null || D.tag !== 7 ? (D = Ga(H, z.mode, J, gt), D.return = z, D) : (D = g(D, H), D.return = z, D);
      }
      function tt(z, D, H) {
        if (typeof D == "string" && D !== "" || typeof D == "number" || typeof D == "bigint") return D = rf("" + D, z.mode, H), D.return = z, D;
        if (typeof D == "object" && D !== null) {
          switch (D.$$typeof) {
            case b:
              return H = Zo(D.type, D.key, D.props, null, z.mode, H), ps(H, D), H.return = z, H;
            case x:
              return D = af(D, z.mode, H), D.return = z, D;
            case et:
              var J = D._init;
              return D = J(D._payload), tt(z, D, H);
          }
          if (G(D) || at(D)) return D = Ga(D, z.mode, H, null), D.return = z, D;
          if (typeof D.then == "function") return tt(z, dc(D), H);
          if (D.$$typeof === L) return tt(z, tc(z, D), H);
          pc(z, D);
        }
        return null;
      }
      function I(z, D, H, J) {
        var gt = D !== null ? D.key : null;
        if (typeof H == "string" && H !== "" || typeof H == "number" || typeof H == "bigint") return gt !== null ? null : T(z, D, "" + H, J);
        if (typeof H == "object" && H !== null) {
          switch (H.$$typeof) {
            case b:
              return H.key === gt ? B(z, D, H, J) : null;
            case x:
              return H.key === gt ? U(z, D, H, J) : null;
            case et:
              return gt = H._init, H = gt(H._payload), I(z, D, H, J);
          }
          if (G(H) || at(H)) return gt !== null ? null : Q(z, D, H, J, null);
          if (typeof H.then == "function") return I(z, D, dc(H), J);
          if (H.$$typeof === L) return I(z, D, tc(z, H), J);
          pc(z, H);
        }
        return null;
      }
      function P(z, D, H, J, gt) {
        if (typeof J == "string" && J !== "" || typeof J == "number" || typeof J == "bigint") return z = z.get(H) || null, T(D, z, "" + J, gt);
        if (typeof J == "object" && J !== null) {
          switch (J.$$typeof) {
            case b:
              return z = z.get(J.key === null ? H : J.key) || null, B(D, z, J, gt);
            case x:
              return z = z.get(J.key === null ? H : J.key) || null, U(D, z, J, gt);
            case et:
              var Rt = J._init;
              return J = Rt(J._payload), P(z, D, H, J, gt);
          }
          if (G(J) || at(J)) return z = z.get(H) || null, Q(D, z, J, gt, null);
          if (typeof J.then == "function") return P(z, D, H, dc(J), gt);
          if (J.$$typeof === L) return P(z, D, H, tc(D, J), gt);
          pc(D, J);
        }
        return null;
      }
      function Bt(z, D, H, J) {
        for (var gt = null, Rt = null, St = D, Et = D = 0, Le = null; St !== null && Et < H.length; Et++) {
          St.index > Et ? (Le = St, St = null) : Le = St.sibling;
          var Yt = I(z, St, H[Et], J);
          if (Yt === null) {
            St === null && (St = Le);
            break;
          }
          i && St && Yt.alternate === null && r(z, St), D = y(Yt, D, Et), Rt === null ? gt = Yt : Rt.sibling = Yt, Rt = Yt, St = Le;
        }
        if (Et === H.length) return s(z, St), It && Xa(z, Et), gt;
        if (St === null) {
          for (; Et < H.length; Et++) St = tt(z, H[Et], J), St !== null && (D = y(St, D, Et), Rt === null ? gt = St : Rt.sibling = St, Rt = St);
          return It && Xa(z, Et), gt;
        }
        for (St = c(St); Et < H.length; Et++) Le = P(St, z, Et, H[Et], J), Le !== null && (i && Le.alternate !== null && St.delete(Le.key === null ? Et : Le.key), D = y(Le, D, Et), Rt === null ? gt = Le : Rt.sibling = Le, Rt = Le);
        return i && St.forEach(function(Ta) {
          return r(z, Ta);
        }), It && Xa(z, Et), gt;
      }
      function kt(z, D, H, J) {
        if (H == null) throw Error(n(151));
        for (var gt = null, Rt = null, St = D, Et = D = 0, Le = null, Yt = H.next(); St !== null && !Yt.done; Et++, Yt = H.next()) {
          St.index > Et ? (Le = St, St = null) : Le = St.sibling;
          var Ta = I(z, St, Yt.value, J);
          if (Ta === null) {
            St === null && (St = Le);
            break;
          }
          i && St && Ta.alternate === null && r(z, St), D = y(Ta, D, Et), Rt === null ? gt = Ta : Rt.sibling = Ta, Rt = Ta, St = Le;
        }
        if (Yt.done) return s(z, St), It && Xa(z, Et), gt;
        if (St === null) {
          for (; !Yt.done; Et++, Yt = H.next()) Yt = tt(z, Yt.value, J), Yt !== null && (D = y(Yt, D, Et), Rt === null ? gt = Yt : Rt.sibling = Yt, Rt = Yt);
          return It && Xa(z, Et), gt;
        }
        for (St = c(St); !Yt.done; Et++, Yt = H.next()) Yt = P(St, z, Et, Yt.value, J), Yt !== null && (i && Yt.alternate !== null && St.delete(Yt.key === null ? Et : Yt.key), D = y(Yt, D, Et), Rt === null ? gt = Yt : Rt.sibling = Yt, Rt = Yt);
        return i && St.forEach(function(rA) {
          return r(z, rA);
        }), It && Xa(z, Et), gt;
      }
      function Jt(z, D, H, J) {
        if (typeof H == "object" && H !== null && H.type === _ && H.key === null && (H = H.props.children), typeof H == "object" && H !== null) {
          switch (H.$$typeof) {
            case b:
              t: {
                for (var gt = H.key; D !== null; ) {
                  if (D.key === gt) {
                    if (gt = H.type, gt === _) {
                      if (D.tag === 7) {
                        s(z, D.sibling), J = g(D, H.props.children), J.return = z, z = J;
                        break t;
                      }
                    } else if (D.elementType === gt || typeof gt == "object" && gt !== null && gt.$$typeof === et && Qm(gt) === D.type) {
                      s(z, D.sibling), J = g(D, H.props), ps(J, H), J.return = z, z = J;
                      break t;
                    }
                    s(z, D);
                    break;
                  } else r(z, D);
                  D = D.sibling;
                }
                H.type === _ ? (J = Ga(H.props.children, z.mode, J, H.key), J.return = z, z = J) : (J = Zo(H.type, H.key, H.props, null, z.mode, J), ps(J, H), J.return = z, z = J);
              }
              return C(z);
            case x:
              t: {
                for (gt = H.key; D !== null; ) {
                  if (D.key === gt) if (D.tag === 4 && D.stateNode.containerInfo === H.containerInfo && D.stateNode.implementation === H.implementation) {
                    s(z, D.sibling), J = g(D, H.children || []), J.return = z, z = J;
                    break t;
                  } else {
                    s(z, D);
                    break;
                  }
                  else r(z, D);
                  D = D.sibling;
                }
                J = af(H, z.mode, J), J.return = z, z = J;
              }
              return C(z);
            case et:
              return gt = H._init, H = gt(H._payload), Jt(z, D, H, J);
          }
          if (G(H)) return Bt(z, D, H, J);
          if (at(H)) {
            if (gt = at(H), typeof gt != "function") throw Error(n(150));
            return H = gt.call(H), kt(z, D, H, J);
          }
          if (typeof H.then == "function") return Jt(z, D, dc(H), J);
          if (H.$$typeof === L) return Jt(z, D, tc(z, H), J);
          pc(z, H);
        }
        return typeof H == "string" && H !== "" || typeof H == "number" || typeof H == "bigint" ? (H = "" + H, D !== null && D.tag === 6 ? (s(z, D.sibling), J = g(D, H), J.return = z, z = J) : (s(z, D), J = rf(H, z.mode, J), J.return = z, z = J), C(z)) : s(z, D);
      }
      return function(z, D, H, J) {
        try {
          ds = 0;
          var gt = Jt(z, D, H, J);
          return Zn = null, gt;
        } catch (St) {
          if (St === as || St === ic) throw St;
          var Rt = vi(29, St, null, z.mode);
          return Rt.lanes = J, Rt.return = z, Rt;
        } finally {
        }
      };
    }
    var Qn = Km(true), Jm = Km(false), Ni = Y(null), or = null;
    function ua(i) {
      var r = i.alternate;
      Z(we, we.current & 1), Z(Ni, i), or === null && (r === null || Gn.current !== null || r.memoizedState !== null) && (or = i);
    }
    function ty(i) {
      if (i.tag === 22) {
        if (Z(we, we.current), Z(Ni, i), or === null) {
          var r = i.alternate;
          r !== null && r.memoizedState !== null && (or = i);
        }
      } else ha();
    }
    function ha() {
      Z(we, we.current), Z(Ni, Ni.current);
    }
    function Rr(i) {
      K(Ni), or === i && (or = null), K(we);
    }
    var we = Y(0);
    function gc(i) {
      for (var r = i; r !== null; ) {
        if (r.tag === 13) {
          var s = r.memoizedState;
          if (s !== null && (s = s.dehydrated, s === null || s.data === "$?" || kd(s))) return r;
        } else if (r.tag === 19 && r.memoizedProps.revealOrder !== void 0) {
          if ((r.flags & 128) !== 0) return r;
        } else if (r.child !== null) {
          r.child.return = r, r = r.child;
          continue;
        }
        if (r === i) break;
        for (; r.sibling === null; ) {
          if (r.return === null || r.return === i) return null;
          r = r.return;
        }
        r.sibling.return = r.return, r = r.sibling;
      }
      return null;
    }
    function zf(i, r, s, c) {
      r = i.memoizedState, s = s(c, r), s = s == null ? r : p({}, r, s), i.memoizedState = s, i.lanes === 0 && (i.updateQueue.baseState = s);
    }
    var Ff = {
      enqueueSetState: function(i, r, s) {
        i = i._reactInternals;
        var c = wi(), g = sa(c);
        g.payload = r, s != null && (g.callback = s), r = oa(i, g, c), r !== null && (Ti(r, i, c), ls(r, i, c));
      },
      enqueueReplaceState: function(i, r, s) {
        i = i._reactInternals;
        var c = wi(), g = sa(c);
        g.tag = 1, g.payload = r, s != null && (g.callback = s), r = oa(i, g, c), r !== null && (Ti(r, i, c), ls(r, i, c));
      },
      enqueueForceUpdate: function(i, r) {
        i = i._reactInternals;
        var s = wi(), c = sa(s);
        c.tag = 2, r != null && (c.callback = r), r = oa(i, c, s), r !== null && (Ti(r, i, s), ls(r, i, s));
      }
    };
    function ey(i, r, s, c, g, y, C) {
      return i = i.stateNode, typeof i.shouldComponentUpdate == "function" ? i.shouldComponentUpdate(c, y, C) : r.prototype && r.prototype.isPureReactComponent ? !Zl(s, c) || !Zl(g, y) : true;
    }
    function iy(i, r, s, c) {
      i = r.state, typeof r.componentWillReceiveProps == "function" && r.componentWillReceiveProps(s, c), typeof r.UNSAFE_componentWillReceiveProps == "function" && r.UNSAFE_componentWillReceiveProps(s, c), r.state !== i && Ff.enqueueReplaceState(r, r.state, null);
    }
    function en(i, r) {
      var s = r;
      if ("ref" in r) {
        s = {};
        for (var c in r) c !== "ref" && (s[c] = r[c]);
      }
      if (i = i.defaultProps) {
        s === r && (s = p({}, s));
        for (var g in i) s[g] === void 0 && (s[g] = i[g]);
      }
      return s;
    }
    var mc = typeof reportError == "function" ? reportError : function(i) {
      if (typeof window == "object" && typeof window.ErrorEvent == "function") {
        var r = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: typeof i == "object" && i !== null && typeof i.message == "string" ? String(i.message) : String(i),
          error: i
        });
        if (!window.dispatchEvent(r)) return;
      } else if (typeof process == "object" && typeof process.emit == "function") {
        process.emit("uncaughtException", i);
        return;
      }
      console.error(i);
    };
    function ry(i) {
      mc(i);
    }
    function ay(i) {
      console.error(i);
    }
    function ny(i) {
      mc(i);
    }
    function yc(i, r) {
      try {
        var s = i.onUncaughtError;
        s(r.value, {
          componentStack: r.stack
        });
      } catch (c) {
        setTimeout(function() {
          throw c;
        });
      }
    }
    function ly(i, r, s) {
      try {
        var c = i.onCaughtError;
        c(s.value, {
          componentStack: s.stack,
          errorBoundary: r.tag === 1 ? r.stateNode : null
        });
      } catch (g) {
        setTimeout(function() {
          throw g;
        });
      }
    }
    function qf(i, r, s) {
      return s = sa(s), s.tag = 3, s.payload = {
        element: null
      }, s.callback = function() {
        yc(i, r);
      }, s;
    }
    function sy(i) {
      return i = sa(i), i.tag = 3, i;
    }
    function oy(i, r, s, c) {
      var g = s.type.getDerivedStateFromError;
      if (typeof g == "function") {
        var y = c.value;
        i.payload = function() {
          return g(y);
        }, i.callback = function() {
          ly(r, s, c);
        };
      }
      var C = s.stateNode;
      C !== null && typeof C.componentDidCatch == "function" && (i.callback = function() {
        ly(r, s, c), typeof g != "function" && (ya === null ? ya = /* @__PURE__ */ new Set([
          this
        ]) : ya.add(this));
        var T = c.stack;
        this.componentDidCatch(c.value, {
          componentStack: T !== null ? T : ""
        });
      });
    }
    function rk(i, r, s, c, g) {
      if (s.flags |= 32768, c !== null && typeof c == "object" && typeof c.then == "function") {
        if (r = s.alternate, r !== null && es(r, s, g, true), s = Ni.current, s !== null) {
          switch (s.tag) {
            case 13:
              return or === null ? cd() : s.alternate === null && ue === 0 && (ue = 3), s.flags &= -257, s.flags |= 65536, s.lanes = g, c === pf ? s.flags |= 16384 : (r = s.updateQueue, r === null ? s.updateQueue = /* @__PURE__ */ new Set([
                c
              ]) : r.add(c), hd(i, c, g)), false;
            case 22:
              return s.flags |= 65536, c === pf ? s.flags |= 16384 : (r = s.updateQueue, r === null ? (r = {
                transitions: null,
                markerInstances: null,
                retryQueue: /* @__PURE__ */ new Set([
                  c
                ])
              }, s.updateQueue = r) : (s = r.retryQueue, s === null ? r.retryQueue = /* @__PURE__ */ new Set([
                c
              ]) : s.add(c)), hd(i, c, g)), false;
          }
          throw Error(n(435, s.tag));
        }
        return hd(i, c, g), cd(), false;
      }
      if (It) return r = Ni.current, r !== null ? ((r.flags & 65536) === 0 && (r.flags |= 256), r.flags |= 65536, r.lanes = g, c !== sf && (i = Error(n(422), {
        cause: c
      }), ts(Oi(i, s)))) : (c !== sf && (r = Error(n(423), {
        cause: c
      }), ts(Oi(r, s))), i = i.current.alternate, i.flags |= 65536, g &= -g, i.lanes |= g, c = Oi(c, s), g = qf(i.stateNode, c, g), yf(i, g), ue !== 4 && (ue = 2)), false;
      var y = Error(n(520), {
        cause: c
      });
      if (y = Oi(y, s), _s === null ? _s = [
        y
      ] : _s.push(y), ue !== 4 && (ue = 2), r === null) return true;
      c = Oi(c, s), s = r;
      do {
        switch (s.tag) {
          case 3:
            return s.flags |= 65536, i = g & -g, s.lanes |= i, i = qf(s.stateNode, c, i), yf(s, i), false;
          case 1:
            if (r = s.type, y = s.stateNode, (s.flags & 128) === 0 && (typeof r.getDerivedStateFromError == "function" || y !== null && typeof y.componentDidCatch == "function" && (ya === null || !ya.has(y)))) return s.flags |= 65536, g &= -g, s.lanes |= g, g = sy(g), oy(g, i, s, c), yf(s, g), false;
        }
        s = s.return;
      } while (s !== null);
      return false;
    }
    var cy = Error(n(461)), Me = false;
    function Re(i, r, s, c) {
      r.child = i === null ? Jm(r, null, s, c) : Qn(r, i.child, s, c);
    }
    function uy(i, r, s, c, g) {
      s = s.render;
      var y = r.ref;
      if ("ref" in c) {
        var C = {};
        for (var T in c) T !== "ref" && (C[T] = c[T]);
      } else C = c;
      return Ka(r), c = Sf(i, r, s, C, y, g), T = Cf(), i !== null && !Me ? (wf(i, r, g), $r(i, r, g)) : (It && T && nf(r), r.flags |= 1, Re(i, r, c, g), r.child);
    }
    function hy(i, r, s, c, g) {
      if (i === null) {
        var y = s.type;
        return typeof y == "function" && !ef(y) && y.defaultProps === void 0 && s.compare === null ? (r.tag = 15, r.type = y, fy(i, r, y, c, g)) : (i = Zo(s.type, null, c, r, r.mode, g), i.ref = r.ref, i.return = r, r.child = i);
      }
      if (y = i.child, !Wf(i, g)) {
        var C = y.memoizedProps;
        if (s = s.compare, s = s !== null ? s : Zl, s(C, c) && i.ref === r.ref) return $r(i, r, g);
      }
      return r.flags |= 1, i = Er(y, c), i.ref = r.ref, i.return = r, r.child = i;
    }
    function fy(i, r, s, c, g) {
      if (i !== null) {
        var y = i.memoizedProps;
        if (Zl(y, c) && i.ref === r.ref) if (Me = false, r.pendingProps = c = y, Wf(i, g)) (i.flags & 131072) !== 0 && (Me = true);
        else return r.lanes = i.lanes, $r(i, r, g);
      }
      return Hf(i, r, s, c, g);
    }
    function dy(i, r, s) {
      var c = r.pendingProps, g = c.children, y = i !== null ? i.memoizedState : null;
      if (c.mode === "hidden") {
        if ((r.flags & 128) !== 0) {
          if (c = y !== null ? y.baseLanes | s : s, i !== null) {
            for (g = r.child = i.child, y = 0; g !== null; ) y = y | g.lanes | g.childLanes, g = g.sibling;
            r.childLanes = y & ~c;
          } else r.childLanes = 0, r.child = null;
          return py(i, r, c, s);
        }
        if ((s & 536870912) !== 0) r.memoizedState = {
          baseLanes: 0,
          cachePool: null
        }, i !== null && ec(r, y !== null ? y.cachePool : null), y !== null ? fm(r, y) : xf(), ty(r);
        else return r.lanes = r.childLanes = 536870912, py(i, r, y !== null ? y.baseLanes | s : s, s);
      } else y !== null ? (ec(r, y.cachePool), fm(r, y), ha(), r.memoizedState = null) : (i !== null && ec(r, null), xf(), ha());
      return Re(i, r, g, s), r.child;
    }
    function py(i, r, s, c) {
      var g = df();
      return g = g === null ? null : {
        parent: Ce._currentValue,
        pool: g
      }, r.memoizedState = {
        baseLanes: s,
        cachePool: g
      }, i !== null && ec(r, null), xf(), ty(r), i !== null && es(i, r, c, true), null;
    }
    function bc(i, r) {
      var s = r.ref;
      if (s === null) i !== null && i.ref !== null && (r.flags |= 4194816);
      else {
        if (typeof s != "function" && typeof s != "object") throw Error(n(284));
        (i === null || i.ref !== s) && (r.flags |= 4194816);
      }
    }
    function Hf(i, r, s, c, g) {
      return Ka(r), s = Sf(i, r, s, c, void 0, g), c = Cf(), i !== null && !Me ? (wf(i, r, g), $r(i, r, g)) : (It && c && nf(r), r.flags |= 1, Re(i, r, s, g), r.child);
    }
    function gy(i, r, s, c, g, y) {
      return Ka(r), r.updateQueue = null, s = pm(r, c, s, g), dm(i), c = Cf(), i !== null && !Me ? (wf(i, r, y), $r(i, r, y)) : (It && c && nf(r), r.flags |= 1, Re(i, r, s, y), r.child);
    }
    function my(i, r, s, c, g) {
      if (Ka(r), r.stateNode === null) {
        var y = Un, C = s.contextType;
        typeof C == "object" && C !== null && (y = Pe(C)), y = new s(c, y), r.memoizedState = y.state !== null && y.state !== void 0 ? y.state : null, y.updater = Ff, r.stateNode = y, y._reactInternals = r, y = r.stateNode, y.props = c, y.state = r.memoizedState, y.refs = {}, gf(r), C = s.contextType, y.context = typeof C == "object" && C !== null ? Pe(C) : Un, y.state = r.memoizedState, C = s.getDerivedStateFromProps, typeof C == "function" && (zf(r, s, C, c), y.state = r.memoizedState), typeof s.getDerivedStateFromProps == "function" || typeof y.getSnapshotBeforeUpdate == "function" || typeof y.UNSAFE_componentWillMount != "function" && typeof y.componentWillMount != "function" || (C = y.state, typeof y.componentWillMount == "function" && y.componentWillMount(), typeof y.UNSAFE_componentWillMount == "function" && y.UNSAFE_componentWillMount(), C !== y.state && Ff.enqueueReplaceState(y, y.state, null), os(r, c, y, g), ss(), y.state = r.memoizedState), typeof y.componentDidMount == "function" && (r.flags |= 4194308), c = true;
      } else if (i === null) {
        y = r.stateNode;
        var T = r.memoizedProps, B = en(s, T);
        y.props = B;
        var U = y.context, Q = s.contextType;
        C = Un, typeof Q == "object" && Q !== null && (C = Pe(Q));
        var tt = s.getDerivedStateFromProps;
        Q = typeof tt == "function" || typeof y.getSnapshotBeforeUpdate == "function", T = r.pendingProps !== T, Q || typeof y.UNSAFE_componentWillReceiveProps != "function" && typeof y.componentWillReceiveProps != "function" || (T || U !== C) && iy(r, y, c, C), la = false;
        var I = r.memoizedState;
        y.state = I, os(r, c, y, g), ss(), U = r.memoizedState, T || I !== U || la ? (typeof tt == "function" && (zf(r, s, tt, c), U = r.memoizedState), (B = la || ey(r, s, B, c, I, U, C)) ? (Q || typeof y.UNSAFE_componentWillMount != "function" && typeof y.componentWillMount != "function" || (typeof y.componentWillMount == "function" && y.componentWillMount(), typeof y.UNSAFE_componentWillMount == "function" && y.UNSAFE_componentWillMount()), typeof y.componentDidMount == "function" && (r.flags |= 4194308)) : (typeof y.componentDidMount == "function" && (r.flags |= 4194308), r.memoizedProps = c, r.memoizedState = U), y.props = c, y.state = U, y.context = C, c = B) : (typeof y.componentDidMount == "function" && (r.flags |= 4194308), c = false);
      } else {
        y = r.stateNode, mf(i, r), C = r.memoizedProps, Q = en(s, C), y.props = Q, tt = r.pendingProps, I = y.context, U = s.contextType, B = Un, typeof U == "object" && U !== null && (B = Pe(U)), T = s.getDerivedStateFromProps, (U = typeof T == "function" || typeof y.getSnapshotBeforeUpdate == "function") || typeof y.UNSAFE_componentWillReceiveProps != "function" && typeof y.componentWillReceiveProps != "function" || (C !== tt || I !== B) && iy(r, y, c, B), la = false, I = r.memoizedState, y.state = I, os(r, c, y, g), ss();
        var P = r.memoizedState;
        C !== tt || I !== P || la || i !== null && i.dependencies !== null && Jo(i.dependencies) ? (typeof T == "function" && (zf(r, s, T, c), P = r.memoizedState), (Q = la || ey(r, s, Q, c, I, P, B) || i !== null && i.dependencies !== null && Jo(i.dependencies)) ? (U || typeof y.UNSAFE_componentWillUpdate != "function" && typeof y.componentWillUpdate != "function" || (typeof y.componentWillUpdate == "function" && y.componentWillUpdate(c, P, B), typeof y.UNSAFE_componentWillUpdate == "function" && y.UNSAFE_componentWillUpdate(c, P, B)), typeof y.componentDidUpdate == "function" && (r.flags |= 4), typeof y.getSnapshotBeforeUpdate == "function" && (r.flags |= 1024)) : (typeof y.componentDidUpdate != "function" || C === i.memoizedProps && I === i.memoizedState || (r.flags |= 4), typeof y.getSnapshotBeforeUpdate != "function" || C === i.memoizedProps && I === i.memoizedState || (r.flags |= 1024), r.memoizedProps = c, r.memoizedState = P), y.props = c, y.state = P, y.context = B, c = Q) : (typeof y.componentDidUpdate != "function" || C === i.memoizedProps && I === i.memoizedState || (r.flags |= 4), typeof y.getSnapshotBeforeUpdate != "function" || C === i.memoizedProps && I === i.memoizedState || (r.flags |= 1024), c = false);
      }
      return y = c, bc(i, r), c = (r.flags & 128) !== 0, y || c ? (y = r.stateNode, s = c && typeof s.getDerivedStateFromError != "function" ? null : y.render(), r.flags |= 1, i !== null && c ? (r.child = Qn(r, i.child, null, g), r.child = Qn(r, null, s, g)) : Re(i, r, s, g), r.memoizedState = y.state, i = r.child) : i = $r(i, r, g), i;
    }
    function yy(i, r, s, c) {
      return Jl(), r.flags |= 256, Re(i, r, s, c), r.child;
    }
    var Uf = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0,
      hydrationErrors: null
    };
    function jf(i) {
      return {
        baseLanes: i,
        cachePool: am()
      };
    }
    function Yf(i, r, s) {
      return i = i !== null ? i.childLanes & ~s : 0, r && (i |= zi), i;
    }
    function by(i, r, s) {
      var c = r.pendingProps, g = false, y = (r.flags & 128) !== 0, C;
      if ((C = y) || (C = i !== null && i.memoizedState === null ? false : (we.current & 2) !== 0), C && (g = true, r.flags &= -129), C = (r.flags & 32) !== 0, r.flags &= -33, i === null) {
        if (It) {
          if (g ? ua(r) : ha(), It) {
            var T = ce, B;
            if (B = T) {
              t: {
                for (B = T, T = sr; B.nodeType !== 8; ) {
                  if (!T) {
                    T = null;
                    break t;
                  }
                  if (B = Zi(B.nextSibling), B === null) {
                    T = null;
                    break t;
                  }
                }
                T = B;
              }
              T !== null ? (r.memoizedState = {
                dehydrated: T,
                treeContext: Wa !== null ? {
                  id: Mr,
                  overflow: Br
                } : null,
                retryLane: 536870912,
                hydrationErrors: null
              }, B = vi(18, null, null, 0), B.stateNode = T, B.return = r, r.child = B, Ke = r, ce = null, B = true) : B = false;
            }
            B || Za(r);
          }
          if (T = r.memoizedState, T !== null && (T = T.dehydrated, T !== null)) return kd(T) ? r.lanes = 32 : r.lanes = 536870912, null;
          Rr(r);
        }
        return T = c.children, c = c.fallback, g ? (ha(), g = r.mode, T = xc({
          mode: "hidden",
          children: T
        }, g), c = Ga(c, g, s, null), T.return = r, c.return = r, T.sibling = c, r.child = T, g = r.child, g.memoizedState = jf(s), g.childLanes = Yf(i, C, s), r.memoizedState = Uf, c) : (ua(r), If(r, T));
      }
      if (B = i.memoizedState, B !== null && (T = B.dehydrated, T !== null)) {
        if (y) r.flags & 256 ? (ua(r), r.flags &= -257, r = Pf(i, r, s)) : r.memoizedState !== null ? (ha(), r.child = i.child, r.flags |= 128, r = null) : (ha(), g = c.fallback, T = r.mode, c = xc({
          mode: "visible",
          children: c.children
        }, T), g = Ga(g, T, s, null), g.flags |= 2, c.return = r, g.return = r, c.sibling = g, r.child = c, Qn(r, i.child, null, s), c = r.child, c.memoizedState = jf(s), c.childLanes = Yf(i, C, s), r.memoizedState = Uf, r = g);
        else if (ua(r), kd(T)) {
          if (C = T.nextSibling && T.nextSibling.dataset, C) var U = C.dgst;
          C = U, c = Error(n(419)), c.stack = "", c.digest = C, ts({
            value: c,
            source: null,
            stack: null
          }), r = Pf(i, r, s);
        } else if (Me || es(i, r, s, false), C = (s & i.childLanes) !== 0, Me || C) {
          if (C = ie, C !== null && (c = s & -s, c = (c & 42) !== 0 ? 1 : ar(c), c = (c & (C.suspendedLanes | s)) !== 0 ? 0 : c, c !== 0 && c !== B.retryLane)) throw B.retryLane = c, Hn(i, c), Ti(C, i, c), cy;
          T.data === "$?" || cd(), r = Pf(i, r, s);
        } else T.data === "$?" ? (r.flags |= 192, r.child = i.child, r = null) : (i = B.treeContext, ce = Zi(T.nextSibling), Ke = r, It = true, Va = null, sr = false, i !== null && (Ri[$i++] = Mr, Ri[$i++] = Br, Ri[$i++] = Wa, Mr = i.id, Br = i.overflow, Wa = r), r = If(r, c.children), r.flags |= 4096);
        return r;
      }
      return g ? (ha(), g = c.fallback, T = r.mode, B = i.child, U = B.sibling, c = Er(B, {
        mode: "hidden",
        children: c.children
      }), c.subtreeFlags = B.subtreeFlags & 65011712, U !== null ? g = Er(U, g) : (g = Ga(g, T, s, null), g.flags |= 2), g.return = r, c.return = r, c.sibling = g, r.child = c, c = g, g = r.child, T = i.child.memoizedState, T === null ? T = jf(s) : (B = T.cachePool, B !== null ? (U = Ce._currentValue, B = B.parent !== U ? {
        parent: U,
        pool: U
      } : B) : B = am(), T = {
        baseLanes: T.baseLanes | s,
        cachePool: B
      }), g.memoizedState = T, g.childLanes = Yf(i, C, s), r.memoizedState = Uf, c) : (ua(r), s = i.child, i = s.sibling, s = Er(s, {
        mode: "visible",
        children: c.children
      }), s.return = r, s.sibling = null, i !== null && (C = r.deletions, C === null ? (r.deletions = [
        i
      ], r.flags |= 16) : C.push(i)), r.child = s, r.memoizedState = null, s);
    }
    function If(i, r) {
      return r = xc({
        mode: "visible",
        children: r
      }, i.mode), r.return = i, i.child = r;
    }
    function xc(i, r) {
      return i = vi(22, i, null, r), i.lanes = 0, i.stateNode = {
        _visibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      }, i;
    }
    function Pf(i, r, s) {
      return Qn(r, i.child, null, s), i = If(r, r.pendingProps.children), i.flags |= 2, r.memoizedState = null, i;
    }
    function xy(i, r, s) {
      i.lanes |= r;
      var c = i.alternate;
      c !== null && (c.lanes |= r), cf(i.return, r, s);
    }
    function Gf(i, r, s, c, g) {
      var y = i.memoizedState;
      y === null ? i.memoizedState = {
        isBackwards: r,
        rendering: null,
        renderingStartTime: 0,
        last: c,
        tail: s,
        tailMode: g
      } : (y.isBackwards = r, y.rendering = null, y.renderingStartTime = 0, y.last = c, y.tail = s, y.tailMode = g);
    }
    function vy(i, r, s) {
      var c = r.pendingProps, g = c.revealOrder, y = c.tail;
      if (Re(i, r, c.children, s), c = we.current, (c & 2) !== 0) c = c & 1 | 2, r.flags |= 128;
      else {
        if (i !== null && (i.flags & 128) !== 0) t: for (i = r.child; i !== null; ) {
          if (i.tag === 13) i.memoizedState !== null && xy(i, s, r);
          else if (i.tag === 19) xy(i, s, r);
          else if (i.child !== null) {
            i.child.return = i, i = i.child;
            continue;
          }
          if (i === r) break t;
          for (; i.sibling === null; ) {
            if (i.return === null || i.return === r) break t;
            i = i.return;
          }
          i.sibling.return = i.return, i = i.sibling;
        }
        c &= 1;
      }
      switch (Z(we, c), g) {
        case "forwards":
          for (s = r.child, g = null; s !== null; ) i = s.alternate, i !== null && gc(i) === null && (g = s), s = s.sibling;
          s = g, s === null ? (g = r.child, r.child = null) : (g = s.sibling, s.sibling = null), Gf(r, false, g, s, y);
          break;
        case "backwards":
          for (s = null, g = r.child, r.child = null; g !== null; ) {
            if (i = g.alternate, i !== null && gc(i) === null) {
              r.child = g;
              break;
            }
            i = g.sibling, g.sibling = s, s = g, g = i;
          }
          Gf(r, true, s, null, y);
          break;
        case "together":
          Gf(r, false, null, null, void 0);
          break;
        default:
          r.memoizedState = null;
      }
      return r.child;
    }
    function $r(i, r, s) {
      if (i !== null && (r.dependencies = i.dependencies), ma |= r.lanes, (s & r.childLanes) === 0) if (i !== null) {
        if (es(i, r, s, false), (s & r.childLanes) === 0) return null;
      } else return null;
      if (i !== null && r.child !== i.child) throw Error(n(153));
      if (r.child !== null) {
        for (i = r.child, s = Er(i, i.pendingProps), r.child = s, s.return = r; i.sibling !== null; ) i = i.sibling, s = s.sibling = Er(i, i.pendingProps), s.return = r;
        s.sibling = null;
      }
      return r.child;
    }
    function Wf(i, r) {
      return (i.lanes & r) !== 0 ? true : (i = i.dependencies, !!(i !== null && Jo(i)));
    }
    function ak(i, r, s) {
      switch (r.tag) {
        case 3:
          qt(r, r.stateNode.containerInfo), na(r, Ce, i.memoizedState.cache), Jl();
          break;
        case 27:
        case 5:
          re(r);
          break;
        case 4:
          qt(r, r.stateNode.containerInfo);
          break;
        case 10:
          na(r, r.type, r.memoizedProps.value);
          break;
        case 13:
          var c = r.memoizedState;
          if (c !== null) return c.dehydrated !== null ? (ua(r), r.flags |= 128, null) : (s & r.child.childLanes) !== 0 ? by(i, r, s) : (ua(r), i = $r(i, r, s), i !== null ? i.sibling : null);
          ua(r);
          break;
        case 19:
          var g = (i.flags & 128) !== 0;
          if (c = (s & r.childLanes) !== 0, c || (es(i, r, s, false), c = (s & r.childLanes) !== 0), g) {
            if (c) return vy(i, r, s);
            r.flags |= 128;
          }
          if (g = r.memoizedState, g !== null && (g.rendering = null, g.tail = null, g.lastEffect = null), Z(we, we.current), c) break;
          return null;
        case 22:
        case 23:
          return r.lanes = 0, dy(i, r, s);
        case 24:
          na(r, Ce, i.memoizedState.cache);
      }
      return $r(i, r, s);
    }
    function _y(i, r, s) {
      if (i !== null) if (i.memoizedProps !== r.pendingProps) Me = true;
      else {
        if (!Wf(i, s) && (r.flags & 128) === 0) return Me = false, ak(i, r, s);
        Me = (i.flags & 131072) !== 0;
      }
      else Me = false, It && (r.flags & 1048576) !== 0 && Q0(r, Ko, r.index);
      switch (r.lanes = 0, r.tag) {
        case 16:
          t: {
            i = r.pendingProps;
            var c = r.elementType, g = c._init;
            if (c = g(c._payload), r.type = c, typeof c == "function") ef(c) ? (i = en(c, i), r.tag = 1, r = my(null, r, c, i, s)) : (r.tag = 0, r = Hf(null, r, c, i, s));
            else {
              if (c != null) {
                if (g = c.$$typeof, g === $) {
                  r.tag = 11, r = uy(null, r, c, i, s);
                  break t;
                } else if (g === j) {
                  r.tag = 14, r = hy(null, r, c, i, s);
                  break t;
                }
              }
              throw r = V(c) || c, Error(n(306, r, ""));
            }
          }
          return r;
        case 0:
          return Hf(i, r, r.type, r.pendingProps, s);
        case 1:
          return c = r.type, g = en(c, r.pendingProps), my(i, r, c, g, s);
        case 3:
          t: {
            if (qt(r, r.stateNode.containerInfo), i === null) throw Error(n(387));
            c = r.pendingProps;
            var y = r.memoizedState;
            g = y.element, mf(i, r), os(r, c, null, s);
            var C = r.memoizedState;
            if (c = C.cache, na(r, Ce, c), c !== y.cache && uf(r, [
              Ce
            ], s, true), ss(), c = C.element, y.isDehydrated) if (y = {
              element: c,
              isDehydrated: false,
              cache: C.cache
            }, r.updateQueue.baseState = y, r.memoizedState = y, r.flags & 256) {
              r = yy(i, r, c, s);
              break t;
            } else if (c !== g) {
              g = Oi(Error(n(424)), r), ts(g), r = yy(i, r, c, s);
              break t;
            } else {
              switch (i = r.stateNode.containerInfo, i.nodeType) {
                case 9:
                  i = i.body;
                  break;
                default:
                  i = i.nodeName === "HTML" ? i.ownerDocument.body : i;
              }
              for (ce = Zi(i.firstChild), Ke = r, It = true, Va = null, sr = true, s = Jm(r, null, c, s), r.child = s; s; ) s.flags = s.flags & -3 | 4096, s = s.sibling;
            }
            else {
              if (Jl(), c === g) {
                r = $r(i, r, s);
                break t;
              }
              Re(i, r, c, s);
            }
            r = r.child;
          }
          return r;
        case 26:
          return bc(i, r), i === null ? (s = Tb(r.type, null, r.pendingProps, null)) ? r.memoizedState = s : It || (s = r.type, i = r.pendingProps, c = Dc(pt.current).createElement(s), c[_e2] = r, c[Ye] = i, Ne(c, s, i), me(c), r.stateNode = c) : r.memoizedState = Tb(r.type, i.memoizedProps, r.pendingProps, i.memoizedState), null;
        case 27:
          return re(r), i === null && It && (c = r.stateNode = Sb(r.type, r.pendingProps, pt.current), Ke = r, sr = true, g = ce, va(r.type) ? (Ad = g, ce = Zi(c.firstChild)) : ce = g), Re(i, r, r.pendingProps.children, s), bc(i, r), i === null && (r.flags |= 4194304), r.child;
        case 5:
          return i === null && It && ((g = c = ce) && (c = Ok(c, r.type, r.pendingProps, sr), c !== null ? (r.stateNode = c, Ke = r, ce = Zi(c.firstChild), sr = false, g = true) : g = false), g || Za(r)), re(r), g = r.type, y = r.pendingProps, C = i !== null ? i.memoizedProps : null, c = y.children, Cd(g, y) ? c = null : C !== null && Cd(g, C) && (r.flags |= 32), r.memoizedState !== null && (g = Sf(i, r, ZT, null, null, s), Bs._currentValue = g), bc(i, r), Re(i, r, c, s), r.child;
        case 6:
          return i === null && It && ((i = s = ce) && (s = Dk(s, r.pendingProps, sr), s !== null ? (r.stateNode = s, Ke = r, ce = null, i = true) : i = false), i || Za(r)), null;
        case 13:
          return by(i, r, s);
        case 4:
          return qt(r, r.stateNode.containerInfo), c = r.pendingProps, i === null ? r.child = Qn(r, null, c, s) : Re(i, r, c, s), r.child;
        case 11:
          return uy(i, r, r.type, r.pendingProps, s);
        case 7:
          return Re(i, r, r.pendingProps, s), r.child;
        case 8:
          return Re(i, r, r.pendingProps.children, s), r.child;
        case 12:
          return Re(i, r, r.pendingProps.children, s), r.child;
        case 10:
          return c = r.pendingProps, na(r, r.type, c.value), Re(i, r, c.children, s), r.child;
        case 9:
          return g = r.type._context, c = r.pendingProps.children, Ka(r), g = Pe(g), c = c(g), r.flags |= 1, Re(i, r, c, s), r.child;
        case 14:
          return hy(i, r, r.type, r.pendingProps, s);
        case 15:
          return fy(i, r, r.type, r.pendingProps, s);
        case 19:
          return vy(i, r, s);
        case 31:
          return c = r.pendingProps, s = r.mode, c = {
            mode: c.mode,
            children: c.children
          }, i === null ? (s = xc(c, s), s.ref = r.ref, r.child = s, s.return = r, r = s) : (s = Er(i.child, c), s.ref = r.ref, r.child = s, s.return = r, r = s), r;
        case 22:
          return dy(i, r, s);
        case 24:
          return Ka(r), c = Pe(Ce), i === null ? (g = df(), g === null && (g = ie, y = hf(), g.pooledCache = y, y.refCount++, y !== null && (g.pooledCacheLanes |= s), g = y), r.memoizedState = {
            parent: c,
            cache: g
          }, gf(r), na(r, Ce, g)) : ((i.lanes & s) !== 0 && (mf(i, r), os(r, null, null, s), ss()), g = i.memoizedState, y = r.memoizedState, g.parent !== c ? (g = {
            parent: c,
            cache: c
          }, r.memoizedState = g, r.lanes === 0 && (r.memoizedState = r.updateQueue.baseState = g), na(r, Ce, c)) : (c = y.cache, na(r, Ce, c), c !== g.cache && uf(r, [
            Ce
          ], s, true))), Re(i, r, r.pendingProps.children, s), r.child;
        case 29:
          throw r.pendingProps;
      }
      throw Error(n(156, r.tag));
    }
    function Nr(i) {
      i.flags |= 4;
    }
    function Sy(i, r) {
      if (r.type !== "stylesheet" || (r.state.loading & 4) !== 0) i.flags &= -16777217;
      else if (i.flags |= 16777216, !Bb(r)) {
        if (r = Ni.current, r !== null && ((Ut & 4194048) === Ut ? or !== null : (Ut & 62914560) !== Ut && (Ut & 536870912) === 0 || r !== or)) throw ns = pf, nm;
        i.flags |= 8192;
      }
    }
    function vc(i, r) {
      r !== null && (i.flags |= 4), i.flags & 16384 && (r = i.tag !== 22 ? ja() : 536870912, i.lanes |= r, el |= r);
    }
    function gs(i, r) {
      if (!It) switch (i.tailMode) {
        case "hidden":
          r = i.tail;
          for (var s = null; r !== null; ) r.alternate !== null && (s = r), r = r.sibling;
          s === null ? i.tail = null : s.sibling = null;
          break;
        case "collapsed":
          s = i.tail;
          for (var c = null; s !== null; ) s.alternate !== null && (c = s), s = s.sibling;
          c === null ? r || i.tail === null ? i.tail = null : i.tail.sibling = null : c.sibling = null;
      }
    }
    function se(i) {
      var r = i.alternate !== null && i.alternate.child === i.child, s = 0, c = 0;
      if (r) for (var g = i.child; g !== null; ) s |= g.lanes | g.childLanes, c |= g.subtreeFlags & 65011712, c |= g.flags & 65011712, g.return = i, g = g.sibling;
      else for (g = i.child; g !== null; ) s |= g.lanes | g.childLanes, c |= g.subtreeFlags, c |= g.flags, g.return = i, g = g.sibling;
      return i.subtreeFlags |= c, i.childLanes = s, r;
    }
    function nk(i, r, s) {
      var c = r.pendingProps;
      switch (lf(r), r.tag) {
        case 31:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return se(r), null;
        case 1:
          return se(r), null;
        case 3:
          return s = r.stateNode, c = null, i !== null && (c = i.memoizedState.cache), r.memoizedState.cache !== c && (r.flags |= 2048), Or(Ce), he(), s.pendingContext && (s.context = s.pendingContext, s.pendingContext = null), (i === null || i.child === null) && (Kl(r) ? Nr(r) : i === null || i.memoizedState.isDehydrated && (r.flags & 256) === 0 || (r.flags |= 1024, tm())), se(r), null;
        case 26:
          return s = r.memoizedState, i === null ? (Nr(r), s !== null ? (se(r), Sy(r, s)) : (se(r), r.flags &= -16777217)) : s ? s !== i.memoizedState ? (Nr(r), se(r), Sy(r, s)) : (se(r), r.flags &= -16777217) : (i.memoizedProps !== c && Nr(r), se(r), r.flags &= -16777217), null;
        case 27:
          qe(r), s = pt.current;
          var g = r.type;
          if (i !== null && r.stateNode != null) i.memoizedProps !== c && Nr(r);
          else {
            if (!c) {
              if (r.stateNode === null) throw Error(n(166));
              return se(r), null;
            }
            i = ct.current, Kl(r) ? K0(r) : (i = Sb(g, c, s), r.stateNode = i, Nr(r));
          }
          return se(r), null;
        case 5:
          if (qe(r), s = r.type, i !== null && r.stateNode != null) i.memoizedProps !== c && Nr(r);
          else {
            if (!c) {
              if (r.stateNode === null) throw Error(n(166));
              return se(r), null;
            }
            if (i = ct.current, Kl(r)) K0(r);
            else {
              switch (g = Dc(pt.current), i) {
                case 1:
                  i = g.createElementNS("http://www.w3.org/2000/svg", s);
                  break;
                case 2:
                  i = g.createElementNS("http://www.w3.org/1998/Math/MathML", s);
                  break;
                default:
                  switch (s) {
                    case "svg":
                      i = g.createElementNS("http://www.w3.org/2000/svg", s);
                      break;
                    case "math":
                      i = g.createElementNS("http://www.w3.org/1998/Math/MathML", s);
                      break;
                    case "script":
                      i = g.createElement("div"), i.innerHTML = "<script><\/script>", i = i.removeChild(i.firstChild);
                      break;
                    case "select":
                      i = typeof c.is == "string" ? g.createElement("select", {
                        is: c.is
                      }) : g.createElement("select"), c.multiple ? i.multiple = true : c.size && (i.size = c.size);
                      break;
                    default:
                      i = typeof c.is == "string" ? g.createElement(s, {
                        is: c.is
                      }) : g.createElement(s);
                  }
              }
              i[_e2] = r, i[Ye] = c;
              t: for (g = r.child; g !== null; ) {
                if (g.tag === 5 || g.tag === 6) i.appendChild(g.stateNode);
                else if (g.tag !== 4 && g.tag !== 27 && g.child !== null) {
                  g.child.return = g, g = g.child;
                  continue;
                }
                if (g === r) break t;
                for (; g.sibling === null; ) {
                  if (g.return === null || g.return === r) break t;
                  g = g.return;
                }
                g.sibling.return = g.return, g = g.sibling;
              }
              r.stateNode = i;
              t: switch (Ne(i, s, c), s) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  i = !!c.autoFocus;
                  break t;
                case "img":
                  i = true;
                  break t;
                default:
                  i = false;
              }
              i && Nr(r);
            }
          }
          return se(r), r.flags &= -16777217, null;
        case 6:
          if (i && r.stateNode != null) i.memoizedProps !== c && Nr(r);
          else {
            if (typeof c != "string" && r.stateNode === null) throw Error(n(166));
            if (i = pt.current, Kl(r)) {
              if (i = r.stateNode, s = r.memoizedProps, c = null, g = Ke, g !== null) switch (g.tag) {
                case 27:
                case 5:
                  c = g.memoizedProps;
              }
              i[_e2] = r, i = !!(i.nodeValue === s || c !== null && c.suppressHydrationWarning === true || gb(i.nodeValue, s)), i || Za(r);
            } else i = Dc(i).createTextNode(c), i[_e2] = r, r.stateNode = i;
          }
          return se(r), null;
        case 13:
          if (c = r.memoizedState, i === null || i.memoizedState !== null && i.memoizedState.dehydrated !== null) {
            if (g = Kl(r), c !== null && c.dehydrated !== null) {
              if (i === null) {
                if (!g) throw Error(n(318));
                if (g = r.memoizedState, g = g !== null ? g.dehydrated : null, !g) throw Error(n(317));
                g[_e2] = r;
              } else Jl(), (r.flags & 128) === 0 && (r.memoizedState = null), r.flags |= 4;
              se(r), g = false;
            } else g = tm(), i !== null && i.memoizedState !== null && (i.memoizedState.hydrationErrors = g), g = true;
            if (!g) return r.flags & 256 ? (Rr(r), r) : (Rr(r), null);
          }
          if (Rr(r), (r.flags & 128) !== 0) return r.lanes = s, r;
          if (s = c !== null, i = i !== null && i.memoizedState !== null, s) {
            c = r.child, g = null, c.alternate !== null && c.alternate.memoizedState !== null && c.alternate.memoizedState.cachePool !== null && (g = c.alternate.memoizedState.cachePool.pool);
            var y = null;
            c.memoizedState !== null && c.memoizedState.cachePool !== null && (y = c.memoizedState.cachePool.pool), y !== g && (c.flags |= 2048);
          }
          return s !== i && s && (r.child.flags |= 8192), vc(r, r.updateQueue), se(r), null;
        case 4:
          return he(), i === null && bd(r.stateNode.containerInfo), se(r), null;
        case 10:
          return Or(r.type), se(r), null;
        case 19:
          if (K(we), g = r.memoizedState, g === null) return se(r), null;
          if (c = (r.flags & 128) !== 0, y = g.rendering, y === null) if (c) gs(g, false);
          else {
            if (ue !== 0 || i !== null && (i.flags & 128) !== 0) for (i = r.child; i !== null; ) {
              if (y = gc(i), y !== null) {
                for (r.flags |= 128, gs(g, false), i = y.updateQueue, r.updateQueue = i, vc(r, i), r.subtreeFlags = 0, i = s, s = r.child; s !== null; ) Z0(s, i), s = s.sibling;
                return Z(we, we.current & 1 | 2), r.child;
              }
              i = i.sibling;
            }
            g.tail !== null && Oe() > Cc && (r.flags |= 128, c = true, gs(g, false), r.lanes = 4194304);
          }
          else {
            if (!c) if (i = gc(y), i !== null) {
              if (r.flags |= 128, c = true, i = i.updateQueue, r.updateQueue = i, vc(r, i), gs(g, true), g.tail === null && g.tailMode === "hidden" && !y.alternate && !It) return se(r), null;
            } else 2 * Oe() - g.renderingStartTime > Cc && s !== 536870912 && (r.flags |= 128, c = true, gs(g, false), r.lanes = 4194304);
            g.isBackwards ? (y.sibling = r.child, r.child = y) : (i = g.last, i !== null ? i.sibling = y : r.child = y, g.last = y);
          }
          return g.tail !== null ? (r = g.tail, g.rendering = r, g.tail = r.sibling, g.renderingStartTime = Oe(), r.sibling = null, i = we.current, Z(we, c ? i & 1 | 2 : i & 1), r) : (se(r), null);
        case 22:
        case 23:
          return Rr(r), vf(), c = r.memoizedState !== null, i !== null ? i.memoizedState !== null !== c && (r.flags |= 8192) : c && (r.flags |= 8192), c ? (s & 536870912) !== 0 && (r.flags & 128) === 0 && (se(r), r.subtreeFlags & 6 && (r.flags |= 8192)) : se(r), s = r.updateQueue, s !== null && vc(r, s.retryQueue), s = null, i !== null && i.memoizedState !== null && i.memoizedState.cachePool !== null && (s = i.memoizedState.cachePool.pool), c = null, r.memoizedState !== null && r.memoizedState.cachePool !== null && (c = r.memoizedState.cachePool.pool), c !== s && (r.flags |= 2048), i !== null && K(Ja), null;
        case 24:
          return s = null, i !== null && (s = i.memoizedState.cache), r.memoizedState.cache !== s && (r.flags |= 2048), Or(Ce), se(r), null;
        case 25:
          return null;
        case 30:
          return null;
      }
      throw Error(n(156, r.tag));
    }
    function lk(i, r) {
      switch (lf(r), r.tag) {
        case 1:
          return i = r.flags, i & 65536 ? (r.flags = i & -65537 | 128, r) : null;
        case 3:
          return Or(Ce), he(), i = r.flags, (i & 65536) !== 0 && (i & 128) === 0 ? (r.flags = i & -65537 | 128, r) : null;
        case 26:
        case 27:
        case 5:
          return qe(r), null;
        case 13:
          if (Rr(r), i = r.memoizedState, i !== null && i.dehydrated !== null) {
            if (r.alternate === null) throw Error(n(340));
            Jl();
          }
          return i = r.flags, i & 65536 ? (r.flags = i & -65537 | 128, r) : null;
        case 19:
          return K(we), null;
        case 4:
          return he(), null;
        case 10:
          return Or(r.type), null;
        case 22:
        case 23:
          return Rr(r), vf(), i !== null && K(Ja), i = r.flags, i & 65536 ? (r.flags = i & -65537 | 128, r) : null;
        case 24:
          return Or(Ce), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function Cy(i, r) {
      switch (lf(r), r.tag) {
        case 3:
          Or(Ce), he();
          break;
        case 26:
        case 27:
        case 5:
          qe(r);
          break;
        case 4:
          he();
          break;
        case 13:
          Rr(r);
          break;
        case 19:
          K(we);
          break;
        case 10:
          Or(r.type);
          break;
        case 22:
        case 23:
          Rr(r), vf(), i !== null && K(Ja);
          break;
        case 24:
          Or(Ce);
      }
    }
    function ms(i, r) {
      try {
        var s = r.updateQueue, c = s !== null ? s.lastEffect : null;
        if (c !== null) {
          var g = c.next;
          s = g;
          do {
            if ((s.tag & i) === i) {
              c = void 0;
              var y = s.create, C = s.inst;
              c = y(), C.destroy = c;
            }
            s = s.next;
          } while (s !== g);
        }
      } catch (T) {
        te(r, r.return, T);
      }
    }
    function fa(i, r, s) {
      try {
        var c = r.updateQueue, g = c !== null ? c.lastEffect : null;
        if (g !== null) {
          var y = g.next;
          c = y;
          do {
            if ((c.tag & i) === i) {
              var C = c.inst, T = C.destroy;
              if (T !== void 0) {
                C.destroy = void 0, g = r;
                var B = s, U = T;
                try {
                  U();
                } catch (Q) {
                  te(g, B, Q);
                }
              }
            }
            c = c.next;
          } while (c !== y);
        }
      } catch (Q) {
        te(r, r.return, Q);
      }
    }
    function wy(i) {
      var r = i.updateQueue;
      if (r !== null) {
        var s = i.stateNode;
        try {
          hm(r, s);
        } catch (c) {
          te(i, i.return, c);
        }
      }
    }
    function Ty(i, r, s) {
      s.props = en(i.type, i.memoizedProps), s.state = i.memoizedState;
      try {
        s.componentWillUnmount();
      } catch (c) {
        te(i, r, c);
      }
    }
    function ys(i, r) {
      try {
        var s = i.ref;
        if (s !== null) {
          switch (i.tag) {
            case 26:
            case 27:
            case 5:
              var c = i.stateNode;
              break;
            case 30:
              c = i.stateNode;
              break;
            default:
              c = i.stateNode;
          }
          typeof s == "function" ? i.refCleanup = s(c) : s.current = c;
        }
      } catch (g) {
        te(i, r, g);
      }
    }
    function cr(i, r) {
      var s = i.ref, c = i.refCleanup;
      if (s !== null) if (typeof c == "function") try {
        c();
      } catch (g) {
        te(i, r, g);
      } finally {
        i.refCleanup = null, i = i.alternate, i != null && (i.refCleanup = null);
      }
      else if (typeof s == "function") try {
        s(null);
      } catch (g) {
        te(i, r, g);
      }
      else s.current = null;
    }
    function ky(i) {
      var r = i.type, s = i.memoizedProps, c = i.stateNode;
      try {
        t: switch (r) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            s.autoFocus && c.focus();
            break t;
          case "img":
            s.src ? c.src = s.src : s.srcSet && (c.srcset = s.srcSet);
        }
      } catch (g) {
        te(i, i.return, g);
      }
    }
    function Xf(i, r, s) {
      try {
        var c = i.stateNode;
        Ak(c, i.type, s, r), c[Ye] = r;
      } catch (g) {
        te(i, i.return, g);
      }
    }
    function Ay(i) {
      return i.tag === 5 || i.tag === 3 || i.tag === 26 || i.tag === 27 && va(i.type) || i.tag === 4;
    }
    function Vf(i) {
      t: for (; ; ) {
        for (; i.sibling === null; ) {
          if (i.return === null || Ay(i.return)) return null;
          i = i.return;
        }
        for (i.sibling.return = i.return, i = i.sibling; i.tag !== 5 && i.tag !== 6 && i.tag !== 18; ) {
          if (i.tag === 27 && va(i.type) || i.flags & 2 || i.child === null || i.tag === 4) continue t;
          i.child.return = i, i = i.child;
        }
        if (!(i.flags & 2)) return i.stateNode;
      }
    }
    function Zf(i, r, s) {
      var c = i.tag;
      if (c === 5 || c === 6) i = i.stateNode, r ? (s.nodeType === 9 ? s.body : s.nodeName === "HTML" ? s.ownerDocument.body : s).insertBefore(i, r) : (r = s.nodeType === 9 ? s.body : s.nodeName === "HTML" ? s.ownerDocument.body : s, r.appendChild(i), s = s._reactRootContainer, s != null || r.onclick !== null || (r.onclick = Oc));
      else if (c !== 4 && (c === 27 && va(i.type) && (s = i.stateNode, r = null), i = i.child, i !== null)) for (Zf(i, r, s), i = i.sibling; i !== null; ) Zf(i, r, s), i = i.sibling;
    }
    function _c2(i, r, s) {
      var c = i.tag;
      if (c === 5 || c === 6) i = i.stateNode, r ? s.insertBefore(i, r) : s.appendChild(i);
      else if (c !== 4 && (c === 27 && va(i.type) && (s = i.stateNode), i = i.child, i !== null)) for (_c2(i, r, s), i = i.sibling; i !== null; ) _c2(i, r, s), i = i.sibling;
    }
    function Ey(i) {
      var r = i.stateNode, s = i.memoizedProps;
      try {
        for (var c = i.type, g = r.attributes; g.length; ) r.removeAttributeNode(g[0]);
        Ne(r, c, s), r[_e2] = i, r[Ye] = s;
      } catch (y) {
        te(i, i.return, y);
      }
    }
    var zr = false, pe = false, Qf = false, My = typeof WeakSet == "function" ? WeakSet : Set, Be = null;
    function sk(i, r) {
      if (i = i.containerInfo, _d2 = qc, i = H0(i), Xh(i)) {
        if ("selectionStart" in i) var s = {
          start: i.selectionStart,
          end: i.selectionEnd
        };
        else t: {
          s = (s = i.ownerDocument) && s.defaultView || window;
          var c = s.getSelection && s.getSelection();
          if (c && c.rangeCount !== 0) {
            s = c.anchorNode;
            var g = c.anchorOffset, y = c.focusNode;
            c = c.focusOffset;
            try {
              s.nodeType, y.nodeType;
            } catch {
              s = null;
              break t;
            }
            var C = 0, T = -1, B = -1, U = 0, Q = 0, tt = i, I = null;
            e: for (; ; ) {
              for (var P; tt !== s || g !== 0 && tt.nodeType !== 3 || (T = C + g), tt !== y || c !== 0 && tt.nodeType !== 3 || (B = C + c), tt.nodeType === 3 && (C += tt.nodeValue.length), (P = tt.firstChild) !== null; ) I = tt, tt = P;
              for (; ; ) {
                if (tt === i) break e;
                if (I === s && ++U === g && (T = C), I === y && ++Q === c && (B = C), (P = tt.nextSibling) !== null) break;
                tt = I, I = tt.parentNode;
              }
              tt = P;
            }
            s = T === -1 || B === -1 ? null : {
              start: T,
              end: B
            };
          } else s = null;
        }
        s = s || {
          start: 0,
          end: 0
        };
      } else s = null;
      for (Sd = {
        focusedElem: i,
        selectionRange: s
      }, qc = false, Be = r; Be !== null; ) if (r = Be, i = r.child, (r.subtreeFlags & 1024) !== 0 && i !== null) i.return = r, Be = i;
      else for (; Be !== null; ) {
        switch (r = Be, y = r.alternate, i = r.flags, r.tag) {
          case 0:
            break;
          case 11:
          case 15:
            break;
          case 1:
            if ((i & 1024) !== 0 && y !== null) {
              i = void 0, s = r, g = y.memoizedProps, y = y.memoizedState, c = s.stateNode;
              try {
                var Bt = en(s.type, g, s.elementType === s.type);
                i = c.getSnapshotBeforeUpdate(Bt, y), c.__reactInternalSnapshotBeforeUpdate = i;
              } catch (kt) {
                te(s, s.return, kt);
              }
            }
            break;
          case 3:
            if ((i & 1024) !== 0) {
              if (i = r.stateNode.containerInfo, s = i.nodeType, s === 9) Td(i);
              else if (s === 1) switch (i.nodeName) {
                case "HEAD":
                case "HTML":
                case "BODY":
                  Td(i);
                  break;
                default:
                  i.textContent = "";
              }
            }
            break;
          case 5:
          case 26:
          case 27:
          case 6:
          case 4:
          case 17:
            break;
          default:
            if ((i & 1024) !== 0) throw Error(n(163));
        }
        if (i = r.sibling, i !== null) {
          i.return = r.return, Be = i;
          break;
        }
        Be = r.return;
      }
    }
    function By(i, r, s) {
      var c = s.flags;
      switch (s.tag) {
        case 0:
        case 11:
        case 15:
          da(i, s), c & 4 && ms(5, s);
          break;
        case 1:
          if (da(i, s), c & 4) if (i = s.stateNode, r === null) try {
            i.componentDidMount();
          } catch (C) {
            te(s, s.return, C);
          }
          else {
            var g = en(s.type, r.memoizedProps);
            r = r.memoizedState;
            try {
              i.componentDidUpdate(g, r, i.__reactInternalSnapshotBeforeUpdate);
            } catch (C) {
              te(s, s.return, C);
            }
          }
          c & 64 && wy(s), c & 512 && ys(s, s.return);
          break;
        case 3:
          if (da(i, s), c & 64 && (i = s.updateQueue, i !== null)) {
            if (r = null, s.child !== null) switch (s.child.tag) {
              case 27:
              case 5:
                r = s.child.stateNode;
                break;
              case 1:
                r = s.child.stateNode;
            }
            try {
              hm(i, r);
            } catch (C) {
              te(s, s.return, C);
            }
          }
          break;
        case 27:
          r === null && c & 4 && Ey(s);
        case 26:
        case 5:
          da(i, s), r === null && c & 4 && ky(s), c & 512 && ys(s, s.return);
          break;
        case 12:
          da(i, s);
          break;
        case 13:
          da(i, s), c & 4 && Dy(i, s), c & 64 && (i = s.memoizedState, i !== null && (i = i.dehydrated, i !== null && (s = mk.bind(null, s), Rk(i, s))));
          break;
        case 22:
          if (c = s.memoizedState !== null || zr, !c) {
            r = r !== null && r.memoizedState !== null || pe, g = zr;
            var y = pe;
            zr = c, (pe = r) && !y ? pa(i, s, (s.subtreeFlags & 8772) !== 0) : da(i, s), zr = g, pe = y;
          }
          break;
        case 30:
          break;
        default:
          da(i, s);
      }
    }
    function Ly(i) {
      var r = i.alternate;
      r !== null && (i.alternate = null, Ly(r)), i.child = null, i.deletions = null, i.sibling = null, i.tag === 5 && (r = i.stateNode, r !== null && yi(r)), i.stateNode = null, i.return = null, i.dependencies = null, i.memoizedProps = null, i.memoizedState = null, i.pendingProps = null, i.stateNode = null, i.updateQueue = null;
    }
    var ne = null, ui = false;
    function Fr(i, r, s) {
      for (s = s.child; s !== null; ) Oy(i, r, s), s = s.sibling;
    }
    function Oy(i, r, s) {
      if (Ue && typeof Ue.onCommitFiberUnmount == "function") try {
        Ue.onCommitFiberUnmount(Mi, s);
      } catch {
      }
      switch (s.tag) {
        case 26:
          pe || cr(s, r), Fr(i, r, s), s.memoizedState ? s.memoizedState.count-- : s.stateNode && (s = s.stateNode, s.parentNode.removeChild(s));
          break;
        case 27:
          pe || cr(s, r);
          var c = ne, g = ui;
          va(s.type) && (ne = s.stateNode, ui = false), Fr(i, r, s), ks(s.stateNode), ne = c, ui = g;
          break;
        case 5:
          pe || cr(s, r);
        case 6:
          if (c = ne, g = ui, ne = null, Fr(i, r, s), ne = c, ui = g, ne !== null) if (ui) try {
            (ne.nodeType === 9 ? ne.body : ne.nodeName === "HTML" ? ne.ownerDocument.body : ne).removeChild(s.stateNode);
          } catch (y) {
            te(s, r, y);
          }
          else try {
            ne.removeChild(s.stateNode);
          } catch (y) {
            te(s, r, y);
          }
          break;
        case 18:
          ne !== null && (ui ? (i = ne, vb(i.nodeType === 9 ? i.body : i.nodeName === "HTML" ? i.ownerDocument.body : i, s.stateNode), Rs(i)) : vb(ne, s.stateNode));
          break;
        case 4:
          c = ne, g = ui, ne = s.stateNode.containerInfo, ui = true, Fr(i, r, s), ne = c, ui = g;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          pe || fa(2, s, r), pe || fa(4, s, r), Fr(i, r, s);
          break;
        case 1:
          pe || (cr(s, r), c = s.stateNode, typeof c.componentWillUnmount == "function" && Ty(s, r, c)), Fr(i, r, s);
          break;
        case 21:
          Fr(i, r, s);
          break;
        case 22:
          pe = (c = pe) || s.memoizedState !== null, Fr(i, r, s), pe = c;
          break;
        default:
          Fr(i, r, s);
      }
    }
    function Dy(i, r) {
      if (r.memoizedState === null && (i = r.alternate, i !== null && (i = i.memoizedState, i !== null && (i = i.dehydrated, i !== null)))) try {
        Rs(i);
      } catch (s) {
        te(r, r.return, s);
      }
    }
    function ok(i) {
      switch (i.tag) {
        case 13:
        case 19:
          var r = i.stateNode;
          return r === null && (r = i.stateNode = new My()), r;
        case 22:
          return i = i.stateNode, r = i._retryCache, r === null && (r = i._retryCache = new My()), r;
        default:
          throw Error(n(435, i.tag));
      }
    }
    function Kf(i, r) {
      var s = ok(i);
      r.forEach(function(c) {
        var g = yk.bind(null, i, c);
        s.has(c) || (s.add(c), c.then(g, g));
      });
    }
    function _i2(i, r) {
      var s = r.deletions;
      if (s !== null) for (var c = 0; c < s.length; c++) {
        var g = s[c], y = i, C = r, T = C;
        t: for (; T !== null; ) {
          switch (T.tag) {
            case 27:
              if (va(T.type)) {
                ne = T.stateNode, ui = false;
                break t;
              }
              break;
            case 5:
              ne = T.stateNode, ui = false;
              break t;
            case 3:
            case 4:
              ne = T.stateNode.containerInfo, ui = true;
              break t;
          }
          T = T.return;
        }
        if (ne === null) throw Error(n(160));
        Oy(y, C, g), ne = null, ui = false, y = g.alternate, y !== null && (y.return = null), g.return = null;
      }
      if (r.subtreeFlags & 13878) for (r = r.child; r !== null; ) Ry(r, i), r = r.sibling;
    }
    var Vi = null;
    function Ry(i, r) {
      var s = i.alternate, c = i.flags;
      switch (i.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          _i2(r, i), Si(i), c & 4 && (fa(3, i, i.return), ms(3, i), fa(5, i, i.return));
          break;
        case 1:
          _i2(r, i), Si(i), c & 512 && (pe || s === null || cr(s, s.return)), c & 64 && zr && (i = i.updateQueue, i !== null && (c = i.callbacks, c !== null && (s = i.shared.hiddenCallbacks, i.shared.hiddenCallbacks = s === null ? c : s.concat(c))));
          break;
        case 26:
          var g = Vi;
          if (_i2(r, i), Si(i), c & 512 && (pe || s === null || cr(s, s.return)), c & 4) {
            var y = s !== null ? s.memoizedState : null;
            if (c = i.memoizedState, s === null) if (c === null) if (i.stateNode === null) {
              t: {
                c = i.type, s = i.memoizedProps, g = g.ownerDocument || g;
                e: switch (c) {
                  case "title":
                    y = g.getElementsByTagName("title")[0], (!y || y[ia] || y[_e2] || y.namespaceURI === "http://www.w3.org/2000/svg" || y.hasAttribute("itemprop")) && (y = g.createElement(c), g.head.insertBefore(y, g.querySelector("head > title"))), Ne(y, c, s), y[_e2] = i, me(y), c = y;
                    break t;
                  case "link":
                    var C = Eb("link", "href", g).get(c + (s.href || ""));
                    if (C) {
                      for (var T = 0; T < C.length; T++) if (y = C[T], y.getAttribute("href") === (s.href == null || s.href === "" ? null : s.href) && y.getAttribute("rel") === (s.rel == null ? null : s.rel) && y.getAttribute("title") === (s.title == null ? null : s.title) && y.getAttribute("crossorigin") === (s.crossOrigin == null ? null : s.crossOrigin)) {
                        C.splice(T, 1);
                        break e;
                      }
                    }
                    y = g.createElement(c), Ne(y, c, s), g.head.appendChild(y);
                    break;
                  case "meta":
                    if (C = Eb("meta", "content", g).get(c + (s.content || ""))) {
                      for (T = 0; T < C.length; T++) if (y = C[T], y.getAttribute("content") === (s.content == null ? null : "" + s.content) && y.getAttribute("name") === (s.name == null ? null : s.name) && y.getAttribute("property") === (s.property == null ? null : s.property) && y.getAttribute("http-equiv") === (s.httpEquiv == null ? null : s.httpEquiv) && y.getAttribute("charset") === (s.charSet == null ? null : s.charSet)) {
                        C.splice(T, 1);
                        break e;
                      }
                    }
                    y = g.createElement(c), Ne(y, c, s), g.head.appendChild(y);
                    break;
                  default:
                    throw Error(n(468, c));
                }
                y[_e2] = i, me(y), c = y;
              }
              i.stateNode = c;
            } else Mb(g, i.type, i.stateNode);
            else i.stateNode = Ab(g, c, i.memoizedProps);
            else y !== c ? (y === null ? s.stateNode !== null && (s = s.stateNode, s.parentNode.removeChild(s)) : y.count--, c === null ? Mb(g, i.type, i.stateNode) : Ab(g, c, i.memoizedProps)) : c === null && i.stateNode !== null && Xf(i, i.memoizedProps, s.memoizedProps);
          }
          break;
        case 27:
          _i2(r, i), Si(i), c & 512 && (pe || s === null || cr(s, s.return)), s !== null && c & 4 && Xf(i, i.memoizedProps, s.memoizedProps);
          break;
        case 5:
          if (_i2(r, i), Si(i), c & 512 && (pe || s === null || cr(s, s.return)), i.flags & 32) {
            g = i.stateNode;
            try {
              Dn(g, "");
            } catch (P) {
              te(i, i.return, P);
            }
          }
          c & 4 && i.stateNode != null && (g = i.memoizedProps, Xf(i, g, s !== null ? s.memoizedProps : g)), c & 1024 && (Qf = true);
          break;
        case 6:
          if (_i2(r, i), Si(i), c & 4) {
            if (i.stateNode === null) throw Error(n(162));
            c = i.memoizedProps, s = i.stateNode;
            try {
              s.nodeValue = c;
            } catch (P) {
              te(i, i.return, P);
            }
          }
          break;
        case 3:
          if (Nc = null, g = Vi, Vi = Rc(r.containerInfo), _i2(r, i), Vi = g, Si(i), c & 4 && s !== null && s.memoizedState.isDehydrated) try {
            Rs(r.containerInfo);
          } catch (P) {
            te(i, i.return, P);
          }
          Qf && (Qf = false, $y(i));
          break;
        case 4:
          c = Vi, Vi = Rc(i.stateNode.containerInfo), _i2(r, i), Si(i), Vi = c;
          break;
        case 12:
          _i2(r, i), Si(i);
          break;
        case 13:
          _i2(r, i), Si(i), i.child.flags & 8192 && i.memoizedState !== null != (s !== null && s.memoizedState !== null) && (ad = Oe()), c & 4 && (c = i.updateQueue, c !== null && (i.updateQueue = null, Kf(i, c)));
          break;
        case 22:
          g = i.memoizedState !== null;
          var B = s !== null && s.memoizedState !== null, U = zr, Q = pe;
          if (zr = U || g, pe = Q || B, _i2(r, i), pe = Q, zr = U, Si(i), c & 8192) t: for (r = i.stateNode, r._visibility = g ? r._visibility & -2 : r._visibility | 1, g && (s === null || B || zr || pe || rn(i)), s = null, r = i; ; ) {
            if (r.tag === 5 || r.tag === 26) {
              if (s === null) {
                B = s = r;
                try {
                  if (y = B.stateNode, g) C = y.style, typeof C.setProperty == "function" ? C.setProperty("display", "none", "important") : C.display = "none";
                  else {
                    T = B.stateNode;
                    var tt = B.memoizedProps.style, I = tt != null && tt.hasOwnProperty("display") ? tt.display : null;
                    T.style.display = I == null || typeof I == "boolean" ? "" : ("" + I).trim();
                  }
                } catch (P) {
                  te(B, B.return, P);
                }
              }
            } else if (r.tag === 6) {
              if (s === null) {
                B = r;
                try {
                  B.stateNode.nodeValue = g ? "" : B.memoizedProps;
                } catch (P) {
                  te(B, B.return, P);
                }
              }
            } else if ((r.tag !== 22 && r.tag !== 23 || r.memoizedState === null || r === i) && r.child !== null) {
              r.child.return = r, r = r.child;
              continue;
            }
            if (r === i) break t;
            for (; r.sibling === null; ) {
              if (r.return === null || r.return === i) break t;
              s === r && (s = null), r = r.return;
            }
            s === r && (s = null), r.sibling.return = r.return, r = r.sibling;
          }
          c & 4 && (c = i.updateQueue, c !== null && (s = c.retryQueue, s !== null && (c.retryQueue = null, Kf(i, s))));
          break;
        case 19:
          _i2(r, i), Si(i), c & 4 && (c = i.updateQueue, c !== null && (i.updateQueue = null, Kf(i, c)));
          break;
        case 30:
          break;
        case 21:
          break;
        default:
          _i2(r, i), Si(i);
      }
    }
    function Si(i) {
      var r = i.flags;
      if (r & 2) {
        try {
          for (var s, c = i.return; c !== null; ) {
            if (Ay(c)) {
              s = c;
              break;
            }
            c = c.return;
          }
          if (s == null) throw Error(n(160));
          switch (s.tag) {
            case 27:
              var g = s.stateNode, y = Vf(i);
              _c2(i, y, g);
              break;
            case 5:
              var C = s.stateNode;
              s.flags & 32 && (Dn(C, ""), s.flags &= -33);
              var T = Vf(i);
              _c2(i, T, C);
              break;
            case 3:
            case 4:
              var B = s.stateNode.containerInfo, U = Vf(i);
              Zf(i, U, B);
              break;
            default:
              throw Error(n(161));
          }
        } catch (Q) {
          te(i, i.return, Q);
        }
        i.flags &= -3;
      }
      r & 4096 && (i.flags &= -4097);
    }
    function $y(i) {
      if (i.subtreeFlags & 1024) for (i = i.child; i !== null; ) {
        var r = i;
        $y(r), r.tag === 5 && r.flags & 1024 && r.stateNode.reset(), i = i.sibling;
      }
    }
    function da(i, r) {
      if (r.subtreeFlags & 8772) for (r = r.child; r !== null; ) By(i, r.alternate, r), r = r.sibling;
    }
    function rn(i) {
      for (i = i.child; i !== null; ) {
        var r = i;
        switch (r.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            fa(4, r, r.return), rn(r);
            break;
          case 1:
            cr(r, r.return);
            var s = r.stateNode;
            typeof s.componentWillUnmount == "function" && Ty(r, r.return, s), rn(r);
            break;
          case 27:
            ks(r.stateNode);
          case 26:
          case 5:
            cr(r, r.return), rn(r);
            break;
          case 22:
            r.memoizedState === null && rn(r);
            break;
          case 30:
            rn(r);
            break;
          default:
            rn(r);
        }
        i = i.sibling;
      }
    }
    function pa(i, r, s) {
      for (s = s && (r.subtreeFlags & 8772) !== 0, r = r.child; r !== null; ) {
        var c = r.alternate, g = i, y = r, C = y.flags;
        switch (y.tag) {
          case 0:
          case 11:
          case 15:
            pa(g, y, s), ms(4, y);
            break;
          case 1:
            if (pa(g, y, s), c = y, g = c.stateNode, typeof g.componentDidMount == "function") try {
              g.componentDidMount();
            } catch (U) {
              te(c, c.return, U);
            }
            if (c = y, g = c.updateQueue, g !== null) {
              var T = c.stateNode;
              try {
                var B = g.shared.hiddenCallbacks;
                if (B !== null) for (g.shared.hiddenCallbacks = null, g = 0; g < B.length; g++) um(B[g], T);
              } catch (U) {
                te(c, c.return, U);
              }
            }
            s && C & 64 && wy(y), ys(y, y.return);
            break;
          case 27:
            Ey(y);
          case 26:
          case 5:
            pa(g, y, s), s && c === null && C & 4 && ky(y), ys(y, y.return);
            break;
          case 12:
            pa(g, y, s);
            break;
          case 13:
            pa(g, y, s), s && C & 4 && Dy(g, y);
            break;
          case 22:
            y.memoizedState === null && pa(g, y, s), ys(y, y.return);
            break;
          case 30:
            break;
          default:
            pa(g, y, s);
        }
        r = r.sibling;
      }
    }
    function Jf(i, r) {
      var s = null;
      i !== null && i.memoizedState !== null && i.memoizedState.cachePool !== null && (s = i.memoizedState.cachePool.pool), i = null, r.memoizedState !== null && r.memoizedState.cachePool !== null && (i = r.memoizedState.cachePool.pool), i !== s && (i != null && i.refCount++, s != null && is(s));
    }
    function td(i, r) {
      i = null, r.alternate !== null && (i = r.alternate.memoizedState.cache), r = r.memoizedState.cache, r !== i && (r.refCount++, i != null && is(i));
    }
    function ur(i, r, s, c) {
      if (r.subtreeFlags & 10256) for (r = r.child; r !== null; ) Ny(i, r, s, c), r = r.sibling;
    }
    function Ny(i, r, s, c) {
      var g = r.flags;
      switch (r.tag) {
        case 0:
        case 11:
        case 15:
          ur(i, r, s, c), g & 2048 && ms(9, r);
          break;
        case 1:
          ur(i, r, s, c);
          break;
        case 3:
          ur(i, r, s, c), g & 2048 && (i = null, r.alternate !== null && (i = r.alternate.memoizedState.cache), r = r.memoizedState.cache, r !== i && (r.refCount++, i != null && is(i)));
          break;
        case 12:
          if (g & 2048) {
            ur(i, r, s, c), i = r.stateNode;
            try {
              var y = r.memoizedProps, C = y.id, T = y.onPostCommit;
              typeof T == "function" && T(C, r.alternate === null ? "mount" : "update", i.passiveEffectDuration, -0);
            } catch (B) {
              te(r, r.return, B);
            }
          } else ur(i, r, s, c);
          break;
        case 13:
          ur(i, r, s, c);
          break;
        case 23:
          break;
        case 22:
          y = r.stateNode, C = r.alternate, r.memoizedState !== null ? y._visibility & 2 ? ur(i, r, s, c) : bs(i, r) : y._visibility & 2 ? ur(i, r, s, c) : (y._visibility |= 2, Kn(i, r, s, c, (r.subtreeFlags & 10256) !== 0)), g & 2048 && Jf(C, r);
          break;
        case 24:
          ur(i, r, s, c), g & 2048 && td(r.alternate, r);
          break;
        default:
          ur(i, r, s, c);
      }
    }
    function Kn(i, r, s, c, g) {
      for (g = g && (r.subtreeFlags & 10256) !== 0, r = r.child; r !== null; ) {
        var y = i, C = r, T = s, B = c, U = C.flags;
        switch (C.tag) {
          case 0:
          case 11:
          case 15:
            Kn(y, C, T, B, g), ms(8, C);
            break;
          case 23:
            break;
          case 22:
            var Q = C.stateNode;
            C.memoizedState !== null ? Q._visibility & 2 ? Kn(y, C, T, B, g) : bs(y, C) : (Q._visibility |= 2, Kn(y, C, T, B, g)), g && U & 2048 && Jf(C.alternate, C);
            break;
          case 24:
            Kn(y, C, T, B, g), g && U & 2048 && td(C.alternate, C);
            break;
          default:
            Kn(y, C, T, B, g);
        }
        r = r.sibling;
      }
    }
    function bs(i, r) {
      if (r.subtreeFlags & 10256) for (r = r.child; r !== null; ) {
        var s = i, c = r, g = c.flags;
        switch (c.tag) {
          case 22:
            bs(s, c), g & 2048 && Jf(c.alternate, c);
            break;
          case 24:
            bs(s, c), g & 2048 && td(c.alternate, c);
            break;
          default:
            bs(s, c);
        }
        r = r.sibling;
      }
    }
    var xs = 8192;
    function Jn(i) {
      if (i.subtreeFlags & xs) for (i = i.child; i !== null; ) zy(i), i = i.sibling;
    }
    function zy(i) {
      switch (i.tag) {
        case 26:
          Jn(i), i.flags & xs && i.memoizedState !== null && Wk(Vi, i.memoizedState, i.memoizedProps);
          break;
        case 5:
          Jn(i);
          break;
        case 3:
        case 4:
          var r = Vi;
          Vi = Rc(i.stateNode.containerInfo), Jn(i), Vi = r;
          break;
        case 22:
          i.memoizedState === null && (r = i.alternate, r !== null && r.memoizedState !== null ? (r = xs, xs = 16777216, Jn(i), xs = r) : Jn(i));
          break;
        default:
          Jn(i);
      }
    }
    function Fy(i) {
      var r = i.alternate;
      if (r !== null && (i = r.child, i !== null)) {
        r.child = null;
        do
          r = i.sibling, i.sibling = null, i = r;
        while (i !== null);
      }
    }
    function vs(i) {
      var r = i.deletions;
      if ((i.flags & 16) !== 0) {
        if (r !== null) for (var s = 0; s < r.length; s++) {
          var c = r[s];
          Be = c, Hy(c, i);
        }
        Fy(i);
      }
      if (i.subtreeFlags & 10256) for (i = i.child; i !== null; ) qy(i), i = i.sibling;
    }
    function qy(i) {
      switch (i.tag) {
        case 0:
        case 11:
        case 15:
          vs(i), i.flags & 2048 && fa(9, i, i.return);
          break;
        case 3:
          vs(i);
          break;
        case 12:
          vs(i);
          break;
        case 22:
          var r = i.stateNode;
          i.memoizedState !== null && r._visibility & 2 && (i.return === null || i.return.tag !== 13) ? (r._visibility &= -3, Sc(i)) : vs(i);
          break;
        default:
          vs(i);
      }
    }
    function Sc(i) {
      var r = i.deletions;
      if ((i.flags & 16) !== 0) {
        if (r !== null) for (var s = 0; s < r.length; s++) {
          var c = r[s];
          Be = c, Hy(c, i);
        }
        Fy(i);
      }
      for (i = i.child; i !== null; ) {
        switch (r = i, r.tag) {
          case 0:
          case 11:
          case 15:
            fa(8, r, r.return), Sc(r);
            break;
          case 22:
            s = r.stateNode, s._visibility & 2 && (s._visibility &= -3, Sc(r));
            break;
          default:
            Sc(r);
        }
        i = i.sibling;
      }
    }
    function Hy(i, r) {
      for (; Be !== null; ) {
        var s = Be;
        switch (s.tag) {
          case 0:
          case 11:
          case 15:
            fa(8, s, r);
            break;
          case 23:
          case 22:
            if (s.memoizedState !== null && s.memoizedState.cachePool !== null) {
              var c = s.memoizedState.cachePool.pool;
              c != null && c.refCount++;
            }
            break;
          case 24:
            is(s.memoizedState.cache);
        }
        if (c = s.child, c !== null) c.return = s, Be = c;
        else t: for (s = i; Be !== null; ) {
          c = Be;
          var g = c.sibling, y = c.return;
          if (Ly(c), c === s) {
            Be = null;
            break t;
          }
          if (g !== null) {
            g.return = y, Be = g;
            break t;
          }
          Be = y;
        }
      }
    }
    var ck = {
      getCacheForType: function(i) {
        var r = Pe(Ce), s = r.data.get(i);
        return s === void 0 && (s = i(), r.data.set(i, s)), s;
      }
    }, uk = typeof WeakMap == "function" ? WeakMap : Map, Vt = 0, ie = null, $t = null, Ut = 0, Zt = 0, Ci = null, ga = false, tl = false, ed = false, qr = 0, ue = 0, ma = 0, an = 0, id = 0, zi = 0, el = 0, _s = null, hi = null, rd = false, ad = 0, Cc = 1 / 0, wc = null, ya = null, $e = 0, ba = null, il = null, rl = 0, nd = 0, ld = null, Uy = null, Ss = 0, sd = null;
    function wi() {
      if ((Vt & 2) !== 0 && Ut !== 0) return Ut & -Ut;
      if (E.T !== null) {
        var i = In;
        return i !== 0 ? i : pd();
      }
      return Hl();
    }
    function jy() {
      zi === 0 && (zi = (Ut & 536870912) === 0 || It ? Ua() : 536870912);
      var i = Ni.current;
      return i !== null && (i.flags |= 32), zi;
    }
    function Ti(i, r, s) {
      (i === ie && (Zt === 2 || Zt === 9) || i.cancelPendingCommit !== null) && (al(i, 0), xa(i, Ut, zi, false)), Gi(i, s), ((Vt & 2) === 0 || i !== ie) && (i === ie && ((Vt & 2) === 0 && (an |= s), ue === 4 && xa(i, Ut, zi, false)), hr(i));
    }
    function Yy(i, r, s) {
      if ((Vt & 6) !== 0) throw Error(n(327));
      var c = !s && (r & 124) === 0 && (r & i.expiredLanes) === 0 || Sr(i, r), g = c ? dk(i, r) : ud(i, r, true), y = c;
      do {
        if (g === 0) {
          tl && !c && xa(i, r, 0, false);
          break;
        } else {
          if (s = i.current.alternate, y && !hk(s)) {
            g = ud(i, r, false), y = false;
            continue;
          }
          if (g === 2) {
            if (y = r, i.errorRecoveryDisabledLanes & y) var C = 0;
            else C = i.pendingLanes & -536870913, C = C !== 0 ? C : C & 536870912 ? 536870912 : 0;
            if (C !== 0) {
              r = C;
              t: {
                var T = i;
                g = _s;
                var B = T.current.memoizedState.isDehydrated;
                if (B && (al(T, C).flags |= 256), C = ud(T, C, false), C !== 2) {
                  if (ed && !B) {
                    T.errorRecoveryDisabledLanes |= y, an |= y, g = 4;
                    break t;
                  }
                  y = hi, hi = g, y !== null && (hi === null ? hi = y : hi.push.apply(hi, y));
                }
                g = C;
              }
              if (y = false, g !== 2) continue;
            }
          }
          if (g === 1) {
            al(i, 0), xa(i, r, 0, true);
            break;
          }
          t: {
            switch (c = i, y = g, y) {
              case 0:
              case 1:
                throw Error(n(345));
              case 4:
                if ((r & 4194048) !== r) break;
              case 6:
                xa(c, r, zi, !ga);
                break t;
              case 2:
                hi = null;
                break;
              case 3:
              case 5:
                break;
              default:
                throw Error(n(329));
            }
            if ((r & 62914560) === r && (g = ad + 300 - Oe(), 10 < g)) {
              if (xa(c, r, zi, !ga), ea(c, 0, true) !== 0) break t;
              c.timeoutHandle = bb(Iy.bind(null, c, s, hi, wc, rd, r, zi, an, el, ga, y, 2, -0, 0), g);
              break t;
            }
            Iy(c, s, hi, wc, rd, r, zi, an, el, ga, y, 0, -0, 0);
          }
        }
        break;
      } while (true);
      hr(i);
    }
    function Iy(i, r, s, c, g, y, C, T, B, U, Q, tt, I, P) {
      if (i.timeoutHandle = -1, tt = r.subtreeFlags, (tt & 8192 || (tt & 16785408) === 16785408) && (Ms = {
        stylesheets: null,
        count: 0,
        unsuspend: Gk
      }, zy(r), tt = Xk(), tt !== null)) {
        i.cancelPendingCommit = tt(Qy.bind(null, i, r, y, s, c, g, C, T, B, Q, 1, I, P)), xa(i, y, C, !U);
        return;
      }
      Qy(i, r, y, s, c, g, C, T, B);
    }
    function hk(i) {
      for (var r = i; ; ) {
        var s = r.tag;
        if ((s === 0 || s === 11 || s === 15) && r.flags & 16384 && (s = r.updateQueue, s !== null && (s = s.stores, s !== null))) for (var c = 0; c < s.length; c++) {
          var g = s[c], y = g.getSnapshot;
          g = g.value;
          try {
            if (!xi(y(), g)) return false;
          } catch {
            return false;
          }
        }
        if (s = r.child, r.subtreeFlags & 16384 && s !== null) s.return = r, r = s;
        else {
          if (r === i) break;
          for (; r.sibling === null; ) {
            if (r.return === null || r.return === i) return true;
            r = r.return;
          }
          r.sibling.return = r.return, r = r.sibling;
        }
      }
      return true;
    }
    function xa(i, r, s, c) {
      r &= ~id, r &= ~an, i.suspendedLanes |= r, i.pingedLanes &= ~r, c && (i.warmLanes |= r), c = i.expirationTimes;
      for (var g = r; 0 < g; ) {
        var y = 31 - je(g), C = 1 << y;
        c[y] = -1, g &= ~C;
      }
      s !== 0 && $o(i, s, r);
    }
    function Tc() {
      return (Vt & 6) === 0 ? (Cs(0), false) : true;
    }
    function od() {
      if ($t !== null) {
        if (Zt === 0) var i = $t.return;
        else i = $t, Lr = Qa = null, Tf(i), Zn = null, ds = 0, i = $t;
        for (; i !== null; ) Cy(i.alternate, i), i = i.return;
        $t = null;
      }
    }
    function al(i, r) {
      var s = i.timeoutHandle;
      s !== -1 && (i.timeoutHandle = -1, Mk(s)), s = i.cancelPendingCommit, s !== null && (i.cancelPendingCommit = null, s()), od(), ie = i, $t = s = Er(i.current, null), Ut = r, Zt = 0, Ci = null, ga = false, tl = Sr(i, r), ed = false, el = zi = id = an = ma = ue = 0, hi = _s = null, rd = false, (r & 8) !== 0 && (r |= r & 32);
      var c = i.entangledLanes;
      if (c !== 0) for (i = i.entanglements, c &= r; 0 < c; ) {
        var g = 31 - je(c), y = 1 << g;
        r |= i[g], c &= ~y;
      }
      return qr = r, Wo(), s;
    }
    function Py(i, r) {
      Dt = null, E.H = fc, r === as || r === ic ? (r = om(), Zt = 3) : r === nm ? (r = om(), Zt = 4) : Zt = r === cy ? 8 : r !== null && typeof r == "object" && typeof r.then == "function" ? 6 : 1, Ci = r, $t === null && (ue = 1, yc(i, Oi(r, i.current)));
    }
    function Gy() {
      var i = E.H;
      return E.H = fc, i === null ? fc : i;
    }
    function Wy() {
      var i = E.A;
      return E.A = ck, i;
    }
    function cd() {
      ue = 4, ga || (Ut & 4194048) !== Ut && Ni.current !== null || (tl = true), (ma & 134217727) === 0 && (an & 134217727) === 0 || ie === null || xa(ie, Ut, zi, false);
    }
    function ud(i, r, s) {
      var c = Vt;
      Vt |= 2;
      var g = Gy(), y = Wy();
      (ie !== i || Ut !== r) && (wc = null, al(i, r)), r = false;
      var C = ue;
      t: do
        try {
          if (Zt !== 0 && $t !== null) {
            var T = $t, B = Ci;
            switch (Zt) {
              case 8:
                od(), C = 6;
                break t;
              case 3:
              case 2:
              case 9:
              case 6:
                Ni.current === null && (r = true);
                var U = Zt;
                if (Zt = 0, Ci = null, nl(i, T, B, U), s && tl) {
                  C = 0;
                  break t;
                }
                break;
              default:
                U = Zt, Zt = 0, Ci = null, nl(i, T, B, U);
            }
          }
          fk(), C = ue;
          break;
        } catch (Q) {
          Py(i, Q);
        }
      while (true);
      return r && i.shellSuspendCounter++, Lr = Qa = null, Vt = c, E.H = g, E.A = y, $t === null && (ie = null, Ut = 0, Wo()), C;
    }
    function fk() {
      for (; $t !== null; ) Xy($t);
    }
    function dk(i, r) {
      var s = Vt;
      Vt |= 2;
      var c = Gy(), g = Wy();
      ie !== i || Ut !== r ? (wc = null, Cc = Oe() + 500, al(i, r)) : tl = Sr(i, r);
      t: do
        try {
          if (Zt !== 0 && $t !== null) {
            r = $t;
            var y = Ci;
            e: switch (Zt) {
              case 1:
                Zt = 0, Ci = null, nl(i, r, y, 1);
                break;
              case 2:
              case 9:
                if (lm(y)) {
                  Zt = 0, Ci = null, Vy(r);
                  break;
                }
                r = function() {
                  Zt !== 2 && Zt !== 9 || ie !== i || (Zt = 7), hr(i);
                }, y.then(r, r);
                break t;
              case 3:
                Zt = 7;
                break t;
              case 4:
                Zt = 5;
                break t;
              case 7:
                lm(y) ? (Zt = 0, Ci = null, Vy(r)) : (Zt = 0, Ci = null, nl(i, r, y, 7));
                break;
              case 5:
                var C = null;
                switch ($t.tag) {
                  case 26:
                    C = $t.memoizedState;
                  case 5:
                  case 27:
                    var T = $t;
                    if (!C || Bb(C)) {
                      Zt = 0, Ci = null;
                      var B = T.sibling;
                      if (B !== null) $t = B;
                      else {
                        var U = T.return;
                        U !== null ? ($t = U, kc(U)) : $t = null;
                      }
                      break e;
                    }
                }
                Zt = 0, Ci = null, nl(i, r, y, 5);
                break;
              case 6:
                Zt = 0, Ci = null, nl(i, r, y, 6);
                break;
              case 8:
                od(), ue = 6;
                break t;
              default:
                throw Error(n(462));
            }
          }
          pk();
          break;
        } catch (Q) {
          Py(i, Q);
        }
      while (true);
      return Lr = Qa = null, E.H = c, E.A = g, Vt = s, $t !== null ? 0 : (ie = null, Ut = 0, Wo(), ue);
    }
    function pk() {
      for (; $t !== null && !Rl(); ) Xy($t);
    }
    function Xy(i) {
      var r = _y(i.alternate, i, qr);
      i.memoizedProps = i.pendingProps, r === null ? kc(i) : $t = r;
    }
    function Vy(i) {
      var r = i, s = r.alternate;
      switch (r.tag) {
        case 15:
        case 0:
          r = gy(s, r, r.pendingProps, r.type, void 0, Ut);
          break;
        case 11:
          r = gy(s, r, r.pendingProps, r.type.render, r.ref, Ut);
          break;
        case 5:
          Tf(r);
        default:
          Cy(s, r), r = $t = Z0(r, qr), r = _y(s, r, qr);
      }
      i.memoizedProps = i.pendingProps, r === null ? kc(i) : $t = r;
    }
    function nl(i, r, s, c) {
      Lr = Qa = null, Tf(r), Zn = null, ds = 0;
      var g = r.return;
      try {
        if (rk(i, g, r, s, Ut)) {
          ue = 1, yc(i, Oi(s, i.current)), $t = null;
          return;
        }
      } catch (y) {
        if (g !== null) throw $t = g, y;
        ue = 1, yc(i, Oi(s, i.current)), $t = null;
        return;
      }
      r.flags & 32768 ? (It || c === 1 ? i = true : tl || (Ut & 536870912) !== 0 ? i = false : (ga = i = true, (c === 2 || c === 9 || c === 3 || c === 6) && (c = Ni.current, c !== null && c.tag === 13 && (c.flags |= 16384))), Zy(r, i)) : kc(r);
    }
    function kc(i) {
      var r = i;
      do {
        if ((r.flags & 32768) !== 0) {
          Zy(r, ga);
          return;
        }
        i = r.return;
        var s = nk(r.alternate, r, qr);
        if (s !== null) {
          $t = s;
          return;
        }
        if (r = r.sibling, r !== null) {
          $t = r;
          return;
        }
        $t = r = i;
      } while (r !== null);
      ue === 0 && (ue = 5);
    }
    function Zy(i, r) {
      do {
        var s = lk(i.alternate, i);
        if (s !== null) {
          s.flags &= 32767, $t = s;
          return;
        }
        if (s = i.return, s !== null && (s.flags |= 32768, s.subtreeFlags = 0, s.deletions = null), !r && (i = i.sibling, i !== null)) {
          $t = i;
          return;
        }
        $t = i = s;
      } while (i !== null);
      ue = 6, $t = null;
    }
    function Qy(i, r, s, c, g, y, C, T, B) {
      i.cancelPendingCommit = null;
      do
        Ac();
      while ($e !== 0);
      if ((Vt & 6) !== 0) throw Error(n(327));
      if (r !== null) {
        if (r === i.current) throw Error(n(177));
        if (y = r.lanes | r.childLanes, y |= Jh, Bh(i, s, y, C, T, B), i === ie && ($t = ie = null, Ut = 0), il = r, ba = i, rl = s, nd = y, ld = g, Uy = c, (r.subtreeFlags & 10256) !== 0 || (r.flags & 10256) !== 0 ? (i.callbackNode = null, i.callbackPriority = 0, bk(qa, function() {
          return ib(), null;
        })) : (i.callbackNode = null, i.callbackPriority = 0), c = (r.flags & 13878) !== 0, (r.subtreeFlags & 13878) !== 0 || c) {
          c = E.T, E.T = null, g = N.p, N.p = 2, C = Vt, Vt |= 4;
          try {
            sk(i, r, s);
          } finally {
            Vt = C, N.p = g, E.T = c;
          }
        }
        $e = 1, Ky(), Jy(), tb();
      }
    }
    function Ky() {
      if ($e === 1) {
        $e = 0;
        var i = ba, r = il, s = (r.flags & 13878) !== 0;
        if ((r.subtreeFlags & 13878) !== 0 || s) {
          s = E.T, E.T = null;
          var c = N.p;
          N.p = 2;
          var g = Vt;
          Vt |= 4;
          try {
            Ry(r, i);
            var y = Sd, C = H0(i.containerInfo), T = y.focusedElem, B = y.selectionRange;
            if (C !== T && T && T.ownerDocument && q0(T.ownerDocument.documentElement, T)) {
              if (B !== null && Xh(T)) {
                var U = B.start, Q = B.end;
                if (Q === void 0 && (Q = U), "selectionStart" in T) T.selectionStart = U, T.selectionEnd = Math.min(Q, T.value.length);
                else {
                  var tt = T.ownerDocument || document, I = tt && tt.defaultView || window;
                  if (I.getSelection) {
                    var P = I.getSelection(), Bt = T.textContent.length, kt = Math.min(B.start, Bt), Jt = B.end === void 0 ? kt : Math.min(B.end, Bt);
                    !P.extend && kt > Jt && (C = Jt, Jt = kt, kt = C);
                    var z = F0(T, kt), D = F0(T, Jt);
                    if (z && D && (P.rangeCount !== 1 || P.anchorNode !== z.node || P.anchorOffset !== z.offset || P.focusNode !== D.node || P.focusOffset !== D.offset)) {
                      var H = tt.createRange();
                      H.setStart(z.node, z.offset), P.removeAllRanges(), kt > Jt ? (P.addRange(H), P.extend(D.node, D.offset)) : (H.setEnd(D.node, D.offset), P.addRange(H));
                    }
                  }
                }
              }
              for (tt = [], P = T; P = P.parentNode; ) P.nodeType === 1 && tt.push({
                element: P,
                left: P.scrollLeft,
                top: P.scrollTop
              });
              for (typeof T.focus == "function" && T.focus(), T = 0; T < tt.length; T++) {
                var J = tt[T];
                J.element.scrollLeft = J.left, J.element.scrollTop = J.top;
              }
            }
            qc = !!_d2, Sd = _d2 = null;
          } finally {
            Vt = g, N.p = c, E.T = s;
          }
        }
        i.current = r, $e = 2;
      }
    }
    function Jy() {
      if ($e === 2) {
        $e = 0;
        var i = ba, r = il, s = (r.flags & 8772) !== 0;
        if ((r.subtreeFlags & 8772) !== 0 || s) {
          s = E.T, E.T = null;
          var c = N.p;
          N.p = 2;
          var g = Vt;
          Vt |= 4;
          try {
            By(i, r.alternate, r);
          } finally {
            Vt = g, N.p = c, E.T = s;
          }
        }
        $e = 3;
      }
    }
    function tb() {
      if ($e === 4 || $e === 3) {
        $e = 0, $l();
        var i = ba, r = il, s = rl, c = Uy;
        (r.subtreeFlags & 10256) !== 0 || (r.flags & 10256) !== 0 ? $e = 5 : ($e = 0, il = ba = null, eb(i, i.pendingLanes));
        var g = i.pendingLanes;
        if (g === 0 && (ya = null), ql(s), r = r.stateNode, Ue && typeof Ue.onCommitFiberRoot == "function") try {
          Ue.onCommitFiberRoot(Mi, r, void 0, (r.current.flags & 128) === 128);
        } catch {
        }
        if (c !== null) {
          r = E.T, g = N.p, N.p = 2, E.T = null;
          try {
            for (var y = i.onRecoverableError, C = 0; C < c.length; C++) {
              var T = c[C];
              y(T.value, {
                componentStack: T.stack
              });
            }
          } finally {
            E.T = r, N.p = g;
          }
        }
        (rl & 3) !== 0 && Ac(), hr(i), g = i.pendingLanes, (s & 4194090) !== 0 && (g & 42) !== 0 ? i === sd ? Ss++ : (Ss = 0, sd = i) : Ss = 0, Cs(0);
      }
    }
    function eb(i, r) {
      (i.pooledCacheLanes &= r) === 0 && (r = i.pooledCache, r != null && (i.pooledCache = null, is(r)));
    }
    function Ac(i) {
      return Ky(), Jy(), tb(), ib();
    }
    function ib() {
      if ($e !== 5) return false;
      var i = ba, r = nd;
      nd = 0;
      var s = ql(rl), c = E.T, g = N.p;
      try {
        N.p = 32 > s ? 32 : s, E.T = null, s = ld, ld = null;
        var y = ba, C = rl;
        if ($e = 0, il = ba = null, rl = 0, (Vt & 6) !== 0) throw Error(n(331));
        var T = Vt;
        if (Vt |= 4, qy(y.current), Ny(y, y.current, C, s), Vt = T, Cs(0, false), Ue && typeof Ue.onPostCommitFiberRoot == "function") try {
          Ue.onPostCommitFiberRoot(Mi, y);
        } catch {
        }
        return true;
      } finally {
        N.p = g, E.T = c, eb(i, r);
      }
    }
    function rb(i, r, s) {
      r = Oi(s, r), r = qf(i.stateNode, r, 2), i = oa(i, r, 2), i !== null && (Gi(i, 2), hr(i));
    }
    function te(i, r, s) {
      if (i.tag === 3) rb(i, i, s);
      else for (; r !== null; ) {
        if (r.tag === 3) {
          rb(r, i, s);
          break;
        } else if (r.tag === 1) {
          var c = r.stateNode;
          if (typeof r.type.getDerivedStateFromError == "function" || typeof c.componentDidCatch == "function" && (ya === null || !ya.has(c))) {
            i = Oi(s, i), s = sy(2), c = oa(r, s, 2), c !== null && (oy(s, c, r, i), Gi(c, 2), hr(c));
            break;
          }
        }
        r = r.return;
      }
    }
    function hd(i, r, s) {
      var c = i.pingCache;
      if (c === null) {
        c = i.pingCache = new uk();
        var g = /* @__PURE__ */ new Set();
        c.set(r, g);
      } else g = c.get(r), g === void 0 && (g = /* @__PURE__ */ new Set(), c.set(r, g));
      g.has(s) || (ed = true, g.add(s), i = gk.bind(null, i, r, s), r.then(i, i));
    }
    function gk(i, r, s) {
      var c = i.pingCache;
      c !== null && c.delete(r), i.pingedLanes |= i.suspendedLanes & s, i.warmLanes &= ~s, ie === i && (Ut & s) === s && (ue === 4 || ue === 3 && (Ut & 62914560) === Ut && 300 > Oe() - ad ? (Vt & 2) === 0 && al(i, 0) : id |= s, el === Ut && (el = 0)), hr(i);
    }
    function ab(i, r) {
      r === 0 && (r = ja()), i = Hn(i, r), i !== null && (Gi(i, r), hr(i));
    }
    function mk(i) {
      var r = i.memoizedState, s = 0;
      r !== null && (s = r.retryLane), ab(i, s);
    }
    function yk(i, r) {
      var s = 0;
      switch (i.tag) {
        case 13:
          var c = i.stateNode, g = i.memoizedState;
          g !== null && (s = g.retryLane);
          break;
        case 19:
          c = i.stateNode;
          break;
        case 22:
          c = i.stateNode._retryCache;
          break;
        default:
          throw Error(n(314));
      }
      c !== null && c.delete(r), ab(i, s);
    }
    function bk(i, r) {
      return mi(i, r);
    }
    var Ec = null, ll = null, fd = false, Mc = false, dd = false, nn = 0;
    function hr(i) {
      i !== ll && i.next === null && (ll === null ? Ec = ll = i : ll = ll.next = i), Mc = true, fd || (fd = true, vk());
    }
    function Cs(i, r) {
      if (!dd && Mc) {
        dd = true;
        do
          for (var s = false, c = Ec; c !== null; ) {
            if (i !== 0) {
              var g = c.pendingLanes;
              if (g === 0) var y = 0;
              else {
                var C = c.suspendedLanes, T = c.pingedLanes;
                y = (1 << 31 - je(42 | i) + 1) - 1, y &= g & ~(C & ~T), y = y & 201326741 ? y & 201326741 | 1 : y ? y | 2 : 0;
              }
              y !== 0 && (s = true, ob(c, y));
            } else y = Ut, y = ea(c, c === ie ? y : 0, c.cancelPendingCommit !== null || c.timeoutHandle !== -1), (y & 3) === 0 || Sr(c, y) || (s = true, ob(c, y));
            c = c.next;
          }
        while (s);
        dd = false;
      }
    }
    function xk() {
      nb();
    }
    function nb() {
      Mc = fd = false;
      var i = 0;
      nn !== 0 && (Ek() && (i = nn), nn = 0);
      for (var r = Oe(), s = null, c = Ec; c !== null; ) {
        var g = c.next, y = lb(c, r);
        y === 0 ? (c.next = null, s === null ? Ec = g : s.next = g, g === null && (ll = s)) : (s = c, (i !== 0 || (y & 3) !== 0) && (Mc = true)), c = g;
      }
      Cs(i);
    }
    function lb(i, r) {
      for (var s = i.suspendedLanes, c = i.pingedLanes, g = i.expirationTimes, y = i.pendingLanes & -62914561; 0 < y; ) {
        var C = 31 - je(y), T = 1 << C, B = g[C];
        B === -1 ? ((T & s) === 0 || (T & c) !== 0) && (g[C] = Mh(T, r)) : B <= r && (i.expiredLanes |= T), y &= ~T;
      }
      if (r = ie, s = Ut, s = ea(i, i === r ? s : 0, i.cancelPendingCommit !== null || i.timeoutHandle !== -1), c = i.callbackNode, s === 0 || i === r && (Zt === 2 || Zt === 9) || i.cancelPendingCommit !== null) return c !== null && c !== null && Ii(c), i.callbackNode = null, i.callbackPriority = 0;
      if ((s & 3) === 0 || Sr(i, s)) {
        if (r = s & -s, r === i.callbackPriority) return r;
        switch (c !== null && Ii(c), ql(s)) {
          case 2:
          case 8:
            s = Nl;
            break;
          case 32:
            s = qa;
            break;
          case 268435456:
            s = Mn;
            break;
          default:
            s = qa;
        }
        return c = sb.bind(null, i), s = mi(s, c), i.callbackPriority = r, i.callbackNode = s, r;
      }
      return c !== null && c !== null && Ii(c), i.callbackPriority = 2, i.callbackNode = null, 2;
    }
    function sb(i, r) {
      if ($e !== 0 && $e !== 5) return i.callbackNode = null, i.callbackPriority = 0, null;
      var s = i.callbackNode;
      if (Ac() && i.callbackNode !== s) return null;
      var c = Ut;
      return c = ea(i, i === ie ? c : 0, i.cancelPendingCommit !== null || i.timeoutHandle !== -1), c === 0 ? null : (Yy(i, c, r), lb(i, Oe()), i.callbackNode != null && i.callbackNode === s ? sb.bind(null, i) : null);
    }
    function ob(i, r) {
      if (Ac()) return null;
      Yy(i, r, true);
    }
    function vk() {
      Bk(function() {
        (Vt & 6) !== 0 ? mi(Fa, xk) : nb();
      });
    }
    function pd() {
      return nn === 0 && (nn = Ua()), nn;
    }
    function cb(i) {
      return i == null || typeof i == "symbol" || typeof i == "boolean" ? null : typeof i == "function" ? i : Ho("" + i);
    }
    function ub(i, r) {
      var s = r.ownerDocument.createElement("input");
      return s.name = r.name, s.value = r.value, i.id && s.setAttribute("form", i.id), r.parentNode.insertBefore(s, r), i = new FormData(i), s.parentNode.removeChild(s), i;
    }
    function _k(i, r, s, c, g) {
      if (r === "submit" && s && s.stateNode === g) {
        var y = cb((g[Ye] || null).action), C = c.submitter;
        C && (r = (r = C[Ye] || null) ? cb(r.formAction) : C.getAttribute("formAction"), r !== null && (y = r, C = null));
        var T = new Io("action", "action", null, c, g);
        i.push({
          event: T,
          listeners: [
            {
              instance: null,
              listener: function() {
                if (c.defaultPrevented) {
                  if (nn !== 0) {
                    var B = C ? ub(g, C) : new FormData(g);
                    Rf(s, {
                      pending: true,
                      data: B,
                      method: g.method,
                      action: y
                    }, null, B);
                  }
                } else typeof y == "function" && (T.preventDefault(), B = C ? ub(g, C) : new FormData(g), Rf(s, {
                  pending: true,
                  data: B,
                  method: g.method,
                  action: y
                }, y, B));
              },
              currentTarget: g
            }
          ]
        });
      }
    }
    for (var gd = 0; gd < Kh.length; gd++) {
      var md = Kh[gd], Sk = md.toLowerCase(), Ck = md[0].toUpperCase() + md.slice(1);
      Xi(Sk, "on" + Ck);
    }
    Xi(Y0, "onAnimationEnd"), Xi(I0, "onAnimationIteration"), Xi(P0, "onAnimationStart"), Xi("dblclick", "onDoubleClick"), Xi("focusin", "onFocus"), Xi("focusout", "onBlur"), Xi(HT, "onTransitionRun"), Xi(UT, "onTransitionStart"), Xi(jT, "onTransitionCancel"), Xi(G0, "onTransitionEnd"), dt("onMouseEnter", [
      "mouseout",
      "mouseover"
    ]), dt("onMouseLeave", [
      "mouseout",
      "mouseover"
    ]), dt("onPointerEnter", [
      "pointerout",
      "pointerover"
    ]), dt("onPointerLeave", [
      "pointerout",
      "pointerover"
    ]), st("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), st("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), st("onBeforeInput", [
      "compositionend",
      "keypress",
      "textInput",
      "paste"
    ]), st("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), st("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), st("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var ws = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), wk = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(ws));
    function hb(i, r) {
      r = (r & 4) !== 0;
      for (var s = 0; s < i.length; s++) {
        var c = i[s], g = c.event;
        c = c.listeners;
        t: {
          var y = void 0;
          if (r) for (var C = c.length - 1; 0 <= C; C--) {
            var T = c[C], B = T.instance, U = T.currentTarget;
            if (T = T.listener, B !== y && g.isPropagationStopped()) break t;
            y = T, g.currentTarget = U;
            try {
              y(g);
            } catch (Q) {
              mc(Q);
            }
            g.currentTarget = null, y = B;
          }
          else for (C = 0; C < c.length; C++) {
            if (T = c[C], B = T.instance, U = T.currentTarget, T = T.listener, B !== y && g.isPropagationStopped()) break t;
            y = T, g.currentTarget = U;
            try {
              y(g);
            } catch (Q) {
              mc(Q);
            }
            g.currentTarget = null, y = B;
          }
        }
      }
    }
    function Nt(i, r) {
      var s = r[nr];
      s === void 0 && (s = r[nr] = /* @__PURE__ */ new Set());
      var c = i + "__bubble";
      s.has(c) || (fb(r, i, 2, false), s.add(c));
    }
    function yd(i, r, s) {
      var c = 0;
      r && (c |= 4), fb(s, i, c, r);
    }
    var Bc = "_reactListening" + Math.random().toString(36).slice(2);
    function bd(i) {
      if (!i[Bc]) {
        i[Bc] = true, _t.forEach(function(s) {
          s !== "selectionchange" && (wk.has(s) || yd(s, false, i), yd(s, true, i));
        });
        var r = i.nodeType === 9 ? i : i.ownerDocument;
        r === null || r[Bc] || (r[Bc] = true, yd("selectionchange", false, r));
      }
    }
    function fb(i, r, s, c) {
      switch (Nb(r)) {
        case 2:
          var g = Qk;
          break;
        case 8:
          g = Kk;
          break;
        default:
          g = Od;
      }
      s = g.bind(null, r, s, i), g = void 0, !qh || r !== "touchstart" && r !== "touchmove" && r !== "wheel" || (g = true), c ? g !== void 0 ? i.addEventListener(r, s, {
        capture: true,
        passive: g
      }) : i.addEventListener(r, s, true) : g !== void 0 ? i.addEventListener(r, s, {
        passive: g
      }) : i.addEventListener(r, s, false);
    }
    function xd(i, r, s, c, g) {
      var y = c;
      if ((r & 1) === 0 && (r & 2) === 0 && c !== null) t: for (; ; ) {
        if (c === null) return;
        var C = c.tag;
        if (C === 3 || C === 4) {
          var T = c.stateNode.containerInfo;
          if (T === g) break;
          if (C === 4) for (C = c.return; C !== null; ) {
            var B = C.tag;
            if ((B === 3 || B === 4) && C.stateNode.containerInfo === g) return;
            C = C.return;
          }
          for (; T !== null; ) {
            if (C = Cr(T), C === null) return;
            if (B = C.tag, B === 5 || B === 6 || B === 26 || B === 27) {
              c = y = C;
              continue t;
            }
            T = T.parentNode;
          }
        }
        c = c.return;
      }
      x0(function() {
        var U = y, Q = zh(s), tt = [];
        t: {
          var I = W0.get(i);
          if (I !== void 0) {
            var P = Io, Bt = i;
            switch (i) {
              case "keypress":
                if (jo(s) === 0) break t;
              case "keydown":
              case "keyup":
                P = bT;
                break;
              case "focusin":
                Bt = "focus", P = Yh;
                break;
              case "focusout":
                Bt = "blur", P = Yh;
                break;
              case "beforeblur":
              case "afterblur":
                P = Yh;
                break;
              case "click":
                if (s.button === 2) break t;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                P = S0;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                P = lT;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                P = _T;
                break;
              case Y0:
              case I0:
              case P0:
                P = cT;
                break;
              case G0:
                P = CT;
                break;
              case "scroll":
              case "scrollend":
                P = aT;
                break;
              case "wheel":
                P = TT;
                break;
              case "copy":
              case "cut":
              case "paste":
                P = hT;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                P = w0;
                break;
              case "toggle":
              case "beforetoggle":
                P = AT;
            }
            var kt = (r & 4) !== 0, Jt = !kt && (i === "scroll" || i === "scrollend"), z = kt ? I !== null ? I + "Capture" : null : I;
            kt = [];
            for (var D = U, H; D !== null; ) {
              var J = D;
              if (H = J.stateNode, J = J.tag, J !== 5 && J !== 26 && J !== 27 || H === null || z === null || (J = Yl(D, z), J != null && kt.push(Ts(D, J, H))), Jt) break;
              D = D.return;
            }
            0 < kt.length && (I = new P(I, Bt, null, s, Q), tt.push({
              event: I,
              listeners: kt
            }));
          }
        }
        if ((r & 7) === 0) {
          t: {
            if (I = i === "mouseover" || i === "pointerover", P = i === "mouseout" || i === "pointerout", I && s !== Nh && (Bt = s.relatedTarget || s.fromElement) && (Cr(Bt) || Bt[De])) break t;
            if ((P || I) && (I = Q.window === Q ? Q : (I = Q.ownerDocument) ? I.defaultView || I.parentWindow : window, P ? (Bt = s.relatedTarget || s.toElement, P = U, Bt = Bt ? Cr(Bt) : null, Bt !== null && (Jt = o(Bt), kt = Bt.tag, Bt !== Jt || kt !== 5 && kt !== 27 && kt !== 6) && (Bt = null)) : (P = null, Bt = U), P !== Bt)) {
              if (kt = S0, J = "onMouseLeave", z = "onMouseEnter", D = "mouse", (i === "pointerout" || i === "pointerover") && (kt = w0, J = "onPointerLeave", z = "onPointerEnter", D = "pointer"), Jt = P == null ? I : ra(P), H = Bt == null ? I : ra(Bt), I = new kt(J, D + "leave", P, s, Q), I.target = Jt, I.relatedTarget = H, J = null, Cr(Q) === U && (kt = new kt(z, D + "enter", Bt, s, Q), kt.target = H, kt.relatedTarget = Jt, J = kt), Jt = J, P && Bt) e: {
                for (kt = P, z = Bt, D = 0, H = kt; H; H = sl(H)) D++;
                for (H = 0, J = z; J; J = sl(J)) H++;
                for (; 0 < D - H; ) kt = sl(kt), D--;
                for (; 0 < H - D; ) z = sl(z), H--;
                for (; D--; ) {
                  if (kt === z || z !== null && kt === z.alternate) break e;
                  kt = sl(kt), z = sl(z);
                }
                kt = null;
              }
              else kt = null;
              P !== null && db(tt, I, P, kt, false), Bt !== null && Jt !== null && db(tt, Jt, Bt, kt, true);
            }
          }
          t: {
            if (I = U ? ra(U) : window, P = I.nodeName && I.nodeName.toLowerCase(), P === "select" || P === "input" && I.type === "file") var gt = O0;
            else if (B0(I)) if (D0) gt = zT;
            else {
              gt = $T;
              var Rt = RT;
            }
            else P = I.nodeName, !P || P.toLowerCase() !== "input" || I.type !== "checkbox" && I.type !== "radio" ? U && $h(U.elementType) && (gt = O0) : gt = NT;
            if (gt && (gt = gt(i, U))) {
              L0(tt, gt, s, Q);
              break t;
            }
            Rt && Rt(i, I, U), i === "focusout" && U && I.type === "number" && U.memoizedProps.value != null && Rh(I, "number", I.value);
          }
          switch (Rt = U ? ra(U) : window, i) {
            case "focusin":
              (B0(Rt) || Rt.contentEditable === "true") && (zn = Rt, Vh = U, Ql = null);
              break;
            case "focusout":
              Ql = Vh = zn = null;
              break;
            case "mousedown":
              Zh = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Zh = false, U0(tt, s, Q);
              break;
            case "selectionchange":
              if (qT) break;
            case "keydown":
            case "keyup":
              U0(tt, s, Q);
          }
          var St;
          if (Ph) t: {
            switch (i) {
              case "compositionstart":
                var Et = "onCompositionStart";
                break t;
              case "compositionend":
                Et = "onCompositionEnd";
                break t;
              case "compositionupdate":
                Et = "onCompositionUpdate";
                break t;
            }
            Et = void 0;
          }
          else Nn ? E0(i, s) && (Et = "onCompositionEnd") : i === "keydown" && s.keyCode === 229 && (Et = "onCompositionStart");
          Et && (T0 && s.locale !== "ko" && (Nn || Et !== "onCompositionStart" ? Et === "onCompositionEnd" && Nn && (St = v0()) : (aa = Q, Hh = "value" in aa ? aa.value : aa.textContent, Nn = true)), Rt = Lc(U, Et), 0 < Rt.length && (Et = new C0(Et, i, null, s, Q), tt.push({
            event: Et,
            listeners: Rt
          }), St ? Et.data = St : (St = M0(s), St !== null && (Et.data = St)))), (St = MT ? BT(i, s) : LT(i, s)) && (Et = Lc(U, "onBeforeInput"), 0 < Et.length && (Rt = new C0("onBeforeInput", "beforeinput", null, s, Q), tt.push({
            event: Rt,
            listeners: Et
          }), Rt.data = St)), _k(tt, i, U, s, Q);
        }
        hb(tt, r);
      });
    }
    function Ts(i, r, s) {
      return {
        instance: i,
        listener: r,
        currentTarget: s
      };
    }
    function Lc(i, r) {
      for (var s = r + "Capture", c = []; i !== null; ) {
        var g = i, y = g.stateNode;
        if (g = g.tag, g !== 5 && g !== 26 && g !== 27 || y === null || (g = Yl(i, s), g != null && c.unshift(Ts(i, g, y)), g = Yl(i, r), g != null && c.push(Ts(i, g, y))), i.tag === 3) return c;
        i = i.return;
      }
      return [];
    }
    function sl(i) {
      if (i === null) return null;
      do
        i = i.return;
      while (i && i.tag !== 5 && i.tag !== 27);
      return i || null;
    }
    function db(i, r, s, c, g) {
      for (var y = r._reactName, C = []; s !== null && s !== c; ) {
        var T = s, B = T.alternate, U = T.stateNode;
        if (T = T.tag, B !== null && B === c) break;
        T !== 5 && T !== 26 && T !== 27 || U === null || (B = U, g ? (U = Yl(s, y), U != null && C.unshift(Ts(s, U, B))) : g || (U = Yl(s, y), U != null && C.push(Ts(s, U, B)))), s = s.return;
      }
      C.length !== 0 && i.push({
        event: r,
        listeners: C
      });
    }
    var Tk = /\r\n?/g, kk = /\u0000|\uFFFD/g;
    function pb(i) {
      return (typeof i == "string" ? i : "" + i).replace(Tk, `
`).replace(kk, "");
    }
    function gb(i, r) {
      return r = pb(r), pb(i) === r;
    }
    function Oc() {
    }
    function Kt(i, r, s, c, g, y) {
      switch (s) {
        case "children":
          typeof c == "string" ? r === "body" || r === "textarea" && c === "" || Dn(i, c) : (typeof c == "number" || typeof c == "bigint") && r !== "body" && Dn(i, "" + c);
          break;
        case "className":
          lr(i, "class", c);
          break;
        case "tabIndex":
          lr(i, "tabindex", c);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          lr(i, s, c);
          break;
        case "style":
          y0(i, c, y);
          break;
        case "data":
          if (r !== "object") {
            lr(i, "data", c);
            break;
          }
        case "src":
        case "href":
          if (c === "" && (r !== "a" || s !== "href")) {
            i.removeAttribute(s);
            break;
          }
          if (c == null || typeof c == "function" || typeof c == "symbol" || typeof c == "boolean") {
            i.removeAttribute(s);
            break;
          }
          c = Ho("" + c), i.setAttribute(s, c);
          break;
        case "action":
        case "formAction":
          if (typeof c == "function") {
            i.setAttribute(s, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
            break;
          } else typeof y == "function" && (s === "formAction" ? (r !== "input" && Kt(i, r, "name", g.name, g, null), Kt(i, r, "formEncType", g.formEncType, g, null), Kt(i, r, "formMethod", g.formMethod, g, null), Kt(i, r, "formTarget", g.formTarget, g, null)) : (Kt(i, r, "encType", g.encType, g, null), Kt(i, r, "method", g.method, g, null), Kt(i, r, "target", g.target, g, null)));
          if (c == null || typeof c == "symbol" || typeof c == "boolean") {
            i.removeAttribute(s);
            break;
          }
          c = Ho("" + c), i.setAttribute(s, c);
          break;
        case "onClick":
          c != null && (i.onclick = Oc);
          break;
        case "onScroll":
          c != null && Nt("scroll", i);
          break;
        case "onScrollEnd":
          c != null && Nt("scrollend", i);
          break;
        case "dangerouslySetInnerHTML":
          if (c != null) {
            if (typeof c != "object" || !("__html" in c)) throw Error(n(61));
            if (s = c.__html, s != null) {
              if (g.children != null) throw Error(n(60));
              i.innerHTML = s;
            }
          }
          break;
        case "multiple":
          i.multiple = c && typeof c != "function" && typeof c != "symbol";
          break;
        case "muted":
          i.muted = c && typeof c != "function" && typeof c != "symbol";
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (c == null || typeof c == "function" || typeof c == "boolean" || typeof c == "symbol") {
            i.removeAttribute("xlink:href");
            break;
          }
          s = Ho("" + c), i.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", s);
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          c != null && typeof c != "function" && typeof c != "symbol" ? i.setAttribute(s, "" + c) : i.removeAttribute(s);
          break;
        case "inert":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          c && typeof c != "function" && typeof c != "symbol" ? i.setAttribute(s, "") : i.removeAttribute(s);
          break;
        case "capture":
        case "download":
          c === true ? i.setAttribute(s, "") : c !== false && c != null && typeof c != "function" && typeof c != "symbol" ? i.setAttribute(s, c) : i.removeAttribute(s);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          c != null && typeof c != "function" && typeof c != "symbol" && !isNaN(c) && 1 <= c ? i.setAttribute(s, c) : i.removeAttribute(s);
          break;
        case "rowSpan":
        case "start":
          c == null || typeof c == "function" || typeof c == "symbol" || isNaN(c) ? i.removeAttribute(s) : i.setAttribute(s, c);
          break;
        case "popover":
          Nt("beforetoggle", i), Nt("toggle", i), si(i, "popover", c);
          break;
        case "xlinkActuate":
          bi(i, "http://www.w3.org/1999/xlink", "xlink:actuate", c);
          break;
        case "xlinkArcrole":
          bi(i, "http://www.w3.org/1999/xlink", "xlink:arcrole", c);
          break;
        case "xlinkRole":
          bi(i, "http://www.w3.org/1999/xlink", "xlink:role", c);
          break;
        case "xlinkShow":
          bi(i, "http://www.w3.org/1999/xlink", "xlink:show", c);
          break;
        case "xlinkTitle":
          bi(i, "http://www.w3.org/1999/xlink", "xlink:title", c);
          break;
        case "xlinkType":
          bi(i, "http://www.w3.org/1999/xlink", "xlink:type", c);
          break;
        case "xmlBase":
          bi(i, "http://www.w3.org/XML/1998/namespace", "xml:base", c);
          break;
        case "xmlLang":
          bi(i, "http://www.w3.org/XML/1998/namespace", "xml:lang", c);
          break;
        case "xmlSpace":
          bi(i, "http://www.w3.org/XML/1998/namespace", "xml:space", c);
          break;
        case "is":
          si(i, "is", c);
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          (!(2 < s.length) || s[0] !== "o" && s[0] !== "O" || s[1] !== "n" && s[1] !== "N") && (s = iT.get(s) || s, si(i, s, c));
      }
    }
    function vd(i, r, s, c, g, y) {
      switch (s) {
        case "style":
          y0(i, c, y);
          break;
        case "dangerouslySetInnerHTML":
          if (c != null) {
            if (typeof c != "object" || !("__html" in c)) throw Error(n(61));
            if (s = c.__html, s != null) {
              if (g.children != null) throw Error(n(60));
              i.innerHTML = s;
            }
          }
          break;
        case "children":
          typeof c == "string" ? Dn(i, c) : (typeof c == "number" || typeof c == "bigint") && Dn(i, "" + c);
          break;
        case "onScroll":
          c != null && Nt("scroll", i);
          break;
        case "onScrollEnd":
          c != null && Nt("scrollend", i);
          break;
        case "onClick":
          c != null && (i.onclick = Oc);
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (!R.hasOwnProperty(s)) t: {
            if (s[0] === "o" && s[1] === "n" && (g = s.endsWith("Capture"), r = s.slice(2, g ? s.length - 7 : void 0), y = i[Ye] || null, y = y != null ? y[s] : null, typeof y == "function" && i.removeEventListener(r, y, g), typeof c == "function")) {
              typeof y != "function" && y !== null && (s in i ? i[s] = null : i.hasAttribute(s) && i.removeAttribute(s)), i.addEventListener(r, c, g);
              break t;
            }
            s in i ? i[s] = c : c === true ? i.setAttribute(s, "") : si(i, s, c);
          }
      }
    }
    function Ne(i, r, s) {
      switch (r) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          Nt("error", i), Nt("load", i);
          var c = false, g = false, y;
          for (y in s) if (s.hasOwnProperty(y)) {
            var C = s[y];
            if (C != null) switch (y) {
              case "src":
                c = true;
                break;
              case "srcSet":
                g = true;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(n(137, r));
              default:
                Kt(i, r, y, C, s, null);
            }
          }
          g && Kt(i, r, "srcSet", s.srcSet, s, null), c && Kt(i, r, "src", s.src, s, null);
          return;
        case "input":
          Nt("invalid", i);
          var T = y = C = g = null, B = null, U = null;
          for (c in s) if (s.hasOwnProperty(c)) {
            var Q = s[c];
            if (Q != null) switch (c) {
              case "name":
                g = Q;
                break;
              case "type":
                C = Q;
                break;
              case "checked":
                B = Q;
                break;
              case "defaultChecked":
                U = Q;
                break;
              case "value":
                y = Q;
                break;
              case "defaultValue":
                T = Q;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (Q != null) throw Error(n(137, r));
                break;
              default:
                Kt(i, r, c, Q, s, null);
            }
          }
          d0(i, y, T, B, U, C, g, false), Fo(i);
          return;
        case "select":
          Nt("invalid", i), c = C = y = null;
          for (g in s) if (s.hasOwnProperty(g) && (T = s[g], T != null)) switch (g) {
            case "value":
              y = T;
              break;
            case "defaultValue":
              C = T;
              break;
            case "multiple":
              c = T;
            default:
              Kt(i, r, g, T, s, null);
          }
          r = y, s = C, i.multiple = !!c, r != null ? On(i, !!c, r, false) : s != null && On(i, !!c, s, true);
          return;
        case "textarea":
          Nt("invalid", i), y = g = c = null;
          for (C in s) if (s.hasOwnProperty(C) && (T = s[C], T != null)) switch (C) {
            case "value":
              c = T;
              break;
            case "defaultValue":
              g = T;
              break;
            case "children":
              y = T;
              break;
            case "dangerouslySetInnerHTML":
              if (T != null) throw Error(n(91));
              break;
            default:
              Kt(i, r, C, T, s, null);
          }
          g0(i, c, g, y), Fo(i);
          return;
        case "option":
          for (B in s) if (s.hasOwnProperty(B) && (c = s[B], c != null)) switch (B) {
            case "selected":
              i.selected = c && typeof c != "function" && typeof c != "symbol";
              break;
            default:
              Kt(i, r, B, c, s, null);
          }
          return;
        case "dialog":
          Nt("beforetoggle", i), Nt("toggle", i), Nt("cancel", i), Nt("close", i);
          break;
        case "iframe":
        case "object":
          Nt("load", i);
          break;
        case "video":
        case "audio":
          for (c = 0; c < ws.length; c++) Nt(ws[c], i);
          break;
        case "image":
          Nt("error", i), Nt("load", i);
          break;
        case "details":
          Nt("toggle", i);
          break;
        case "embed":
        case "source":
        case "link":
          Nt("error", i), Nt("load", i);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (U in s) if (s.hasOwnProperty(U) && (c = s[U], c != null)) switch (U) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(n(137, r));
            default:
              Kt(i, r, U, c, s, null);
          }
          return;
        default:
          if ($h(r)) {
            for (Q in s) s.hasOwnProperty(Q) && (c = s[Q], c !== void 0 && vd(i, r, Q, c, s, void 0));
            return;
          }
      }
      for (T in s) s.hasOwnProperty(T) && (c = s[T], c != null && Kt(i, r, T, c, s, null));
    }
    function Ak(i, r, s, c) {
      switch (r) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var g = null, y = null, C = null, T = null, B = null, U = null, Q = null;
          for (P in s) {
            var tt = s[P];
            if (s.hasOwnProperty(P) && tt != null) switch (P) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                B = tt;
              default:
                c.hasOwnProperty(P) || Kt(i, r, P, null, c, tt);
            }
          }
          for (var I in c) {
            var P = c[I];
            if (tt = s[I], c.hasOwnProperty(I) && (P != null || tt != null)) switch (I) {
              case "type":
                y = P;
                break;
              case "name":
                g = P;
                break;
              case "checked":
                U = P;
                break;
              case "defaultChecked":
                Q = P;
                break;
              case "value":
                C = P;
                break;
              case "defaultValue":
                T = P;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (P != null) throw Error(n(137, r));
                break;
              default:
                P !== tt && Kt(i, r, I, P, c, tt);
            }
          }
          Dh(i, C, T, B, U, Q, y, g);
          return;
        case "select":
          P = C = T = I = null;
          for (y in s) if (B = s[y], s.hasOwnProperty(y) && B != null) switch (y) {
            case "value":
              break;
            case "multiple":
              P = B;
            default:
              c.hasOwnProperty(y) || Kt(i, r, y, null, c, B);
          }
          for (g in c) if (y = c[g], B = s[g], c.hasOwnProperty(g) && (y != null || B != null)) switch (g) {
            case "value":
              I = y;
              break;
            case "defaultValue":
              T = y;
              break;
            case "multiple":
              C = y;
            default:
              y !== B && Kt(i, r, g, y, c, B);
          }
          r = T, s = C, c = P, I != null ? On(i, !!s, I, false) : !!c != !!s && (r != null ? On(i, !!s, r, true) : On(i, !!s, s ? [] : "", false));
          return;
        case "textarea":
          P = I = null;
          for (T in s) if (g = s[T], s.hasOwnProperty(T) && g != null && !c.hasOwnProperty(T)) switch (T) {
            case "value":
              break;
            case "children":
              break;
            default:
              Kt(i, r, T, null, c, g);
          }
          for (C in c) if (g = c[C], y = s[C], c.hasOwnProperty(C) && (g != null || y != null)) switch (C) {
            case "value":
              I = g;
              break;
            case "defaultValue":
              P = g;
              break;
            case "children":
              break;
            case "dangerouslySetInnerHTML":
              if (g != null) throw Error(n(91));
              break;
            default:
              g !== y && Kt(i, r, C, g, c, y);
          }
          p0(i, I, P);
          return;
        case "option":
          for (var Bt in s) if (I = s[Bt], s.hasOwnProperty(Bt) && I != null && !c.hasOwnProperty(Bt)) switch (Bt) {
            case "selected":
              i.selected = false;
              break;
            default:
              Kt(i, r, Bt, null, c, I);
          }
          for (B in c) if (I = c[B], P = s[B], c.hasOwnProperty(B) && I !== P && (I != null || P != null)) switch (B) {
            case "selected":
              i.selected = I && typeof I != "function" && typeof I != "symbol";
              break;
            default:
              Kt(i, r, B, I, c, P);
          }
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var kt in s) I = s[kt], s.hasOwnProperty(kt) && I != null && !c.hasOwnProperty(kt) && Kt(i, r, kt, null, c, I);
          for (U in c) if (I = c[U], P = s[U], c.hasOwnProperty(U) && I !== P && (I != null || P != null)) switch (U) {
            case "children":
            case "dangerouslySetInnerHTML":
              if (I != null) throw Error(n(137, r));
              break;
            default:
              Kt(i, r, U, I, c, P);
          }
          return;
        default:
          if ($h(r)) {
            for (var Jt in s) I = s[Jt], s.hasOwnProperty(Jt) && I !== void 0 && !c.hasOwnProperty(Jt) && vd(i, r, Jt, void 0, c, I);
            for (Q in c) I = c[Q], P = s[Q], !c.hasOwnProperty(Q) || I === P || I === void 0 && P === void 0 || vd(i, r, Q, I, c, P);
            return;
          }
      }
      for (var z in s) I = s[z], s.hasOwnProperty(z) && I != null && !c.hasOwnProperty(z) && Kt(i, r, z, null, c, I);
      for (tt in c) I = c[tt], P = s[tt], !c.hasOwnProperty(tt) || I === P || I == null && P == null || Kt(i, r, tt, I, c, P);
    }
    var _d2 = null, Sd = null;
    function Dc(i) {
      return i.nodeType === 9 ? i : i.ownerDocument;
    }
    function mb(i) {
      switch (i) {
        case "http://www.w3.org/2000/svg":
          return 1;
        case "http://www.w3.org/1998/Math/MathML":
          return 2;
        default:
          return 0;
      }
    }
    function yb(i, r) {
      if (i === 0) switch (r) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
      return i === 1 && r === "foreignObject" ? 0 : i;
    }
    function Cd(i, r) {
      return i === "textarea" || i === "noscript" || typeof r.children == "string" || typeof r.children == "number" || typeof r.children == "bigint" || typeof r.dangerouslySetInnerHTML == "object" && r.dangerouslySetInnerHTML !== null && r.dangerouslySetInnerHTML.__html != null;
    }
    var wd = null;
    function Ek() {
      var i = window.event;
      return i && i.type === "popstate" ? i === wd ? false : (wd = i, true) : (wd = null, false);
    }
    var bb = typeof setTimeout == "function" ? setTimeout : void 0, Mk = typeof clearTimeout == "function" ? clearTimeout : void 0, xb = typeof Promise == "function" ? Promise : void 0, Bk = typeof queueMicrotask == "function" ? queueMicrotask : typeof xb < "u" ? function(i) {
      return xb.resolve(null).then(i).catch(Lk);
    } : bb;
    function Lk(i) {
      setTimeout(function() {
        throw i;
      });
    }
    function va(i) {
      return i === "head";
    }
    function vb(i, r) {
      var s = r, c = 0, g = 0;
      do {
        var y = s.nextSibling;
        if (i.removeChild(s), y && y.nodeType === 8) if (s = y.data, s === "/$") {
          if (0 < c && 8 > c) {
            s = c;
            var C = i.ownerDocument;
            if (s & 1 && ks(C.documentElement), s & 2 && ks(C.body), s & 4) for (s = C.head, ks(s), C = s.firstChild; C; ) {
              var T = C.nextSibling, B = C.nodeName;
              C[ia] || B === "SCRIPT" || B === "STYLE" || B === "LINK" && C.rel.toLowerCase() === "stylesheet" || s.removeChild(C), C = T;
            }
          }
          if (g === 0) {
            i.removeChild(y), Rs(r);
            return;
          }
          g--;
        } else s === "$" || s === "$?" || s === "$!" ? g++ : c = s.charCodeAt(0) - 48;
        else c = 0;
        s = y;
      } while (s);
      Rs(r);
    }
    function Td(i) {
      var r = i.firstChild;
      for (r && r.nodeType === 10 && (r = r.nextSibling); r; ) {
        var s = r;
        switch (r = r.nextSibling, s.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY":
            Td(s), yi(s);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if (s.rel.toLowerCase() === "stylesheet") continue;
        }
        i.removeChild(s);
      }
    }
    function Ok(i, r, s, c) {
      for (; i.nodeType === 1; ) {
        var g = s;
        if (i.nodeName.toLowerCase() !== r.toLowerCase()) {
          if (!c && (i.nodeName !== "INPUT" || i.type !== "hidden")) break;
        } else if (c) {
          if (!i[ia]) switch (r) {
            case "meta":
              if (!i.hasAttribute("itemprop")) break;
              return i;
            case "link":
              if (y = i.getAttribute("rel"), y === "stylesheet" && i.hasAttribute("data-precedence")) break;
              if (y !== g.rel || i.getAttribute("href") !== (g.href == null || g.href === "" ? null : g.href) || i.getAttribute("crossorigin") !== (g.crossOrigin == null ? null : g.crossOrigin) || i.getAttribute("title") !== (g.title == null ? null : g.title)) break;
              return i;
            case "style":
              if (i.hasAttribute("data-precedence")) break;
              return i;
            case "script":
              if (y = i.getAttribute("src"), (y !== (g.src == null ? null : g.src) || i.getAttribute("type") !== (g.type == null ? null : g.type) || i.getAttribute("crossorigin") !== (g.crossOrigin == null ? null : g.crossOrigin)) && y && i.hasAttribute("async") && !i.hasAttribute("itemprop")) break;
              return i;
            default:
              return i;
          }
        } else if (r === "input" && i.type === "hidden") {
          var y = g.name == null ? null : "" + g.name;
          if (g.type === "hidden" && i.getAttribute("name") === y) return i;
        } else return i;
        if (i = Zi(i.nextSibling), i === null) break;
      }
      return null;
    }
    function Dk(i, r, s) {
      if (r === "") return null;
      for (; i.nodeType !== 3; ) if ((i.nodeType !== 1 || i.nodeName !== "INPUT" || i.type !== "hidden") && !s || (i = Zi(i.nextSibling), i === null)) return null;
      return i;
    }
    function kd(i) {
      return i.data === "$!" || i.data === "$?" && i.ownerDocument.readyState === "complete";
    }
    function Rk(i, r) {
      var s = i.ownerDocument;
      if (i.data !== "$?" || s.readyState === "complete") r();
      else {
        var c = function() {
          r(), s.removeEventListener("DOMContentLoaded", c);
        };
        s.addEventListener("DOMContentLoaded", c), i._reactRetry = c;
      }
    }
    function Zi(i) {
      for (; i != null; i = i.nextSibling) {
        var r = i.nodeType;
        if (r === 1 || r === 3) break;
        if (r === 8) {
          if (r = i.data, r === "$" || r === "$!" || r === "$?" || r === "F!" || r === "F") break;
          if (r === "/$") return null;
        }
      }
      return i;
    }
    var Ad = null;
    function _b2(i) {
      i = i.previousSibling;
      for (var r = 0; i; ) {
        if (i.nodeType === 8) {
          var s = i.data;
          if (s === "$" || s === "$!" || s === "$?") {
            if (r === 0) return i;
            r--;
          } else s === "/$" && r++;
        }
        i = i.previousSibling;
      }
      return null;
    }
    function Sb(i, r, s) {
      switch (r = Dc(s), i) {
        case "html":
          if (i = r.documentElement, !i) throw Error(n(452));
          return i;
        case "head":
          if (i = r.head, !i) throw Error(n(453));
          return i;
        case "body":
          if (i = r.body, !i) throw Error(n(454));
          return i;
        default:
          throw Error(n(451));
      }
    }
    function ks(i) {
      for (var r = i.attributes; r.length; ) i.removeAttributeNode(r[0]);
      yi(i);
    }
    var Fi = /* @__PURE__ */ new Map(), Cb = /* @__PURE__ */ new Set();
    function Rc(i) {
      return typeof i.getRootNode == "function" ? i.getRootNode() : i.nodeType === 9 ? i : i.ownerDocument;
    }
    var Hr = N.d;
    N.d = {
      f: $k,
      r: Nk,
      D: zk,
      C: Fk,
      L: qk,
      m: Hk,
      X: jk,
      S: Uk,
      M: Yk
    };
    function $k() {
      var i = Hr.f(), r = Tc();
      return i || r;
    }
    function Nk(i) {
      var r = wr(i);
      r !== null && r.tag === 5 && r.type === "form" ? Ym(r) : Hr.r(i);
    }
    var ol = typeof document > "u" ? null : document;
    function wb(i, r, s) {
      var c = ol;
      if (c && typeof r == "string" && r) {
        var g = Li(r);
        g = 'link[rel="' + i + '"][href="' + g + '"]', typeof s == "string" && (g += '[crossorigin="' + s + '"]'), Cb.has(g) || (Cb.add(g), i = {
          rel: i,
          crossOrigin: s,
          href: r
        }, c.querySelector(g) === null && (r = c.createElement("link"), Ne(r, "link", i), me(r), c.head.appendChild(r)));
      }
    }
    function zk(i) {
      Hr.D(i), wb("dns-prefetch", i, null);
    }
    function Fk(i, r) {
      Hr.C(i, r), wb("preconnect", i, r);
    }
    function qk(i, r, s) {
      Hr.L(i, r, s);
      var c = ol;
      if (c && i && r) {
        var g = 'link[rel="preload"][as="' + Li(r) + '"]';
        r === "image" && s && s.imageSrcSet ? (g += '[imagesrcset="' + Li(s.imageSrcSet) + '"]', typeof s.imageSizes == "string" && (g += '[imagesizes="' + Li(s.imageSizes) + '"]')) : g += '[href="' + Li(i) + '"]';
        var y = g;
        switch (r) {
          case "style":
            y = cl(i);
            break;
          case "script":
            y = ul(i);
        }
        Fi.has(y) || (i = p({
          rel: "preload",
          href: r === "image" && s && s.imageSrcSet ? void 0 : i,
          as: r
        }, s), Fi.set(y, i), c.querySelector(g) !== null || r === "style" && c.querySelector(As(y)) || r === "script" && c.querySelector(Es(y)) || (r = c.createElement("link"), Ne(r, "link", i), me(r), c.head.appendChild(r)));
      }
    }
    function Hk(i, r) {
      Hr.m(i, r);
      var s = ol;
      if (s && i) {
        var c = r && typeof r.as == "string" ? r.as : "script", g = 'link[rel="modulepreload"][as="' + Li(c) + '"][href="' + Li(i) + '"]', y = g;
        switch (c) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            y = ul(i);
        }
        if (!Fi.has(y) && (i = p({
          rel: "modulepreload",
          href: i
        }, r), Fi.set(y, i), s.querySelector(g) === null)) {
          switch (c) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              if (s.querySelector(Es(y))) return;
          }
          c = s.createElement("link"), Ne(c, "link", i), me(c), s.head.appendChild(c);
        }
      }
    }
    function Uk(i, r, s) {
      Hr.S(i, r, s);
      var c = ol;
      if (c && i) {
        var g = Tr(c).hoistableStyles, y = cl(i);
        r = r || "default";
        var C = g.get(y);
        if (!C) {
          var T = {
            loading: 0,
            preload: null
          };
          if (C = c.querySelector(As(y))) T.loading = 5;
          else {
            i = p({
              rel: "stylesheet",
              href: i,
              "data-precedence": r
            }, s), (s = Fi.get(y)) && Ed(i, s);
            var B = C = c.createElement("link");
            me(B), Ne(B, "link", i), B._p = new Promise(function(U, Q) {
              B.onload = U, B.onerror = Q;
            }), B.addEventListener("load", function() {
              T.loading |= 1;
            }), B.addEventListener("error", function() {
              T.loading |= 2;
            }), T.loading |= 4, $c(C, r, c);
          }
          C = {
            type: "stylesheet",
            instance: C,
            count: 1,
            state: T
          }, g.set(y, C);
        }
      }
    }
    function jk(i, r) {
      Hr.X(i, r);
      var s = ol;
      if (s && i) {
        var c = Tr(s).hoistableScripts, g = ul(i), y = c.get(g);
        y || (y = s.querySelector(Es(g)), y || (i = p({
          src: i,
          async: true
        }, r), (r = Fi.get(g)) && Md(i, r), y = s.createElement("script"), me(y), Ne(y, "link", i), s.head.appendChild(y)), y = {
          type: "script",
          instance: y,
          count: 1,
          state: null
        }, c.set(g, y));
      }
    }
    function Yk(i, r) {
      Hr.M(i, r);
      var s = ol;
      if (s && i) {
        var c = Tr(s).hoistableScripts, g = ul(i), y = c.get(g);
        y || (y = s.querySelector(Es(g)), y || (i = p({
          src: i,
          async: true,
          type: "module"
        }, r), (r = Fi.get(g)) && Md(i, r), y = s.createElement("script"), me(y), Ne(y, "link", i), s.head.appendChild(y)), y = {
          type: "script",
          instance: y,
          count: 1,
          state: null
        }, c.set(g, y));
      }
    }
    function Tb(i, r, s, c) {
      var g = (g = pt.current) ? Rc(g) : null;
      if (!g) throw Error(n(446));
      switch (i) {
        case "meta":
        case "title":
          return null;
        case "style":
          return typeof s.precedence == "string" && typeof s.href == "string" ? (r = cl(s.href), s = Tr(g).hoistableStyles, c = s.get(r), c || (c = {
            type: "style",
            instance: null,
            count: 0,
            state: null
          }, s.set(r, c)), c) : {
            type: "void",
            instance: null,
            count: 0,
            state: null
          };
        case "link":
          if (s.rel === "stylesheet" && typeof s.href == "string" && typeof s.precedence == "string") {
            i = cl(s.href);
            var y = Tr(g).hoistableStyles, C = y.get(i);
            if (C || (g = g.ownerDocument || g, C = {
              type: "stylesheet",
              instance: null,
              count: 0,
              state: {
                loading: 0,
                preload: null
              }
            }, y.set(i, C), (y = g.querySelector(As(i))) && !y._p && (C.instance = y, C.state.loading = 5), Fi.has(i) || (s = {
              rel: "preload",
              as: "style",
              href: s.href,
              crossOrigin: s.crossOrigin,
              integrity: s.integrity,
              media: s.media,
              hrefLang: s.hrefLang,
              referrerPolicy: s.referrerPolicy
            }, Fi.set(i, s), y || Ik(g, i, s, C.state))), r && c === null) throw Error(n(528, ""));
            return C;
          }
          if (r && c !== null) throw Error(n(529, ""));
          return null;
        case "script":
          return r = s.async, s = s.src, typeof s == "string" && r && typeof r != "function" && typeof r != "symbol" ? (r = ul(s), s = Tr(g).hoistableScripts, c = s.get(r), c || (c = {
            type: "script",
            instance: null,
            count: 0,
            state: null
          }, s.set(r, c)), c) : {
            type: "void",
            instance: null,
            count: 0,
            state: null
          };
        default:
          throw Error(n(444, i));
      }
    }
    function cl(i) {
      return 'href="' + Li(i) + '"';
    }
    function As(i) {
      return 'link[rel="stylesheet"][' + i + "]";
    }
    function kb(i) {
      return p({}, i, {
        "data-precedence": i.precedence,
        precedence: null
      });
    }
    function Ik(i, r, s, c) {
      i.querySelector('link[rel="preload"][as="style"][' + r + "]") ? c.loading = 1 : (r = i.createElement("link"), c.preload = r, r.addEventListener("load", function() {
        return c.loading |= 1;
      }), r.addEventListener("error", function() {
        return c.loading |= 2;
      }), Ne(r, "link", s), me(r), i.head.appendChild(r));
    }
    function ul(i) {
      return '[src="' + Li(i) + '"]';
    }
    function Es(i) {
      return "script[async]" + i;
    }
    function Ab(i, r, s) {
      if (r.count++, r.instance === null) switch (r.type) {
        case "style":
          var c = i.querySelector('style[data-href~="' + Li(s.href) + '"]');
          if (c) return r.instance = c, me(c), c;
          var g = p({}, s, {
            "data-href": s.href,
            "data-precedence": s.precedence,
            href: null,
            precedence: null
          });
          return c = (i.ownerDocument || i).createElement("style"), me(c), Ne(c, "style", g), $c(c, s.precedence, i), r.instance = c;
        case "stylesheet":
          g = cl(s.href);
          var y = i.querySelector(As(g));
          if (y) return r.state.loading |= 4, r.instance = y, me(y), y;
          c = kb(s), (g = Fi.get(g)) && Ed(c, g), y = (i.ownerDocument || i).createElement("link"), me(y);
          var C = y;
          return C._p = new Promise(function(T, B) {
            C.onload = T, C.onerror = B;
          }), Ne(y, "link", c), r.state.loading |= 4, $c(y, s.precedence, i), r.instance = y;
        case "script":
          return y = ul(s.src), (g = i.querySelector(Es(y))) ? (r.instance = g, me(g), g) : (c = s, (g = Fi.get(y)) && (c = p({}, s), Md(c, g)), i = i.ownerDocument || i, g = i.createElement("script"), me(g), Ne(g, "link", c), i.head.appendChild(g), r.instance = g);
        case "void":
          return null;
        default:
          throw Error(n(443, r.type));
      }
      else r.type === "stylesheet" && (r.state.loading & 4) === 0 && (c = r.instance, r.state.loading |= 4, $c(c, s.precedence, i));
      return r.instance;
    }
    function $c(i, r, s) {
      for (var c = s.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), g = c.length ? c[c.length - 1] : null, y = g, C = 0; C < c.length; C++) {
        var T = c[C];
        if (T.dataset.precedence === r) y = T;
        else if (y !== g) break;
      }
      y ? y.parentNode.insertBefore(i, y.nextSibling) : (r = s.nodeType === 9 ? s.head : s, r.insertBefore(i, r.firstChild));
    }
    function Ed(i, r) {
      i.crossOrigin == null && (i.crossOrigin = r.crossOrigin), i.referrerPolicy == null && (i.referrerPolicy = r.referrerPolicy), i.title == null && (i.title = r.title);
    }
    function Md(i, r) {
      i.crossOrigin == null && (i.crossOrigin = r.crossOrigin), i.referrerPolicy == null && (i.referrerPolicy = r.referrerPolicy), i.integrity == null && (i.integrity = r.integrity);
    }
    var Nc = null;
    function Eb(i, r, s) {
      if (Nc === null) {
        var c = /* @__PURE__ */ new Map(), g = Nc = /* @__PURE__ */ new Map();
        g.set(s, c);
      } else g = Nc, c = g.get(s), c || (c = /* @__PURE__ */ new Map(), g.set(s, c));
      if (c.has(i)) return c;
      for (c.set(i, null), s = s.getElementsByTagName(i), g = 0; g < s.length; g++) {
        var y = s[g];
        if (!(y[ia] || y[_e2] || i === "link" && y.getAttribute("rel") === "stylesheet") && y.namespaceURI !== "http://www.w3.org/2000/svg") {
          var C = y.getAttribute(r) || "";
          C = i + C;
          var T = c.get(C);
          T ? T.push(y) : c.set(C, [
            y
          ]);
        }
      }
      return c;
    }
    function Mb(i, r, s) {
      i = i.ownerDocument || i, i.head.insertBefore(s, r === "title" ? i.querySelector("head > title") : null);
    }
    function Pk(i, r, s) {
      if (s === 1 || r.itemProp != null) return false;
      switch (i) {
        case "meta":
        case "title":
          return true;
        case "style":
          if (typeof r.precedence != "string" || typeof r.href != "string" || r.href === "") break;
          return true;
        case "link":
          if (typeof r.rel != "string" || typeof r.href != "string" || r.href === "" || r.onLoad || r.onError) break;
          switch (r.rel) {
            case "stylesheet":
              return i = r.disabled, typeof r.precedence == "string" && i == null;
            default:
              return true;
          }
        case "script":
          if (r.async && typeof r.async != "function" && typeof r.async != "symbol" && !r.onLoad && !r.onError && r.src && typeof r.src == "string") return true;
      }
      return false;
    }
    function Bb(i) {
      return !(i.type === "stylesheet" && (i.state.loading & 3) === 0);
    }
    var Ms = null;
    function Gk() {
    }
    function Wk(i, r, s) {
      if (Ms === null) throw Error(n(475));
      var c = Ms;
      if (r.type === "stylesheet" && (typeof s.media != "string" || matchMedia(s.media).matches !== false) && (r.state.loading & 4) === 0) {
        if (r.instance === null) {
          var g = cl(s.href), y = i.querySelector(As(g));
          if (y) {
            i = y._p, i !== null && typeof i == "object" && typeof i.then == "function" && (c.count++, c = zc.bind(c), i.then(c, c)), r.state.loading |= 4, r.instance = y, me(y);
            return;
          }
          y = i.ownerDocument || i, s = kb(s), (g = Fi.get(g)) && Ed(s, g), y = y.createElement("link"), me(y);
          var C = y;
          C._p = new Promise(function(T, B) {
            C.onload = T, C.onerror = B;
          }), Ne(y, "link", s), r.instance = y;
        }
        c.stylesheets === null && (c.stylesheets = /* @__PURE__ */ new Map()), c.stylesheets.set(r, i), (i = r.state.preload) && (r.state.loading & 3) === 0 && (c.count++, r = zc.bind(c), i.addEventListener("load", r), i.addEventListener("error", r));
      }
    }
    function Xk() {
      if (Ms === null) throw Error(n(475));
      var i = Ms;
      return i.stylesheets && i.count === 0 && Bd(i, i.stylesheets), 0 < i.count ? function(r) {
        var s = setTimeout(function() {
          if (i.stylesheets && Bd(i, i.stylesheets), i.unsuspend) {
            var c = i.unsuspend;
            i.unsuspend = null, c();
          }
        }, 6e4);
        return i.unsuspend = r, function() {
          i.unsuspend = null, clearTimeout(s);
        };
      } : null;
    }
    function zc() {
      if (this.count--, this.count === 0) {
        if (this.stylesheets) Bd(this, this.stylesheets);
        else if (this.unsuspend) {
          var i = this.unsuspend;
          this.unsuspend = null, i();
        }
      }
    }
    var Fc = null;
    function Bd(i, r) {
      i.stylesheets = null, i.unsuspend !== null && (i.count++, Fc = /* @__PURE__ */ new Map(), r.forEach(Vk, i), Fc = null, zc.call(i));
    }
    function Vk(i, r) {
      if (!(r.state.loading & 4)) {
        var s = Fc.get(i);
        if (s) var c = s.get(null);
        else {
          s = /* @__PURE__ */ new Map(), Fc.set(i, s);
          for (var g = i.querySelectorAll("link[data-precedence],style[data-precedence]"), y = 0; y < g.length; y++) {
            var C = g[y];
            (C.nodeName === "LINK" || C.getAttribute("media") !== "not all") && (s.set(C.dataset.precedence, C), c = C);
          }
          c && s.set(null, c);
        }
        g = r.instance, C = g.getAttribute("data-precedence"), y = s.get(C) || c, y === c && s.set(null, g), s.set(C, g), this.count++, c = zc.bind(this), g.addEventListener("load", c), g.addEventListener("error", c), y ? y.parentNode.insertBefore(g, y.nextSibling) : (i = i.nodeType === 9 ? i.head : i, i.insertBefore(g, i.firstChild)), r.state.loading |= 4;
      }
    }
    var Bs = {
      $$typeof: L,
      Provider: null,
      Consumer: null,
      _currentValue: F,
      _currentValue2: F,
      _threadCount: 0
    };
    function Zk(i, r, s, c, g, y, C, T) {
      this.tag = 1, this.containerInfo = i, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = Fl(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Fl(0), this.hiddenUpdates = Fl(null), this.identifierPrefix = c, this.onUncaughtError = g, this.onCaughtError = y, this.onRecoverableError = C, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = T, this.incompleteTransitions = /* @__PURE__ */ new Map();
    }
    function Lb(i, r, s, c, g, y, C, T, B, U, Q, tt) {
      return i = new Zk(i, r, s, C, T, B, U, tt), r = 1, y === true && (r |= 24), y = vi(3, null, null, r), i.current = y, y.stateNode = i, r = hf(), r.refCount++, i.pooledCache = r, r.refCount++, y.memoizedState = {
        element: c,
        isDehydrated: s,
        cache: r
      }, gf(y), i;
    }
    function Ob(i) {
      return i ? (i = Un, i) : Un;
    }
    function Db(i, r, s, c, g, y) {
      g = Ob(g), c.context === null ? c.context = g : c.pendingContext = g, c = sa(r), c.payload = {
        element: s
      }, y = y === void 0 ? null : y, y !== null && (c.callback = y), s = oa(i, c, r), s !== null && (Ti(s, i, r), ls(s, i, r));
    }
    function Rb(i, r) {
      if (i = i.memoizedState, i !== null && i.dehydrated !== null) {
        var s = i.retryLane;
        i.retryLane = s !== 0 && s < r ? s : r;
      }
    }
    function Ld(i, r) {
      Rb(i, r), (i = i.alternate) && Rb(i, r);
    }
    function $b(i) {
      if (i.tag === 13) {
        var r = Hn(i, 67108864);
        r !== null && Ti(r, i, 67108864), Ld(i, 67108864);
      }
    }
    var qc = true;
    function Qk(i, r, s, c) {
      var g = E.T;
      E.T = null;
      var y = N.p;
      try {
        N.p = 2, Od(i, r, s, c);
      } finally {
        N.p = y, E.T = g;
      }
    }
    function Kk(i, r, s, c) {
      var g = E.T;
      E.T = null;
      var y = N.p;
      try {
        N.p = 8, Od(i, r, s, c);
      } finally {
        N.p = y, E.T = g;
      }
    }
    function Od(i, r, s, c) {
      if (qc) {
        var g = Dd(c);
        if (g === null) xd(i, r, c, Hc, s), zb(i, c);
        else if (tA(g, i, r, s, c)) c.stopPropagation();
        else if (zb(i, c), r & 4 && -1 < Jk.indexOf(i)) {
          for (; g !== null; ) {
            var y = wr(g);
            if (y !== null) switch (y.tag) {
              case 3:
                if (y = y.stateNode, y.current.memoizedState.isDehydrated) {
                  var C = li(y.pendingLanes);
                  if (C !== 0) {
                    var T = y;
                    for (T.pendingLanes |= 2, T.entangledLanes |= 2; C; ) {
                      var B = 1 << 31 - je(C);
                      T.entanglements[1] |= B, C &= ~B;
                    }
                    hr(y), (Vt & 6) === 0 && (Cc = Oe() + 500, Cs(0));
                  }
                }
                break;
              case 13:
                T = Hn(y, 2), T !== null && Ti(T, y, 2), Tc(), Ld(y, 2);
            }
            if (y = Dd(c), y === null && xd(i, r, c, Hc, s), y === g) break;
            g = y;
          }
          g !== null && c.stopPropagation();
        } else xd(i, r, c, null, s);
      }
    }
    function Dd(i) {
      return i = zh(i), Rd(i);
    }
    var Hc = null;
    function Rd(i) {
      if (Hc = null, i = Cr(i), i !== null) {
        var r = o(i);
        if (r === null) i = null;
        else {
          var s = r.tag;
          if (s === 13) {
            if (i = h(r), i !== null) return i;
            i = null;
          } else if (s === 3) {
            if (r.stateNode.current.memoizedState.isDehydrated) return r.tag === 3 ? r.stateNode.containerInfo : null;
            i = null;
          } else r !== i && (i = null);
        }
      }
      return Hc = i, null;
    }
    function Nb(i) {
      switch (i) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 2;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 8;
        case "message":
          switch (En()) {
            case Fa:
              return 2;
            case Nl:
              return 8;
            case qa:
            case Eh:
              return 32;
            case Mn:
              return 268435456;
            default:
              return 32;
          }
        default:
          return 32;
      }
    }
    var $d = false, _a2 = null, Sa = null, Ca = null, Ls = /* @__PURE__ */ new Map(), Os = /* @__PURE__ */ new Map(), wa = [], Jk = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
    function zb(i, r) {
      switch (i) {
        case "focusin":
        case "focusout":
          _a2 = null;
          break;
        case "dragenter":
        case "dragleave":
          Sa = null;
          break;
        case "mouseover":
        case "mouseout":
          Ca = null;
          break;
        case "pointerover":
        case "pointerout":
          Ls.delete(r.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Os.delete(r.pointerId);
      }
    }
    function Ds(i, r, s, c, g, y) {
      return i === null || i.nativeEvent !== y ? (i = {
        blockedOn: r,
        domEventName: s,
        eventSystemFlags: c,
        nativeEvent: y,
        targetContainers: [
          g
        ]
      }, r !== null && (r = wr(r), r !== null && $b(r)), i) : (i.eventSystemFlags |= c, r = i.targetContainers, g !== null && r.indexOf(g) === -1 && r.push(g), i);
    }
    function tA(i, r, s, c, g) {
      switch (r) {
        case "focusin":
          return _a2 = Ds(_a2, i, r, s, c, g), true;
        case "dragenter":
          return Sa = Ds(Sa, i, r, s, c, g), true;
        case "mouseover":
          return Ca = Ds(Ca, i, r, s, c, g), true;
        case "pointerover":
          var y = g.pointerId;
          return Ls.set(y, Ds(Ls.get(y) || null, i, r, s, c, g)), true;
        case "gotpointercapture":
          return y = g.pointerId, Os.set(y, Ds(Os.get(y) || null, i, r, s, c, g)), true;
      }
      return false;
    }
    function Fb(i) {
      var r = Cr(i.target);
      if (r !== null) {
        var s = o(r);
        if (s !== null) {
          if (r = s.tag, r === 13) {
            if (r = h(s), r !== null) {
              i.blockedOn = r, Ul(i.priority, function() {
                if (s.tag === 13) {
                  var c = wi();
                  c = ar(c);
                  var g = Hn(s, c);
                  g !== null && Ti(g, s, c), Ld(s, c);
                }
              });
              return;
            }
          } else if (r === 3 && s.stateNode.current.memoizedState.isDehydrated) {
            i.blockedOn = s.tag === 3 ? s.stateNode.containerInfo : null;
            return;
          }
        }
      }
      i.blockedOn = null;
    }
    function Uc(i) {
      if (i.blockedOn !== null) return false;
      for (var r = i.targetContainers; 0 < r.length; ) {
        var s = Dd(i.nativeEvent);
        if (s === null) {
          s = i.nativeEvent;
          var c = new s.constructor(s.type, s);
          Nh = c, s.target.dispatchEvent(c), Nh = null;
        } else return r = wr(s), r !== null && $b(r), i.blockedOn = s, false;
        r.shift();
      }
      return true;
    }
    function qb(i, r, s) {
      Uc(i) && s.delete(r);
    }
    function eA() {
      $d = false, _a2 !== null && Uc(_a2) && (_a2 = null), Sa !== null && Uc(Sa) && (Sa = null), Ca !== null && Uc(Ca) && (Ca = null), Ls.forEach(qb), Os.forEach(qb);
    }
    function jc(i, r) {
      i.blockedOn === r && (i.blockedOn = null, $d || ($d = true, t.unstable_scheduleCallback(t.unstable_NormalPriority, eA)));
    }
    var Yc = null;
    function Hb(i) {
      Yc !== i && (Yc = i, t.unstable_scheduleCallback(t.unstable_NormalPriority, function() {
        Yc === i && (Yc = null);
        for (var r = 0; r < i.length; r += 3) {
          var s = i[r], c = i[r + 1], g = i[r + 2];
          if (typeof c != "function") {
            if (Rd(c || s) === null) continue;
            break;
          }
          var y = wr(s);
          y !== null && (i.splice(r, 3), r -= 3, Rf(y, {
            pending: true,
            data: g,
            method: s.method,
            action: c
          }, c, g));
        }
      }));
    }
    function Rs(i) {
      function r(B) {
        return jc(B, i);
      }
      _a2 !== null && jc(_a2, i), Sa !== null && jc(Sa, i), Ca !== null && jc(Ca, i), Ls.forEach(r), Os.forEach(r);
      for (var s = 0; s < wa.length; s++) {
        var c = wa[s];
        c.blockedOn === i && (c.blockedOn = null);
      }
      for (; 0 < wa.length && (s = wa[0], s.blockedOn === null); ) Fb(s), s.blockedOn === null && wa.shift();
      if (s = (i.ownerDocument || i).$$reactFormReplay, s != null) for (c = 0; c < s.length; c += 3) {
        var g = s[c], y = s[c + 1], C = g[Ye] || null;
        if (typeof y == "function") C || Hb(s);
        else if (C) {
          var T = null;
          if (y && y.hasAttribute("formAction")) {
            if (g = y, C = y[Ye] || null) T = C.formAction;
            else if (Rd(g) !== null) continue;
          } else T = C.action;
          typeof T == "function" ? s[c + 1] = T : (s.splice(c, 3), c -= 3), Hb(s);
        }
      }
    }
    function Nd(i) {
      this._internalRoot = i;
    }
    Ic.prototype.render = Nd.prototype.render = function(i) {
      var r = this._internalRoot;
      if (r === null) throw Error(n(409));
      var s = r.current, c = wi();
      Db(s, c, i, r, null, null);
    }, Ic.prototype.unmount = Nd.prototype.unmount = function() {
      var i = this._internalRoot;
      if (i !== null) {
        this._internalRoot = null;
        var r = i.containerInfo;
        Db(i.current, 2, null, i, null, null), Tc(), r[De] = null;
      }
    };
    function Ic(i) {
      this._internalRoot = i;
    }
    Ic.prototype.unstable_scheduleHydration = function(i) {
      if (i) {
        var r = Hl();
        i = {
          blockedOn: null,
          target: i,
          priority: r
        };
        for (var s = 0; s < wa.length && r !== 0 && r < wa[s].priority; s++) ;
        wa.splice(s, 0, i), s === 0 && Fb(i);
      }
    };
    var Ub = e.version;
    if (Ub !== "19.1.1") throw Error(n(527, Ub, "19.1.1"));
    N.findDOMNode = function(i) {
      var r = i._reactInternals;
      if (r === void 0) throw typeof i.render == "function" ? Error(n(188)) : (i = Object.keys(i).join(","), Error(n(268, i)));
      return i = d(r), i = i !== null ? f(i) : null, i = i === null ? null : i.stateNode, i;
    };
    var iA = {
      bundleType: 0,
      version: "19.1.1",
      rendererPackageName: "react-dom",
      currentDispatcherRef: E,
      reconcilerVersion: "19.1.1"
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
      var Pc = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!Pc.isDisabled && Pc.supportsFiber) try {
        Mi = Pc.inject(iA), Ue = Pc;
      } catch {
      }
    }
    return Ns.createRoot = function(i, r) {
      if (!l(i)) throw Error(n(299));
      var s = false, c = "", g = ry, y = ay, C = ny, T = null;
      return r != null && (r.unstable_strictMode === true && (s = true), r.identifierPrefix !== void 0 && (c = r.identifierPrefix), r.onUncaughtError !== void 0 && (g = r.onUncaughtError), r.onCaughtError !== void 0 && (y = r.onCaughtError), r.onRecoverableError !== void 0 && (C = r.onRecoverableError), r.unstable_transitionCallbacks !== void 0 && (T = r.unstable_transitionCallbacks)), r = Lb(i, 1, false, null, null, s, c, g, y, C, T, null), i[De] = r.current, bd(i), new Nd(r);
    }, Ns.hydrateRoot = function(i, r, s) {
      if (!l(i)) throw Error(n(299));
      var c = false, g = "", y = ry, C = ay, T = ny, B = null, U = null;
      return s != null && (s.unstable_strictMode === true && (c = true), s.identifierPrefix !== void 0 && (g = s.identifierPrefix), s.onUncaughtError !== void 0 && (y = s.onUncaughtError), s.onCaughtError !== void 0 && (C = s.onCaughtError), s.onRecoverableError !== void 0 && (T = s.onRecoverableError), s.unstable_transitionCallbacks !== void 0 && (B = s.unstable_transitionCallbacks), s.formState !== void 0 && (U = s.formState)), r = Lb(i, 1, true, r, s ?? null, c, g, y, C, T, B, U), r.context = Ob(null), s = r.current, c = wi(), c = ar(c), g = sa(c), g.callback = null, oa(s, g, c), s = c, r.current.lanes = s, Gi(r, s), hr(r), i[De] = r.current, bd(i), new Ic(r);
    }, Ns.version = "19.1.1", Ns;
  }
  var Qb;
  function dA() {
    if (Qb) return qd.exports;
    Qb = 1;
    function t() {
      if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t);
      } catch (e) {
        console.error(e);
      }
    }
    return t(), qd.exports = fA(), qd.exports;
  }
  var pA = dA();
  let gA, mA, Kb;
  gA = "modulepreload";
  mA = function(t) {
    return "/" + t;
  };
  Kb = {};
  Wt = function(e, a, n) {
    let l = Promise.resolve();
    if (a && a.length > 0) {
      let d = function(f) {
        return Promise.all(f.map((p) => Promise.resolve(p).then((m) => ({
          status: "fulfilled",
          value: m
        }), (m) => ({
          status: "rejected",
          reason: m
        }))));
      };
      document.getElementsByTagName("link");
      const h = document.querySelector("meta[property=csp-nonce]"), u = (h == null ? void 0 : h.nonce) || (h == null ? void 0 : h.getAttribute("nonce"));
      l = d(a.map((f) => {
        if (f = mA(f), f in Kb) return;
        Kb[f] = true;
        const p = f.endsWith(".css"), m = p ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${f}"]${m}`)) return;
        const b = document.createElement("link");
        if (b.rel = p ? "stylesheet" : gA, p || (b.as = "script"), b.crossOrigin = "", b.href = f, u && b.setAttribute("nonce", u), document.head.appendChild(b), p) return new Promise((x, _) => {
          b.addEventListener("load", x), b.addEventListener("error", () => _(new Error(`Unable to preload CSS for ${f}`)));
        });
      }));
    }
    function o(h) {
      const u = new Event("vite:preloadError", {
        cancelable: true
      });
      if (u.payload = h, window.dispatchEvent(u), !u.defaultPrevented) throw h;
    }
    return l.then((h) => {
      for (const u of h || []) u.status === "rejected" && o(u.reason);
      return e().catch(o);
    });
  };
  let ru, yA, t1;
  Jb = {
    name: "mermaid",
    version: "11.11.0",
    description: "Markdown-ish syntax for generating flowcharts, mindmaps, sequence diagrams, class diagrams, gantt charts, git graphs and more.",
    type: "module",
    module: "./dist/mermaid.core.mjs",
    types: "./dist/mermaid.d.ts",
    exports: {
      ".": {
        types: "./dist/mermaid.d.ts",
        import: "./dist/mermaid.core.mjs",
        default: "./dist/mermaid.core.mjs"
      },
      "./*": "./*"
    },
    keywords: [
      "diagram",
      "markdown",
      "flowchart",
      "sequence diagram",
      "gantt",
      "class diagram",
      "git graph",
      "mindmap",
      "packet diagram",
      "c4 diagram",
      "er diagram",
      "pie chart",
      "pie diagram",
      "quadrant chart",
      "requirement diagram",
      "graph"
    ],
    scripts: {
      clean: "rimraf dist",
      dev: "pnpm -w dev",
      "docs:code": "typedoc src/defaultConfig.ts src/config.ts src/mermaid.ts && prettier --write ./src/docs/config/setup",
      "docs:build": "rimraf ../../docs && pnpm docs:code && pnpm docs:spellcheck && tsx scripts/docs.cli.mts",
      "docs:verify": "pnpm docs:code && pnpm docs:spellcheck && tsx scripts/docs.cli.mts --verify",
      "docs:pre:vitepress": "pnpm --filter ./src/docs prefetch && rimraf src/vitepress && pnpm docs:code && tsx scripts/docs.cli.mts --vitepress && pnpm --filter ./src/vitepress install --no-frozen-lockfile --ignore-scripts",
      "docs:build:vitepress": "pnpm docs:pre:vitepress && (cd src/vitepress && pnpm run build) && cpy --flat src/docs/landing/ ./src/vitepress/.vitepress/dist/landing",
      "docs:dev": 'pnpm docs:pre:vitepress && concurrently "pnpm --filter ./src/vitepress dev" "tsx scripts/docs.cli.mts --watch --vitepress"',
      "docs:dev:docker": 'pnpm docs:pre:vitepress && concurrently "pnpm --filter ./src/vitepress dev:docker" "tsx scripts/docs.cli.mts --watch --vitepress"',
      "docs:serve": "pnpm docs:build:vitepress && vitepress serve src/vitepress",
      "docs:spellcheck": 'cspell "src/docs/**/*.md"',
      "docs:release-version": "tsx scripts/update-release-version.mts",
      "docs:verify-version": "tsx scripts/update-release-version.mts --verify",
      "types:build-config": "tsx scripts/create-types-from-json-schema.mts",
      "types:verify-config": "tsx scripts/create-types-from-json-schema.mts --verify",
      checkCircle: "npx madge --circular ./src",
      prepublishOnly: "pnpm docs:verify-version"
    },
    repository: {
      type: "git",
      url: "https://github.com/mermaid-js/mermaid"
    },
    author: "Knut Sveidqvist",
    license: "MIT",
    standard: {
      ignore: [
        "**/parser/*.js",
        "dist/**/*.js",
        "cypress/**/*.js"
      ],
      globals: [
        "page"
      ]
    },
    dependencies: {
      "@braintree/sanitize-url": "^7.0.4",
      "@iconify/utils": "^3.0.1",
      "@mermaid-js/parser": "workspace:^",
      "@types/d3": "^7.4.3",
      cytoscape: "^3.29.3",
      "cytoscape-cose-bilkent": "^4.1.0",
      "cytoscape-fcose": "^2.2.0",
      d3: "^7.9.0",
      "d3-sankey": "^0.12.3",
      "dagre-d3-es": "7.0.11",
      dayjs: "^1.11.13",
      dompurify: "^3.2.5",
      katex: "^0.16.22",
      khroma: "^2.1.0",
      "lodash-es": "^4.17.21",
      marked: "^15.0.7",
      roughjs: "^4.6.6",
      stylis: "^4.3.6",
      "ts-dedent": "^2.2.0",
      uuid: "^11.1.0"
    },
    devDependencies: {
      "@adobe/jsonschema2md": "^8.0.2",
      "@iconify/types": "^2.0.0",
      "@types/cytoscape": "^3.21.9",
      "@types/cytoscape-fcose": "^2.2.4",
      "@types/d3-sankey": "^0.12.4",
      "@types/d3-scale": "^4.0.9",
      "@types/d3-scale-chromatic": "^3.1.0",
      "@types/d3-selection": "^3.0.11",
      "@types/d3-shape": "^3.1.7",
      "@types/jsdom": "^21.1.7",
      "@types/katex": "^0.16.7",
      "@types/lodash-es": "^4.17.12",
      "@types/micromatch": "^4.0.9",
      "@types/stylis": "^4.2.7",
      "@types/uuid": "^10.0.0",
      ajv: "^8.17.1",
      canvas: "^3.1.0",
      chokidar: "3.6.0",
      concurrently: "^9.1.2",
      "csstree-validator": "^4.0.1",
      globby: "^14.0.2",
      jison: "^0.4.18",
      "js-base64": "^3.7.7",
      jsdom: "^26.1.0",
      "json-schema-to-typescript": "^15.0.4",
      micromatch: "^4.0.8",
      "path-browserify": "^1.0.1",
      prettier: "^3.5.2",
      remark: "^15.0.1",
      "remark-frontmatter": "^5.0.0",
      "remark-gfm": "^4.0.1",
      rimraf: "^6.0.1",
      "start-server-and-test": "^2.0.10",
      "type-fest": "^4.35.0",
      typedoc: "^0.28.9",
      "typedoc-plugin-markdown": "^4.8.0",
      typescript: "~5.7.3",
      "unist-util-flatmap": "^1.0.0",
      "unist-util-visit": "^5.0.0",
      vitepress: "^1.0.2",
      "vitepress-plugin-search": "1.0.4-alpha.22"
    },
    files: [
      "dist/",
      "README.md"
    ],
    publishConfig: {
      access: "public"
    }
  };
  ru = {
    exports: {}
  };
  yA = ru.exports;
  function bA() {
    return t1 || (t1 = 1, (function(t, e) {
      (function(a, n) {
        t.exports = n();
      })(yA, (function() {
        var a = 1e3, n = 6e4, l = 36e5, o = "millisecond", h = "second", u = "minute", d = "hour", f = "day", p = "week", m = "month", b = "quarter", x = "year", _ = "date", S = "Invalid Date", w = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, k = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, A = {
          name: "en",
          weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
          months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
          ordinal: function(V) {
            var G = [
              "th",
              "st",
              "nd",
              "rd"
            ], E = V % 100;
            return "[" + V + (G[(E - 20) % 10] || G[E] || G[0]) + "]";
          }
        }, L = function(V, G, E) {
          var N = String(V);
          return !N || N.length >= G ? V : "" + Array(G + 1 - N.length).join(E) + V;
        }, $ = {
          s: L,
          z: function(V) {
            var G = -V.utcOffset(), E = Math.abs(G), N = Math.floor(E / 60), F = E % 60;
            return (G <= 0 ? "+" : "-") + L(N, 2, "0") + ":" + L(F, 2, "0");
          },
          m: function V(G, E) {
            if (G.date() < E.date()) return -V(E, G);
            var N = 12 * (E.year() - G.year()) + (E.month() - G.month()), F = G.clone().add(N, m), ot = E - F < 0, M = G.clone().add(N + (ot ? -1 : 1), m);
            return +(-(N + (E - F) / (ot ? F - M : M - F)) || 0);
          },
          a: function(V) {
            return V < 0 ? Math.ceil(V) || 0 : Math.floor(V);
          },
          p: function(V) {
            return {
              M: m,
              y: x,
              w: p,
              d: f,
              D: _,
              h: d,
              m: u,
              s: h,
              ms: o,
              Q: b
            }[V] || String(V || "").toLowerCase().replace(/s$/, "");
          },
          u: function(V) {
            return V === void 0;
          }
        }, O = "en", W = {};
        W[O] = A;
        var j = "$isDayjsObject", et = function(V) {
          return V instanceof at || !(!V || !V[j]);
        }, nt = function V(G, E, N) {
          var F;
          if (!G) return O;
          if (typeof G == "string") {
            var ot = G.toLowerCase();
            W[ot] && (F = ot), E && (W[ot] = E, F = ot);
            var M = G.split("-");
            if (!F && M.length > 1) return V(M[0]);
          } else {
            var Y = G.name;
            W[Y] = G, F = Y;
          }
          return !N && F && (O = F), F || !N && O;
        }, lt = function(V, G) {
          if (et(V)) return V.clone();
          var E = typeof G == "object" ? G : {};
          return E.date = V, E.args = arguments, new at(E);
        }, X = $;
        X.l = nt, X.i = et, X.w = function(V, G) {
          return lt(V, {
            locale: G.$L,
            utc: G.$u,
            x: G.$x,
            $offset: G.$offset
          });
        };
        var at = (function() {
          function V(E) {
            this.$L = nt(E.locale, null, true), this.parse(E), this.$x = this.$x || E.x || {}, this[j] = true;
          }
          var G = V.prototype;
          return G.parse = function(E) {
            this.$d = (function(N) {
              var F = N.date, ot = N.utc;
              if (F === null) return /* @__PURE__ */ new Date(NaN);
              if (X.u(F)) return /* @__PURE__ */ new Date();
              if (F instanceof Date) return new Date(F);
              if (typeof F == "string" && !/Z$/i.test(F)) {
                var M = F.match(w);
                if (M) {
                  var Y = M[2] - 1 || 0, K = (M[7] || "0").substring(0, 3);
                  return ot ? new Date(Date.UTC(M[1], Y, M[3] || 1, M[4] || 0, M[5] || 0, M[6] || 0, K)) : new Date(M[1], Y, M[3] || 1, M[4] || 0, M[5] || 0, M[6] || 0, K);
                }
              }
              return new Date(F);
            })(E), this.init();
          }, G.init = function() {
            var E = this.$d;
            this.$y = E.getFullYear(), this.$M = E.getMonth(), this.$D = E.getDate(), this.$W = E.getDay(), this.$H = E.getHours(), this.$m = E.getMinutes(), this.$s = E.getSeconds(), this.$ms = E.getMilliseconds();
          }, G.$utils = function() {
            return X;
          }, G.isValid = function() {
            return this.$d.toString() !== S;
          }, G.isSame = function(E, N) {
            var F = lt(E);
            return this.startOf(N) <= F && F <= this.endOf(N);
          }, G.isAfter = function(E, N) {
            return lt(E) < this.startOf(N);
          }, G.isBefore = function(E, N) {
            return this.endOf(N) < lt(E);
          }, G.$g = function(E, N, F) {
            return X.u(E) ? this[N] : this.set(F, E);
          }, G.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, G.valueOf = function() {
            return this.$d.getTime();
          }, G.startOf = function(E, N) {
            var F = this, ot = !!X.u(N) || N, M = X.p(E), Y = function(he, re) {
              var qe = X.w(F.$u ? Date.UTC(F.$y, re, he) : new Date(F.$y, re, he), F);
              return ot ? qe : qe.endOf(f);
            }, K = function(he, re) {
              return X.w(F.toDate()[he].apply(F.toDate("s"), (ot ? [
                0,
                0,
                0,
                0
              ] : [
                23,
                59,
                59,
                999
              ]).slice(re)), F);
            }, Z = this.$W, ct = this.$M, ut = this.$D, pt = "set" + (this.$u ? "UTC" : "");
            switch (M) {
              case x:
                return ot ? Y(1, 0) : Y(31, 11);
              case m:
                return ot ? Y(1, ct) : Y(0, ct + 1);
              case p:
                var Ht = this.$locale().weekStart || 0, qt = (Z < Ht ? Z + 7 : Z) - Ht;
                return Y(ot ? ut - qt : ut + (6 - qt), ct);
              case f:
              case _:
                return K(pt + "Hours", 0);
              case d:
                return K(pt + "Minutes", 1);
              case u:
                return K(pt + "Seconds", 2);
              case h:
                return K(pt + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, G.endOf = function(E) {
            return this.startOf(E, false);
          }, G.$set = function(E, N) {
            var F, ot = X.p(E), M = "set" + (this.$u ? "UTC" : ""), Y = (F = {}, F[f] = M + "Date", F[_] = M + "Date", F[m] = M + "Month", F[x] = M + "FullYear", F[d] = M + "Hours", F[u] = M + "Minutes", F[h] = M + "Seconds", F[o] = M + "Milliseconds", F)[ot], K = ot === f ? this.$D + (N - this.$W) : N;
            if (ot === m || ot === x) {
              var Z = this.clone().set(_, 1);
              Z.$d[Y](K), Z.init(), this.$d = Z.set(_, Math.min(this.$D, Z.daysInMonth())).$d;
            } else Y && this.$d[Y](K);
            return this.init(), this;
          }, G.set = function(E, N) {
            return this.clone().$set(E, N);
          }, G.get = function(E) {
            return this[X.p(E)]();
          }, G.add = function(E, N) {
            var F, ot = this;
            E = Number(E);
            var M = X.p(N), Y = function(ct) {
              var ut = lt(ot);
              return X.w(ut.date(ut.date() + Math.round(ct * E)), ot);
            };
            if (M === m) return this.set(m, this.$M + E);
            if (M === x) return this.set(x, this.$y + E);
            if (M === f) return Y(1);
            if (M === p) return Y(7);
            var K = (F = {}, F[u] = n, F[d] = l, F[h] = a, F)[M] || 1, Z = this.$d.getTime() + E * K;
            return X.w(Z, this);
          }, G.subtract = function(E, N) {
            return this.add(-1 * E, N);
          }, G.format = function(E) {
            var N = this, F = this.$locale();
            if (!this.isValid()) return F.invalidDate || S;
            var ot = E || "YYYY-MM-DDTHH:mm:ssZ", M = X.z(this), Y = this.$H, K = this.$m, Z = this.$M, ct = F.weekdays, ut = F.months, pt = F.meridiem, Ht = function(re, qe, He, mi) {
              return re && (re[qe] || re(N, ot)) || He[qe].slice(0, mi);
            }, qt = function(re) {
              return X.s(Y % 12 || 12, re, "0");
            }, he = pt || function(re, qe, He) {
              var mi = re < 12 ? "AM" : "PM";
              return He ? mi.toLowerCase() : mi;
            };
            return ot.replace(k, (function(re, qe) {
              return qe || (function(He) {
                switch (He) {
                  case "YY":
                    return String(N.$y).slice(-2);
                  case "YYYY":
                    return X.s(N.$y, 4, "0");
                  case "M":
                    return Z + 1;
                  case "MM":
                    return X.s(Z + 1, 2, "0");
                  case "MMM":
                    return Ht(F.monthsShort, Z, ut, 3);
                  case "MMMM":
                    return Ht(ut, Z);
                  case "D":
                    return N.$D;
                  case "DD":
                    return X.s(N.$D, 2, "0");
                  case "d":
                    return String(N.$W);
                  case "dd":
                    return Ht(F.weekdaysMin, N.$W, ct, 2);
                  case "ddd":
                    return Ht(F.weekdaysShort, N.$W, ct, 3);
                  case "dddd":
                    return ct[N.$W];
                  case "H":
                    return String(Y);
                  case "HH":
                    return X.s(Y, 2, "0");
                  case "h":
                    return qt(1);
                  case "hh":
                    return qt(2);
                  case "a":
                    return he(Y, K, true);
                  case "A":
                    return he(Y, K, false);
                  case "m":
                    return String(K);
                  case "mm":
                    return X.s(K, 2, "0");
                  case "s":
                    return String(N.$s);
                  case "ss":
                    return X.s(N.$s, 2, "0");
                  case "SSS":
                    return X.s(N.$ms, 3, "0");
                  case "Z":
                    return M;
                }
                return null;
              })(re) || M.replace(":", "");
            }));
          }, G.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, G.diff = function(E, N, F) {
            var ot, M = this, Y = X.p(N), K = lt(E), Z = (K.utcOffset() - this.utcOffset()) * n, ct = this - K, ut = function() {
              return X.m(M, K);
            };
            switch (Y) {
              case x:
                ot = ut() / 12;
                break;
              case m:
                ot = ut();
                break;
              case b:
                ot = ut() / 3;
                break;
              case p:
                ot = (ct - Z) / 6048e5;
                break;
              case f:
                ot = (ct - Z) / 864e5;
                break;
              case d:
                ot = ct / l;
                break;
              case u:
                ot = ct / n;
                break;
              case h:
                ot = ct / a;
                break;
              default:
                ot = ct;
            }
            return F ? ot : X.a(ot);
          }, G.daysInMonth = function() {
            return this.endOf(m).$D;
          }, G.$locale = function() {
            return W[this.$L];
          }, G.locale = function(E, N) {
            if (!E) return this.$L;
            var F = this.clone(), ot = nt(E, N, true);
            return ot && (F.$L = ot), F;
          }, G.clone = function() {
            return X.w(this.$d, this);
          }, G.toDate = function() {
            return new Date(this.valueOf());
          }, G.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, G.toISOString = function() {
            return this.$d.toISOString();
          }, G.toString = function() {
            return this.$d.toUTCString();
          }, V;
        })(), rt = at.prototype;
        return lt.prototype = rt, [
          [
            "$ms",
            o
          ],
          [
            "$s",
            h
          ],
          [
            "$m",
            u
          ],
          [
            "$H",
            d
          ],
          [
            "$W",
            f
          ],
          [
            "$M",
            m
          ],
          [
            "$y",
            x
          ],
          [
            "$D",
            _
          ]
        ].forEach((function(V) {
          rt[V[1]] = function(G) {
            return this.$g(G, V[0], V[1]);
          };
        })), lt.extend = function(V, G) {
          return V.$i || (V(G, at, lt), V.$i = true), lt;
        }, lt.locale = nt, lt.isDayjs = et, lt.unix = function(V) {
          return lt(1e3 * V);
        }, lt.en = W[O], lt.Ls = W, lt.p = {}, lt;
      }));
    })(ru)), ru.exports;
  }
  var xA = bA();
  vA = aA(xA);
  let Dx, Ur, og, qi;
  Dx = Object.defineProperty;
  v = (t, e) => Dx(t, "name", {
    value: e,
    configurable: true
  });
  _A = (t, e) => {
    for (var a in e) Dx(t, a, {
      get: e[a],
      enumerable: true
    });
  };
  Ur = {
    trace: 0,
    debug: 1,
    info: 2,
    warn: 3,
    error: 4,
    fatal: 5
  };
  it = {
    trace: v((...t) => {
    }, "trace"),
    debug: v((...t) => {
    }, "debug"),
    info: v((...t) => {
    }, "info"),
    warn: v((...t) => {
    }, "warn"),
    error: v((...t) => {
    }, "error"),
    fatal: v((...t) => {
    }, "fatal")
  };
  og = v(function(t = "fatal") {
    let e = Ur.fatal;
    typeof t == "string" ? t.toLowerCase() in Ur && (e = Ur[t]) : typeof t == "number" && (e = t), it.trace = () => {
    }, it.debug = () => {
    }, it.info = () => {
    }, it.warn = () => {
    }, it.error = () => {
    }, it.fatal = () => {
    }, e <= Ur.fatal && (it.fatal = console.error ? console.error.bind(console, qi("FATAL"), "color: orange") : console.log.bind(console, "\x1B[35m", qi("FATAL"))), e <= Ur.error && (it.error = console.error ? console.error.bind(console, qi("ERROR"), "color: orange") : console.log.bind(console, "\x1B[31m", qi("ERROR"))), e <= Ur.warn && (it.warn = console.warn ? console.warn.bind(console, qi("WARN"), "color: orange") : console.log.bind(console, "\x1B[33m", qi("WARN"))), e <= Ur.info && (it.info = console.info ? console.info.bind(console, qi("INFO"), "color: lightblue") : console.log.bind(console, "\x1B[34m", qi("INFO"))), e <= Ur.debug && (it.debug = console.debug ? console.debug.bind(console, qi("DEBUG"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", qi("DEBUG"))), e <= Ur.trace && (it.trace = console.debug ? console.debug.bind(console, qi("TRACE"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", qi("TRACE")));
  }, "setLogLevel");
  qi = v((t) => `%c${vA().format("ss.SSS")} : ${t} : `, "format");
  let au, SA, CA, ka;
  au = {
    min: {
      r: 0,
      g: 0,
      b: 0,
      s: 0,
      l: 0,
      a: 0
    },
    max: {
      r: 255,
      g: 255,
      b: 255,
      h: 360,
      s: 100,
      l: 100,
      a: 1
    },
    clamp: {
      r: (t) => t >= 255 ? 255 : t < 0 ? 0 : t,
      g: (t) => t >= 255 ? 255 : t < 0 ? 0 : t,
      b: (t) => t >= 255 ? 255 : t < 0 ? 0 : t,
      h: (t) => t % 360,
      s: (t) => t >= 100 ? 100 : t < 0 ? 0 : t,
      l: (t) => t >= 100 ? 100 : t < 0 ? 0 : t,
      a: (t) => t >= 1 ? 1 : t < 0 ? 0 : t
    },
    toLinear: (t) => {
      const e = t / 255;
      return t > 0.03928 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92;
    },
    hue2rgb: (t, e, a) => (a < 0 && (a += 1), a > 1 && (a -= 1), a < 1 / 6 ? t + (e - t) * 6 * a : a < 1 / 2 ? e : a < 2 / 3 ? t + (e - t) * (2 / 3 - a) * 6 : t),
    hsl2rgb: ({ h: t, s: e, l: a }, n) => {
      if (!e) return a * 2.55;
      t /= 360, e /= 100, a /= 100;
      const l = a < 0.5 ? a * (1 + e) : a + e - a * e, o = 2 * a - l;
      switch (n) {
        case "r":
          return au.hue2rgb(o, l, t + 1 / 3) * 255;
        case "g":
          return au.hue2rgb(o, l, t) * 255;
        case "b":
          return au.hue2rgb(o, l, t - 1 / 3) * 255;
      }
    },
    rgb2hsl: ({ r: t, g: e, b: a }, n) => {
      t /= 255, e /= 255, a /= 255;
      const l = Math.max(t, e, a), o = Math.min(t, e, a), h = (l + o) / 2;
      if (n === "l") return h * 100;
      if (l === o) return 0;
      const u = l - o, d = h > 0.5 ? u / (2 - l - o) : u / (l + o);
      if (n === "s") return d * 100;
      switch (l) {
        case t:
          return ((e - a) / u + (e < a ? 6 : 0)) * 60;
        case e:
          return ((a - t) / u + 2) * 60;
        case a:
          return ((t - e) / u + 4) * 60;
        default:
          return -1;
      }
    }
  };
  SA = {
    clamp: (t, e, a) => e > a ? Math.min(e, Math.max(a, t)) : Math.min(a, Math.max(e, t)),
    round: (t) => Math.round(t * 1e10) / 1e10
  };
  CA = {
    dec2hex: (t) => {
      const e = Math.round(t).toString(16);
      return e.length > 1 ? e : `0${e}`;
    }
  };
  Lt = {
    channel: au,
    lang: SA,
    unit: CA
  };
  ka = {};
  for (let t = 0; t <= 255; t++) ka[t] = Lt.unit.dec2hex(t);
  const We = {
    ALL: 0,
    RGB: 1,
    HSL: 2
  };
  class wA {
    constructor() {
      this.type = We.ALL;
    }
    get() {
      return this.type;
    }
    set(e) {
      if (this.type && this.type !== e) throw new Error("Cannot change both RGB and HSL channels at the same time");
      this.type = e;
    }
    reset() {
      this.type = We.ALL;
    }
    is(e) {
      return this.type === e;
    }
  }
  class TA {
    constructor(e, a) {
      this.color = a, this.changed = false, this.data = e, this.type = new wA();
    }
    set(e, a) {
      return this.color = a, this.changed = false, this.data = e, this.type.type = We.ALL, this;
    }
    _ensureHSL() {
      const e = this.data, { h: a, s: n, l } = e;
      a === void 0 && (e.h = Lt.channel.rgb2hsl(e, "h")), n === void 0 && (e.s = Lt.channel.rgb2hsl(e, "s")), l === void 0 && (e.l = Lt.channel.rgb2hsl(e, "l"));
    }
    _ensureRGB() {
      const e = this.data, { r: a, g: n, b: l } = e;
      a === void 0 && (e.r = Lt.channel.hsl2rgb(e, "r")), n === void 0 && (e.g = Lt.channel.hsl2rgb(e, "g")), l === void 0 && (e.b = Lt.channel.hsl2rgb(e, "b"));
    }
    get r() {
      const e = this.data, a = e.r;
      return !this.type.is(We.HSL) && a !== void 0 ? a : (this._ensureHSL(), Lt.channel.hsl2rgb(e, "r"));
    }
    get g() {
      const e = this.data, a = e.g;
      return !this.type.is(We.HSL) && a !== void 0 ? a : (this._ensureHSL(), Lt.channel.hsl2rgb(e, "g"));
    }
    get b() {
      const e = this.data, a = e.b;
      return !this.type.is(We.HSL) && a !== void 0 ? a : (this._ensureHSL(), Lt.channel.hsl2rgb(e, "b"));
    }
    get h() {
      const e = this.data, a = e.h;
      return !this.type.is(We.RGB) && a !== void 0 ? a : (this._ensureRGB(), Lt.channel.rgb2hsl(e, "h"));
    }
    get s() {
      const e = this.data, a = e.s;
      return !this.type.is(We.RGB) && a !== void 0 ? a : (this._ensureRGB(), Lt.channel.rgb2hsl(e, "s"));
    }
    get l() {
      const e = this.data, a = e.l;
      return !this.type.is(We.RGB) && a !== void 0 ? a : (this._ensureRGB(), Lt.channel.rgb2hsl(e, "l"));
    }
    get a() {
      return this.data.a;
    }
    set r(e) {
      this.type.set(We.RGB), this.changed = true, this.data.r = e;
    }
    set g(e) {
      this.type.set(We.RGB), this.changed = true, this.data.g = e;
    }
    set b(e) {
      this.type.set(We.RGB), this.changed = true, this.data.b = e;
    }
    set h(e) {
      this.type.set(We.HSL), this.changed = true, this.data.h = e;
    }
    set s(e) {
      this.type.set(We.HSL), this.changed = true, this.data.s = e;
    }
    set l(e) {
      this.type.set(We.HSL), this.changed = true, this.data.l = e;
    }
    set a(e) {
      this.changed = true, this.data.a = e;
    }
  }
  let eh, ml, un, ao, Zs, Rx, kA, AA, $x, q, EA, ht;
  eh = new TA({
    r: 0,
    g: 0,
    b: 0,
    a: 0
  }, "transparent");
  ml = {
    re: /^#((?:[a-f0-9]{2}){2,4}|[a-f0-9]{3})$/i,
    parse: (t) => {
      if (t.charCodeAt(0) !== 35) return;
      const e = t.match(ml.re);
      if (!e) return;
      const a = e[1], n = parseInt(a, 16), l = a.length, o = l % 4 === 0, h = l > 4, u = h ? 1 : 17, d = h ? 8 : 4, f = o ? 0 : -1, p = h ? 255 : 15;
      return eh.set({
        r: (n >> d * (f + 3) & p) * u,
        g: (n >> d * (f + 2) & p) * u,
        b: (n >> d * (f + 1) & p) * u,
        a: o ? (n & p) * u / 255 : 1
      }, t);
    },
    stringify: (t) => {
      const { r: e, g: a, b: n, a: l } = t;
      return l < 1 ? `#${ka[Math.round(e)]}${ka[Math.round(a)]}${ka[Math.round(n)]}${ka[Math.round(l * 255)]}` : `#${ka[Math.round(e)]}${ka[Math.round(a)]}${ka[Math.round(n)]}`;
    }
  };
  un = {
    re: /^hsla?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(?:deg|grad|rad|turn)?)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(%)?))?\s*?\)$/i,
    hueRe: /^(.+?)(deg|grad|rad|turn)$/i,
    _hue2deg: (t) => {
      const e = t.match(un.hueRe);
      if (e) {
        const [, a, n] = e;
        switch (n) {
          case "grad":
            return Lt.channel.clamp.h(parseFloat(a) * 0.9);
          case "rad":
            return Lt.channel.clamp.h(parseFloat(a) * 180 / Math.PI);
          case "turn":
            return Lt.channel.clamp.h(parseFloat(a) * 360);
        }
      }
      return Lt.channel.clamp.h(parseFloat(t));
    },
    parse: (t) => {
      const e = t.charCodeAt(0);
      if (e !== 104 && e !== 72) return;
      const a = t.match(un.re);
      if (!a) return;
      const [, n, l, o, h, u] = a;
      return eh.set({
        h: un._hue2deg(n),
        s: Lt.channel.clamp.s(parseFloat(l)),
        l: Lt.channel.clamp.l(parseFloat(o)),
        a: h ? Lt.channel.clamp.a(u ? parseFloat(h) / 100 : parseFloat(h)) : 1
      }, t);
    },
    stringify: (t) => {
      const { h: e, s: a, l: n, a: l } = t;
      return l < 1 ? `hsla(${Lt.lang.round(e)}, ${Lt.lang.round(a)}%, ${Lt.lang.round(n)}%, ${l})` : `hsl(${Lt.lang.round(e)}, ${Lt.lang.round(a)}%, ${Lt.lang.round(n)}%)`;
    }
  };
  ao = {
    colors: {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyanaqua: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      lavender: "#e6e6fa",
      lavenderblush: "#fff0f5",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrodyellow: "#fafad2",
      lightgray: "#d3d3d3",
      lightgreen: "#90ee90",
      lightgrey: "#d3d3d3",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      rebeccapurple: "#663399",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      transparent: "#00000000",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32"
    },
    parse: (t) => {
      t = t.toLowerCase();
      const e = ao.colors[t];
      if (e) return ml.parse(e);
    },
    stringify: (t) => {
      const e = ml.stringify(t);
      for (const a in ao.colors) if (ao.colors[a] === e) return a;
    }
  };
  Zs = {
    re: /^rgba?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?)))?\s*?\)$/i,
    parse: (t) => {
      const e = t.charCodeAt(0);
      if (e !== 114 && e !== 82) return;
      const a = t.match(Zs.re);
      if (!a) return;
      const [, n, l, o, h, u, d, f, p] = a;
      return eh.set({
        r: Lt.channel.clamp.r(l ? parseFloat(n) * 2.55 : parseFloat(n)),
        g: Lt.channel.clamp.g(h ? parseFloat(o) * 2.55 : parseFloat(o)),
        b: Lt.channel.clamp.b(d ? parseFloat(u) * 2.55 : parseFloat(u)),
        a: f ? Lt.channel.clamp.a(p ? parseFloat(f) / 100 : parseFloat(f)) : 1
      }, t);
    },
    stringify: (t) => {
      const { r: e, g: a, b: n, a: l } = t;
      return l < 1 ? `rgba(${Lt.lang.round(e)}, ${Lt.lang.round(a)}, ${Lt.lang.round(n)}, ${Lt.lang.round(l)})` : `rgb(${Lt.lang.round(e)}, ${Lt.lang.round(a)}, ${Lt.lang.round(n)})`;
    }
  };
  yr = {
    format: {
      keyword: ao,
      hex: ml,
      rgb: Zs,
      rgba: Zs,
      hsl: un,
      hsla: un
    },
    parse: (t) => {
      if (typeof t != "string") return t;
      const e = ml.parse(t) || Zs.parse(t) || un.parse(t) || ao.parse(t);
      if (e) return e;
      throw new Error(`Unsupported color format: "${t}"`);
    },
    stringify: (t) => !t.changed && t.color ? t.color : t.type.is(We.HSL) || t.data.r === void 0 ? un.stringify(t) : t.a < 1 || !Number.isInteger(t.r) || !Number.isInteger(t.g) || !Number.isInteger(t.b) ? Zs.stringify(t) : ml.stringify(t)
  };
  Rx = (t, e) => {
    const a = yr.parse(t);
    for (const n in e) a[n] = Lt.channel.clamp[n](e[n]);
    return yr.stringify(a);
  };
  no = (t, e, a = 0, n = 1) => {
    if (typeof t != "number") return Rx(t, {
      a: e
    });
    const l = eh.set({
      r: Lt.channel.clamp.r(t),
      g: Lt.channel.clamp.g(e),
      b: Lt.channel.clamp.b(a),
      a: Lt.channel.clamp.a(n)
    });
    return yr.stringify(l);
  };
  kA = (t) => {
    const { r: e, g: a, b: n } = yr.parse(t), l = 0.2126 * Lt.channel.toLinear(e) + 0.7152 * Lt.channel.toLinear(a) + 0.0722 * Lt.channel.toLinear(n);
    return Lt.lang.round(l);
  };
  AA = (t) => kA(t) >= 0.5;
  wo = (t) => !AA(t);
  $x = (t, e, a) => {
    const n = yr.parse(t), l = n[e], o = Lt.channel.clamp[e](l + a);
    return l !== o && (n[e] = o), yr.stringify(n);
  };
  mt = (t, e) => $x(t, "l", e);
  wt = (t, e) => $x(t, "l", -e);
  q = (t, e) => {
    const a = yr.parse(t), n = {};
    for (const l in e) e[l] && (n[l] = a[l] + e[l]);
    return Rx(t, n);
  };
  EA = (t, e, a = 50) => {
    const { r: n, g: l, b: o, a: h } = yr.parse(t), { r: u, g: d, b: f, a: p } = yr.parse(e), m = a / 100, b = m * 2 - 1, x = h - p, S = ((b * x === -1 ? b : (b + x) / (1 + b * x)) + 1) / 2, w = 1 - S, k = n * S + u * w, A = l * S + d * w, L = o * S + f * w, $ = h * m + p * (1 - m);
    return no(k, A, L, $);
  };
  ht = (t, e = 100) => {
    const a = yr.parse(t);
    return a.r = 255 - a.r, a.g = 255 - a.g, a.b = 255 - a.b, EA(a, t, e);
  };
  const { entries: Nx, setPrototypeOf: e1, isFrozen: MA, getPrototypeOf: BA, getOwnPropertyDescriptor: LA } = Object;
  let { freeze: ri, seal: Ui, create: zx } = Object, { apply: up, construct: hp } = typeof Reflect < "u" && Reflect;
  ri || (ri = function(e) {
    return e;
  });
  Ui || (Ui = function(e) {
    return e;
  });
  up || (up = function(e, a, n) {
    return e.apply(a, n);
  });
  hp || (hp = function(e, a) {
    return new e(...a);
  });
  const Gc = ai(Array.prototype.forEach), OA = ai(Array.prototype.lastIndexOf), i1 = ai(Array.prototype.pop), zs = ai(Array.prototype.push), DA = ai(Array.prototype.splice), nu = ai(String.prototype.toLowerCase), Yd = ai(String.prototype.toString), r1 = ai(String.prototype.match), Fs = ai(String.prototype.replace), RA = ai(String.prototype.indexOf), $A = ai(String.prototype.trim), Ki = ai(Object.prototype.hasOwnProperty), Je = ai(RegExp.prototype.test), qs = NA(TypeError);
  function ai(t) {
    return function(e) {
      e instanceof RegExp && (e.lastIndex = 0);
      for (var a = arguments.length, n = new Array(a > 1 ? a - 1 : 0), l = 1; l < a; l++) n[l - 1] = arguments[l];
      return up(t, e, n);
    };
  }
  function NA(t) {
    return function() {
      for (var e = arguments.length, a = new Array(e), n = 0; n < e; n++) a[n] = arguments[n];
      return hp(t, a);
    };
  }
  function zt(t, e) {
    let a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : nu;
    e1 && e1(t, null);
    let n = e.length;
    for (; n--; ) {
      let l = e[n];
      if (typeof l == "string") {
        const o = a(l);
        o !== l && (MA(e) || (e[n] = o), l = o);
      }
      t[l] = true;
    }
    return t;
  }
  function zA(t) {
    for (let e = 0; e < t.length; e++) Ki(t, e) || (t[e] = null);
    return t;
  }
  function Yr(t) {
    const e = zx(null);
    for (const [a, n] of Nx(t)) Ki(t, a) && (Array.isArray(n) ? e[a] = zA(n) : n && typeof n == "object" && n.constructor === Object ? e[a] = Yr(n) : e[a] = n);
    return e;
  }
  function Hs(t, e) {
    for (; t !== null; ) {
      const n = LA(t, e);
      if (n) {
        if (n.get) return ai(n.get);
        if (typeof n.value == "function") return ai(n.value);
      }
      t = BA(t);
    }
    function a() {
      return null;
    }
    return a;
  }
  const a1 = ri([
    "a",
    "abbr",
    "acronym",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "bdi",
    "bdo",
    "big",
    "blink",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "center",
    "cite",
    "code",
    "col",
    "colgroup",
    "content",
    "data",
    "datalist",
    "dd",
    "decorator",
    "del",
    "details",
    "dfn",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "element",
    "em",
    "fieldset",
    "figcaption",
    "figure",
    "font",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "img",
    "input",
    "ins",
    "kbd",
    "label",
    "legend",
    "li",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meter",
    "nav",
    "nobr",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "section",
    "select",
    "shadow",
    "small",
    "source",
    "spacer",
    "span",
    "strike",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "template",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "tr",
    "track",
    "tt",
    "u",
    "ul",
    "var",
    "video",
    "wbr"
  ]), Id = ri([
    "svg",
    "a",
    "altglyph",
    "altglyphdef",
    "altglyphitem",
    "animatecolor",
    "animatemotion",
    "animatetransform",
    "circle",
    "clippath",
    "defs",
    "desc",
    "ellipse",
    "filter",
    "font",
    "g",
    "glyph",
    "glyphref",
    "hkern",
    "image",
    "line",
    "lineargradient",
    "marker",
    "mask",
    "metadata",
    "mpath",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialgradient",
    "rect",
    "stop",
    "style",
    "switch",
    "symbol",
    "text",
    "textpath",
    "title",
    "tref",
    "tspan",
    "view",
    "vkern"
  ]), Pd = ri([
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence"
  ]), FA = ri([
    "animate",
    "color-profile",
    "cursor",
    "discard",
    "font-face",
    "font-face-format",
    "font-face-name",
    "font-face-src",
    "font-face-uri",
    "foreignobject",
    "hatch",
    "hatchpath",
    "mesh",
    "meshgradient",
    "meshpatch",
    "meshrow",
    "missing-glyph",
    "script",
    "set",
    "solidcolor",
    "unknown",
    "use"
  ]), Gd = ri([
    "math",
    "menclose",
    "merror",
    "mfenced",
    "mfrac",
    "mglyph",
    "mi",
    "mlabeledtr",
    "mmultiscripts",
    "mn",
    "mo",
    "mover",
    "mpadded",
    "mphantom",
    "mroot",
    "mrow",
    "ms",
    "mspace",
    "msqrt",
    "mstyle",
    "msub",
    "msup",
    "msubsup",
    "mtable",
    "mtd",
    "mtext",
    "mtr",
    "munder",
    "munderover",
    "mprescripts"
  ]), qA = ri([
    "maction",
    "maligngroup",
    "malignmark",
    "mlongdiv",
    "mscarries",
    "mscarry",
    "msgroup",
    "mstack",
    "msline",
    "msrow",
    "semantics",
    "annotation",
    "annotation-xml",
    "mprescripts",
    "none"
  ]), n1 = ri([
    "#text"
  ]), l1 = ri([
    "accept",
    "action",
    "align",
    "alt",
    "autocapitalize",
    "autocomplete",
    "autopictureinpicture",
    "autoplay",
    "background",
    "bgcolor",
    "border",
    "capture",
    "cellpadding",
    "cellspacing",
    "checked",
    "cite",
    "class",
    "clear",
    "color",
    "cols",
    "colspan",
    "controls",
    "controlslist",
    "coords",
    "crossorigin",
    "datetime",
    "decoding",
    "default",
    "dir",
    "disabled",
    "disablepictureinpicture",
    "disableremoteplayback",
    "download",
    "draggable",
    "enctype",
    "enterkeyhint",
    "face",
    "for",
    "headers",
    "height",
    "hidden",
    "high",
    "href",
    "hreflang",
    "id",
    "inputmode",
    "integrity",
    "ismap",
    "kind",
    "label",
    "lang",
    "list",
    "loading",
    "loop",
    "low",
    "max",
    "maxlength",
    "media",
    "method",
    "min",
    "minlength",
    "multiple",
    "muted",
    "name",
    "nonce",
    "noshade",
    "novalidate",
    "nowrap",
    "open",
    "optimum",
    "pattern",
    "placeholder",
    "playsinline",
    "popover",
    "popovertarget",
    "popovertargetaction",
    "poster",
    "preload",
    "pubdate",
    "radiogroup",
    "readonly",
    "rel",
    "required",
    "rev",
    "reversed",
    "role",
    "rows",
    "rowspan",
    "spellcheck",
    "scope",
    "selected",
    "shape",
    "size",
    "sizes",
    "span",
    "srclang",
    "start",
    "src",
    "srcset",
    "step",
    "style",
    "summary",
    "tabindex",
    "title",
    "translate",
    "type",
    "usemap",
    "valign",
    "value",
    "width",
    "wrap",
    "xmlns",
    "slot"
  ]), Wd = ri([
    "accent-height",
    "accumulate",
    "additive",
    "alignment-baseline",
    "amplitude",
    "ascent",
    "attributename",
    "attributetype",
    "azimuth",
    "basefrequency",
    "baseline-shift",
    "begin",
    "bias",
    "by",
    "class",
    "clip",
    "clippathunits",
    "clip-path",
    "clip-rule",
    "color",
    "color-interpolation",
    "color-interpolation-filters",
    "color-profile",
    "color-rendering",
    "cx",
    "cy",
    "d",
    "dx",
    "dy",
    "diffuseconstant",
    "direction",
    "display",
    "divisor",
    "dur",
    "edgemode",
    "elevation",
    "end",
    "exponent",
    "fill",
    "fill-opacity",
    "fill-rule",
    "filter",
    "filterunits",
    "flood-color",
    "flood-opacity",
    "font-family",
    "font-size",
    "font-size-adjust",
    "font-stretch",
    "font-style",
    "font-variant",
    "font-weight",
    "fx",
    "fy",
    "g1",
    "g2",
    "glyph-name",
    "glyphref",
    "gradientunits",
    "gradienttransform",
    "height",
    "href",
    "id",
    "image-rendering",
    "in",
    "in2",
    "intercept",
    "k",
    "k1",
    "k2",
    "k3",
    "k4",
    "kerning",
    "keypoints",
    "keysplines",
    "keytimes",
    "lang",
    "lengthadjust",
    "letter-spacing",
    "kernelmatrix",
    "kernelunitlength",
    "lighting-color",
    "local",
    "marker-end",
    "marker-mid",
    "marker-start",
    "markerheight",
    "markerunits",
    "markerwidth",
    "maskcontentunits",
    "maskunits",
    "max",
    "mask",
    "media",
    "method",
    "mode",
    "min",
    "name",
    "numoctaves",
    "offset",
    "operator",
    "opacity",
    "order",
    "orient",
    "orientation",
    "origin",
    "overflow",
    "paint-order",
    "path",
    "pathlength",
    "patterncontentunits",
    "patterntransform",
    "patternunits",
    "points",
    "preservealpha",
    "preserveaspectratio",
    "primitiveunits",
    "r",
    "rx",
    "ry",
    "radius",
    "refx",
    "refy",
    "repeatcount",
    "repeatdur",
    "restart",
    "result",
    "rotate",
    "scale",
    "seed",
    "shape-rendering",
    "slope",
    "specularconstant",
    "specularexponent",
    "spreadmethod",
    "startoffset",
    "stddeviation",
    "stitchtiles",
    "stop-color",
    "stop-opacity",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke",
    "stroke-width",
    "style",
    "surfacescale",
    "systemlanguage",
    "tabindex",
    "tablevalues",
    "targetx",
    "targety",
    "transform",
    "transform-origin",
    "text-anchor",
    "text-decoration",
    "text-rendering",
    "textlength",
    "type",
    "u1",
    "u2",
    "unicode",
    "values",
    "viewbox",
    "visibility",
    "version",
    "vert-adv-y",
    "vert-origin-x",
    "vert-origin-y",
    "width",
    "word-spacing",
    "wrap",
    "writing-mode",
    "xchannelselector",
    "ychannelselector",
    "x",
    "x1",
    "x2",
    "xmlns",
    "y",
    "y1",
    "y2",
    "z",
    "zoomandpan"
  ]), s1 = ri([
    "accent",
    "accentunder",
    "align",
    "bevelled",
    "close",
    "columnsalign",
    "columnlines",
    "columnspan",
    "denomalign",
    "depth",
    "dir",
    "display",
    "displaystyle",
    "encoding",
    "fence",
    "frame",
    "height",
    "href",
    "id",
    "largeop",
    "length",
    "linethickness",
    "lspace",
    "lquote",
    "mathbackground",
    "mathcolor",
    "mathsize",
    "mathvariant",
    "maxsize",
    "minsize",
    "movablelimits",
    "notation",
    "numalign",
    "open",
    "rowalign",
    "rowlines",
    "rowspacing",
    "rowspan",
    "rspace",
    "rquote",
    "scriptlevel",
    "scriptminsize",
    "scriptsizemultiplier",
    "selection",
    "separator",
    "separators",
    "stretchy",
    "subscriptshift",
    "supscriptshift",
    "symmetric",
    "voffset",
    "width",
    "xmlns"
  ]), Wc = ri([
    "xlink:href",
    "xml:id",
    "xlink:title",
    "xml:space",
    "xmlns:xlink"
  ]), HA = Ui(/\{\{[\w\W]*|[\w\W]*\}\}/gm), UA = Ui(/<%[\w\W]*|[\w\W]*%>/gm), jA = Ui(/\$\{[\w\W]*/gm), YA = Ui(/^data-[\-\w.\u00B7-\uFFFF]+$/), IA = Ui(/^aria-[\-\w]+$/), Fx = Ui(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i), PA = Ui(/^(?:\w+script|data):/i), GA = Ui(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g), qx = Ui(/^html$/i), WA = Ui(/^[a-z][.\w]*(-[.\w]+)+$/i);
  var o1 = Object.freeze({
    __proto__: null,
    ARIA_ATTR: IA,
    ATTR_WHITESPACE: GA,
    CUSTOM_ELEMENT: WA,
    DATA_ATTR: YA,
    DOCTYPE_NAME: qx,
    ERB_EXPR: UA,
    IS_ALLOWED_URI: Fx,
    IS_SCRIPT_OR_DATA: PA,
    MUSTACHE_EXPR: HA,
    TMPLIT_EXPR: jA
  });
  const Us = {
    element: 1,
    text: 3,
    progressingInstruction: 7,
    comment: 8,
    document: 9
  }, XA = function() {
    return typeof window > "u" ? null : window;
  }, VA = function(e, a) {
    if (typeof e != "object" || typeof e.createPolicy != "function") return null;
    let n = null;
    const l = "data-tt-policy-suffix";
    a && a.hasAttribute(l) && (n = a.getAttribute(l));
    const o = "dompurify" + (n ? "#" + n : "");
    try {
      return e.createPolicy(o, {
        createHTML(h) {
          return h;
        },
        createScriptURL(h) {
          return h;
        }
      });
    } catch {
      return console.warn("TrustedTypes policy " + o + " could not be created."), null;
    }
  }, c1 = function() {
    return {
      afterSanitizeAttributes: [],
      afterSanitizeElements: [],
      afterSanitizeShadowDOM: [],
      beforeSanitizeAttributes: [],
      beforeSanitizeElements: [],
      beforeSanitizeShadowDOM: [],
      uponSanitizeAttribute: [],
      uponSanitizeElement: [],
      uponSanitizeShadowNode: []
    };
  };
  function Hx() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : XA();
    const e = (_t) => Hx(_t);
    if (e.version = "3.2.6", e.removed = [], !t || !t.document || t.document.nodeType !== Us.document || !t.Element) return e.isSupported = false, e;
    let { document: a } = t;
    const n = a, l = n.currentScript, { DocumentFragment: o, HTMLTemplateElement: h, Node: u, Element: d, NodeFilter: f, NamedNodeMap: p = t.NamedNodeMap || t.MozNamedAttrMap, HTMLFormElement: m, DOMParser: b, trustedTypes: x } = t, _ = d.prototype, S = Hs(_, "cloneNode"), w = Hs(_, "remove"), k = Hs(_, "nextSibling"), A = Hs(_, "childNodes"), L = Hs(_, "parentNode");
    if (typeof h == "function") {
      const _t = a.createElement("template");
      _t.content && _t.content.ownerDocument && (a = _t.content.ownerDocument);
    }
    let $, O = "";
    const { implementation: W, createNodeIterator: j, createDocumentFragment: et, getElementsByTagName: nt } = a, { importNode: lt } = n;
    let X = c1();
    e.isSupported = typeof Nx == "function" && typeof L == "function" && W && W.createHTMLDocument !== void 0;
    const { MUSTACHE_EXPR: at, ERB_EXPR: rt, TMPLIT_EXPR: V, DATA_ATTR: G, ARIA_ATTR: E, IS_SCRIPT_OR_DATA: N, ATTR_WHITESPACE: F, CUSTOM_ELEMENT: ot } = o1;
    let { IS_ALLOWED_URI: M } = o1, Y = null;
    const K = zt({}, [
      ...a1,
      ...Id,
      ...Pd,
      ...Gd,
      ...n1
    ]);
    let Z = null;
    const ct = zt({}, [
      ...l1,
      ...Wd,
      ...s1,
      ...Wc
    ]);
    let ut = Object.seal(zx(null, {
      tagNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      attributeNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: false
      }
    })), pt = null, Ht = null, qt = true, he = true, re = false, qe = true, He = false, mi = true, Ii = false, Rl = false, $l = false, Oe = false, En = false, Fa = false, Nl = true, qa = false;
    const Eh = "user-content-";
    let Mn = true, Ha = false, ta = {}, Mi = null;
    const Ue = zt({}, [
      "annotation-xml",
      "audio",
      "colgroup",
      "desc",
      "foreignobject",
      "head",
      "iframe",
      "math",
      "mi",
      "mn",
      "mo",
      "ms",
      "mtext",
      "noembed",
      "noframes",
      "noscript",
      "plaintext",
      "script",
      "style",
      "svg",
      "template",
      "thead",
      "title",
      "video",
      "xmp"
    ]);
    let Pi = null;
    const je = zt({}, [
      "audio",
      "video",
      "img",
      "source",
      "image",
      "track"
    ]);
    let zl = null;
    const Ro = zt({}, [
      "alt",
      "class",
      "for",
      "id",
      "label",
      "name",
      "pattern",
      "placeholder",
      "role",
      "summary",
      "title",
      "value",
      "style",
      "xmlns"
    ]), Bn = "http://www.w3.org/1998/Math/MathML", _r = "http://www.w3.org/2000/svg", ni = "http://www.w3.org/1999/xhtml";
    let li = ni, ea = false, Sr = null;
    const Mh = zt({}, [
      Bn,
      _r,
      ni
    ], Yd);
    let Ua = zt({}, [
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext"
    ]), ja = zt({}, [
      "annotation-xml"
    ]);
    const Fl = zt({}, [
      "title",
      "style",
      "font",
      "a",
      "script"
    ]);
    let Gi = null;
    const Bh = [
      "application/xhtml+xml",
      "text/html"
    ], $o = "text/html";
    let fe = null, ar = null;
    const ql = a.createElement("form"), Hl = function(R) {
      return R instanceof RegExp || R instanceof Function;
    }, Ul = function() {
      let R = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!(ar && ar === R)) {
        if ((!R || typeof R != "object") && (R = {}), R = Yr(R), Gi = Bh.indexOf(R.PARSER_MEDIA_TYPE) === -1 ? $o : R.PARSER_MEDIA_TYPE, fe = Gi === "application/xhtml+xml" ? Yd : nu, Y = Ki(R, "ALLOWED_TAGS") ? zt({}, R.ALLOWED_TAGS, fe) : K, Z = Ki(R, "ALLOWED_ATTR") ? zt({}, R.ALLOWED_ATTR, fe) : ct, Sr = Ki(R, "ALLOWED_NAMESPACES") ? zt({}, R.ALLOWED_NAMESPACES, Yd) : Mh, zl = Ki(R, "ADD_URI_SAFE_ATTR") ? zt(Yr(Ro), R.ADD_URI_SAFE_ATTR, fe) : Ro, Pi = Ki(R, "ADD_DATA_URI_TAGS") ? zt(Yr(je), R.ADD_DATA_URI_TAGS, fe) : je, Mi = Ki(R, "FORBID_CONTENTS") ? zt({}, R.FORBID_CONTENTS, fe) : Ue, pt = Ki(R, "FORBID_TAGS") ? zt({}, R.FORBID_TAGS, fe) : Yr({}), Ht = Ki(R, "FORBID_ATTR") ? zt({}, R.FORBID_ATTR, fe) : Yr({}), ta = Ki(R, "USE_PROFILES") ? R.USE_PROFILES : false, qt = R.ALLOW_ARIA_ATTR !== false, he = R.ALLOW_DATA_ATTR !== false, re = R.ALLOW_UNKNOWN_PROTOCOLS || false, qe = R.ALLOW_SELF_CLOSE_IN_ATTR !== false, He = R.SAFE_FOR_TEMPLATES || false, mi = R.SAFE_FOR_XML !== false, Ii = R.WHOLE_DOCUMENT || false, Oe = R.RETURN_DOM || false, En = R.RETURN_DOM_FRAGMENT || false, Fa = R.RETURN_TRUSTED_TYPE || false, $l = R.FORCE_BODY || false, Nl = R.SANITIZE_DOM !== false, qa = R.SANITIZE_NAMED_PROPS || false, Mn = R.KEEP_CONTENT !== false, Ha = R.IN_PLACE || false, M = R.ALLOWED_URI_REGEXP || Fx, li = R.NAMESPACE || ni, Ua = R.MATHML_TEXT_INTEGRATION_POINTS || Ua, ja = R.HTML_INTEGRATION_POINTS || ja, ut = R.CUSTOM_ELEMENT_HANDLING || {}, R.CUSTOM_ELEMENT_HANDLING && Hl(R.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (ut.tagNameCheck = R.CUSTOM_ELEMENT_HANDLING.tagNameCheck), R.CUSTOM_ELEMENT_HANDLING && Hl(R.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (ut.attributeNameCheck = R.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), R.CUSTOM_ELEMENT_HANDLING && typeof R.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (ut.allowCustomizedBuiltInElements = R.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), He && (he = false), En && (Oe = true), ta && (Y = zt({}, n1), Z = [], ta.html === true && (zt(Y, a1), zt(Z, l1)), ta.svg === true && (zt(Y, Id), zt(Z, Wd), zt(Z, Wc)), ta.svgFilters === true && (zt(Y, Pd), zt(Z, Wd), zt(Z, Wc)), ta.mathMl === true && (zt(Y, Gd), zt(Z, s1), zt(Z, Wc))), R.ADD_TAGS && (Y === K && (Y = Yr(Y)), zt(Y, R.ADD_TAGS, fe)), R.ADD_ATTR && (Z === ct && (Z = Yr(Z)), zt(Z, R.ADD_ATTR, fe)), R.ADD_URI_SAFE_ATTR && zt(zl, R.ADD_URI_SAFE_ATTR, fe), R.FORBID_CONTENTS && (Mi === Ue && (Mi = Yr(Mi)), zt(Mi, R.FORBID_CONTENTS, fe)), Mn && (Y["#text"] = true), Ii && zt(Y, [
          "html",
          "head",
          "body"
        ]), Y.table && (zt(Y, [
          "tbody"
        ]), delete pt.tbody), R.TRUSTED_TYPES_POLICY) {
          if (typeof R.TRUSTED_TYPES_POLICY.createHTML != "function") throw qs('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
          if (typeof R.TRUSTED_TYPES_POLICY.createScriptURL != "function") throw qs('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
          $ = R.TRUSTED_TYPES_POLICY, O = $.createHTML("");
        } else $ === void 0 && ($ = VA(x, l)), $ !== null && typeof O == "string" && (O = $.createHTML(""));
        ri && ri(R), ar = R;
      }
    }, Wi = zt({}, [
      ...Id,
      ...Pd,
      ...FA
    ]), _e2 = zt({}, [
      ...Gd,
      ...qA
    ]), Ye = function(R) {
      let st = L(R);
      (!st || !st.tagName) && (st = {
        namespaceURI: li,
        tagName: "template"
      });
      const dt = nu(R.tagName), ee = nu(st.tagName);
      return Sr[R.namespaceURI] ? R.namespaceURI === _r ? st.namespaceURI === ni ? dt === "svg" : st.namespaceURI === Bn ? dt === "svg" && (ee === "annotation-xml" || Ua[ee]) : !!Wi[dt] : R.namespaceURI === Bn ? st.namespaceURI === ni ? dt === "math" : st.namespaceURI === _r ? dt === "math" && ja[ee] : !!_e2[dt] : R.namespaceURI === ni ? st.namespaceURI === _r && !ja[ee] || st.namespaceURI === Bn && !Ua[ee] ? false : !_e2[dt] && (Fl[dt] || !Wi[dt]) : !!(Gi === "application/xhtml+xml" && Sr[R.namespaceURI]) : false;
    }, De = function(R) {
      zs(e.removed, {
        element: R
      });
      try {
        L(R).removeChild(R);
      } catch {
        w(R);
      }
    }, nr = function(R, st) {
      try {
        zs(e.removed, {
          attribute: st.getAttributeNode(R),
          from: st
        });
      } catch {
        zs(e.removed, {
          attribute: null,
          from: st
        });
      }
      if (st.removeAttribute(R), R === "is") if (Oe || En) try {
        De(st);
      } catch {
      }
      else try {
        st.setAttribute(R, "");
      } catch {
      }
    }, No = function(R) {
      let st = null, dt = null;
      if ($l) R = "<remove></remove>" + R;
      else {
        const oe = r1(R, /^[\r\n\t ]+/);
        dt = oe && oe[0];
      }
      Gi === "application/xhtml+xml" && li === ni && (R = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + R + "</body></html>");
      const ee = $ ? $.createHTML(R) : R;
      if (li === ni) try {
        st = new b().parseFromString(ee, Gi);
      } catch {
      }
      if (!st || !st.documentElement) {
        st = W.createDocument(li, "template", null);
        try {
          st.documentElement.innerHTML = ea ? O : ee;
        } catch {
        }
      }
      const Se = st.body || st.documentElement;
      return R && dt && Se.insertBefore(a.createTextNode(dt), Se.childNodes[0] || null), li === ni ? nt.call(st, Ii ? "html" : "body")[0] : Ii ? st.documentElement : Se;
    }, zo = function(R) {
      return j.call(R.ownerDocument || R, R, f.SHOW_ELEMENT | f.SHOW_COMMENT | f.SHOW_TEXT | f.SHOW_PROCESSING_INSTRUCTION | f.SHOW_CDATA_SECTION, null);
    }, Ln = function(R) {
      return R instanceof m && (typeof R.nodeName != "string" || typeof R.textContent != "string" || typeof R.removeChild != "function" || !(R.attributes instanceof p) || typeof R.removeAttribute != "function" || typeof R.setAttribute != "function" || typeof R.namespaceURI != "string" || typeof R.insertBefore != "function" || typeof R.hasChildNodes != "function");
    }, ia = function(R) {
      return typeof u == "function" && R instanceof u;
    };
    function yi(_t, R, st) {
      Gc(_t, (dt) => {
        dt.call(e, R, st, ar);
      });
    }
    const Cr = function(R) {
      let st = null;
      if (yi(X.beforeSanitizeElements, R, null), Ln(R)) return De(R), true;
      const dt = fe(R.nodeName);
      if (yi(X.uponSanitizeElement, R, {
        tagName: dt,
        allowedTags: Y
      }), mi && R.hasChildNodes() && !ia(R.firstElementChild) && Je(/<[/\w!]/g, R.innerHTML) && Je(/<[/\w!]/g, R.textContent) || R.nodeType === Us.progressingInstruction || mi && R.nodeType === Us.comment && Je(/<[/\w]/g, R.data)) return De(R), true;
      if (!Y[dt] || pt[dt]) {
        if (!pt[dt] && ra(dt) && (ut.tagNameCheck instanceof RegExp && Je(ut.tagNameCheck, dt) || ut.tagNameCheck instanceof Function && ut.tagNameCheck(dt))) return false;
        if (Mn && !Mi[dt]) {
          const ee = L(R) || R.parentNode, Se = A(R) || R.childNodes;
          if (Se && ee) {
            const oe = Se.length;
            for (let Ie = oe - 1; Ie >= 0; --Ie) {
              const si = S(Se[Ie], true);
              si.__removalCount = (R.__removalCount || 0) + 1, ee.insertBefore(si, k(R));
            }
          }
        }
        return De(R), true;
      }
      return R instanceof d && !Ye(R) || (dt === "noscript" || dt === "noembed" || dt === "noframes") && Je(/<\/no(script|embed|frames)/i, R.innerHTML) ? (De(R), true) : (He && R.nodeType === Us.text && (st = R.textContent, Gc([
        at,
        rt,
        V
      ], (ee) => {
        st = Fs(st, ee, " ");
      }), R.textContent !== st && (zs(e.removed, {
        element: R.cloneNode()
      }), R.textContent = st)), yi(X.afterSanitizeElements, R, null), false);
    }, wr = function(R, st, dt) {
      if (Nl && (st === "id" || st === "name") && (dt in a || dt in ql)) return false;
      if (!(he && !Ht[st] && Je(G, st))) {
        if (!(qt && Je(E, st))) {
          if (!Z[st] || Ht[st]) {
            if (!(ra(R) && (ut.tagNameCheck instanceof RegExp && Je(ut.tagNameCheck, R) || ut.tagNameCheck instanceof Function && ut.tagNameCheck(R)) && (ut.attributeNameCheck instanceof RegExp && Je(ut.attributeNameCheck, st) || ut.attributeNameCheck instanceof Function && ut.attributeNameCheck(st)) || st === "is" && ut.allowCustomizedBuiltInElements && (ut.tagNameCheck instanceof RegExp && Je(ut.tagNameCheck, dt) || ut.tagNameCheck instanceof Function && ut.tagNameCheck(dt)))) return false;
          } else if (!zl[st]) {
            if (!Je(M, Fs(dt, F, ""))) {
              if (!((st === "src" || st === "xlink:href" || st === "href") && R !== "script" && RA(dt, "data:") === 0 && Pi[R])) {
                if (!(re && !Je(N, Fs(dt, F, "")))) {
                  if (dt) return false;
                }
              }
            }
          }
        }
      }
      return true;
    }, ra = function(R) {
      return R !== "annotation-xml" && r1(R, ot);
    }, Tr = function(R) {
      yi(X.beforeSanitizeAttributes, R, null);
      const { attributes: st } = R;
      if (!st || Ln(R)) return;
      const dt = {
        attrName: "",
        attrValue: "",
        keepAttr: true,
        allowedAttributes: Z,
        forceKeepAttr: void 0
      };
      let ee = st.length;
      for (; ee--; ) {
        const Se = st[ee], { name: oe, namespaceURI: Ie, value: si } = Se, lr = fe(oe), bi = si;
        let ye = oe === "value" ? bi : $A(bi);
        if (dt.attrName = lr, dt.attrValue = ye, dt.keepAttr = true, dt.forceKeepAttr = void 0, yi(X.uponSanitizeAttribute, R, dt), ye = dt.attrValue, qa && (lr === "id" || lr === "name") && (nr(oe, R), ye = Eh + ye), mi && Je(/((--!?|])>)|<\/(style|title)/i, ye)) {
          nr(oe, R);
          continue;
        }
        if (dt.forceKeepAttr) continue;
        if (!dt.keepAttr) {
          nr(oe, R);
          continue;
        }
        if (!qe && Je(/\/>/i, ye)) {
          nr(oe, R);
          continue;
        }
        He && Gc([
          at,
          rt,
          V
        ], (kr) => {
          ye = Fs(ye, kr, " ");
        });
        const jl = fe(R.nodeName);
        if (!wr(jl, lr, ye)) {
          nr(oe, R);
          continue;
        }
        if ($ && typeof x == "object" && typeof x.getAttributeType == "function" && !Ie) switch (x.getAttributeType(jl, lr)) {
          case "TrustedHTML": {
            ye = $.createHTML(ye);
            break;
          }
          case "TrustedScriptURL": {
            ye = $.createScriptURL(ye);
            break;
          }
        }
        if (ye !== bi) try {
          Ie ? R.setAttributeNS(Ie, oe, ye) : R.setAttribute(oe, ye), Ln(R) ? De(R) : i1(e.removed);
        } catch {
          nr(oe, R);
        }
      }
      yi(X.afterSanitizeAttributes, R, null);
    }, me = function _t(R) {
      let st = null;
      const dt = zo(R);
      for (yi(X.beforeSanitizeShadowDOM, R, null); st = dt.nextNode(); ) yi(X.uponSanitizeShadowNode, st, null), Cr(st), Tr(st), st.content instanceof o && _t(st.content);
      yi(X.afterSanitizeShadowDOM, R, null);
    };
    return e.sanitize = function(_t) {
      let R = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, st = null, dt = null, ee = null, Se = null;
      if (ea = !_t, ea && (_t = "<!-->"), typeof _t != "string" && !ia(_t)) if (typeof _t.toString == "function") {
        if (_t = _t.toString(), typeof _t != "string") throw qs("dirty is not a string, aborting");
      } else throw qs("toString is not a function");
      if (!e.isSupported) return _t;
      if (Rl || Ul(R), e.removed = [], typeof _t == "string" && (Ha = false), Ha) {
        if (_t.nodeName) {
          const si = fe(_t.nodeName);
          if (!Y[si] || pt[si]) throw qs("root node is forbidden and cannot be sanitized in-place");
        }
      } else if (_t instanceof u) st = No("<!---->"), dt = st.ownerDocument.importNode(_t, true), dt.nodeType === Us.element && dt.nodeName === "BODY" || dt.nodeName === "HTML" ? st = dt : st.appendChild(dt);
      else {
        if (!Oe && !He && !Ii && _t.indexOf("<") === -1) return $ && Fa ? $.createHTML(_t) : _t;
        if (st = No(_t), !st) return Oe ? null : Fa ? O : "";
      }
      st && $l && De(st.firstChild);
      const oe = zo(Ha ? _t : st);
      for (; ee = oe.nextNode(); ) Cr(ee), Tr(ee), ee.content instanceof o && me(ee.content);
      if (Ha) return _t;
      if (Oe) {
        if (En) for (Se = et.call(st.ownerDocument); st.firstChild; ) Se.appendChild(st.firstChild);
        else Se = st;
        return (Z.shadowroot || Z.shadowrootmode) && (Se = lt.call(n, Se, true)), Se;
      }
      let Ie = Ii ? st.outerHTML : st.innerHTML;
      return Ii && Y["!doctype"] && st.ownerDocument && st.ownerDocument.doctype && st.ownerDocument.doctype.name && Je(qx, st.ownerDocument.doctype.name) && (Ie = "<!DOCTYPE " + st.ownerDocument.doctype.name + `>
` + Ie), He && Gc([
        at,
        rt,
        V
      ], (si) => {
        Ie = Fs(Ie, si, " ");
      }), $ && Fa ? $.createHTML(Ie) : Ie;
    }, e.setConfig = function() {
      let _t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      Ul(_t), Rl = true;
    }, e.clearConfig = function() {
      ar = null, Rl = false;
    }, e.isValidAttribute = function(_t, R, st) {
      ar || Ul({});
      const dt = fe(_t), ee = fe(R);
      return wr(dt, ee, st);
    }, e.addHook = function(_t, R) {
      typeof R == "function" && zs(X[_t], R);
    }, e.removeHook = function(_t, R) {
      if (R !== void 0) {
        const st = OA(X[_t], R);
        return st === -1 ? void 0 : DA(X[_t], st, 1)[0];
      }
      return i1(X[_t]);
    }, e.removeHooks = function(_t) {
      X[_t] = [];
    }, e.removeAllHooks = function() {
      X = c1();
    }, e;
  }
  let xl, Ux, lo, ZA, jx, mn, cg, fp, Yx, QA, dp, ih, rh, ti, KA, JA, tE, eE, iE, aE, nE, lE, sE, Xr, fr, Ix, Px, oE, xu, cE, vl, di, vu, yn, so, ah, uE, hE, fE, Wx, Xx, Vx, dE, _u, pE, u1, gE, Zx, mE, yE;
  xl = Hx();
  Ux = /^-{3}\s*[\n\r](.*?)[\n\r]-{3}\s*[\n\r]+/s;
  lo = /%{2}{\s*(?:(\w+)\s*:|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi;
  ZA = /\s*%%.*\n/gm;
  jx = (_a = class extends Error {
    constructor(t) {
      super(t), this.name = "UnknownDiagramError";
    }
  }, v(_a, "UnknownDiagramError"), _a);
  mn = {};
  cg = v(function(t, e) {
    t = t.replace(Ux, "").replace(lo, "").replace(ZA, `
`);
    for (const [a, { detector: n }] of Object.entries(mn)) if (n(t, e)) return a;
    throw new jx(`No diagram type detected matching given configuration for text: ${t}`);
  }, "detectType");
  fp = v((...t) => {
    for (const { id: e, detector: a, loader: n } of t) Yx(e, a, n);
  }, "registerLazyLoadedDiagrams");
  Yx = v((t, e, a) => {
    mn[t] && it.warn(`Detector with key ${t} already exists. Overwriting.`), mn[t] = {
      detector: e,
      loader: a
    }, it.debug(`Detector with key ${t} added${a ? " with loader" : ""}`);
  }, "addDetector");
  QA = v((t) => mn[t].loader, "getDiagramLoader");
  dp = v((t, e, { depth: a = 2, clobber: n = false } = {}) => {
    const l = {
      depth: a,
      clobber: n
    };
    return Array.isArray(e) && !Array.isArray(t) ? (e.forEach((o) => dp(t, o, l)), t) : Array.isArray(e) && Array.isArray(t) ? (e.forEach((o) => {
      t.includes(o) || t.push(o);
    }), t) : t === void 0 || a <= 0 ? t != null && typeof t == "object" && typeof e == "object" ? Object.assign(t, e) : e : (e !== void 0 && typeof t == "object" && typeof e == "object" && Object.keys(e).forEach((o) => {
      typeof e[o] == "object" && (t[o] === void 0 || typeof t[o] == "object") ? (t[o] === void 0 && (t[o] = Array.isArray(e[o]) ? [] : {}), t[o] = dp(t[o], e[o], {
        depth: a - 1,
        clobber: n
      })) : (n || typeof t[o] != "object" && typeof e[o] != "object") && (t[o] = e[o]);
    }), t);
  }, "assignWithDepth");
  ke = dp;
  ih = "#ffffff";
  rh = "#f2f2f2";
  ti = v((t, e) => e ? q(t, {
    s: -40,
    l: 10
  }) : q(t, {
    s: -40,
    l: -10
  }), "mkBorder");
  KA = (_b = class {
    constructor() {
      this.background = "#f4f4f4", this.primaryColor = "#fff4dd", this.noteBkgColor = "#fff5ad", this.noteTextColor = "#333", this.THEME_COLOR_LIMIT = 12, this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px";
    }
    updateColors() {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g3, _h3, _i2, _j2, _k, _l2, _m, _n2, _o2, _p2, _q, _r, _s, _t, _u2;
      if (this.primaryTextColor = this.primaryTextColor || (this.darkMode ? "#eee" : "#333"), this.secondaryColor = this.secondaryColor || q(this.primaryColor, {
        h: -120
      }), this.tertiaryColor = this.tertiaryColor || q(this.primaryColor, {
        h: 180,
        l: 5
      }), this.primaryBorderColor = this.primaryBorderColor || ti(this.primaryColor, this.darkMode), this.secondaryBorderColor = this.secondaryBorderColor || ti(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = this.tertiaryBorderColor || ti(this.tertiaryColor, this.darkMode), this.noteBorderColor = this.noteBorderColor || ti(this.noteBkgColor, this.darkMode), this.noteBkgColor = this.noteBkgColor || "#fff5ad", this.noteTextColor = this.noteTextColor || "#333", this.secondaryTextColor = this.secondaryTextColor || ht(this.secondaryColor), this.tertiaryTextColor = this.tertiaryTextColor || ht(this.tertiaryColor), this.lineColor = this.lineColor || ht(this.background), this.arrowheadColor = this.arrowheadColor || ht(this.background), this.textColor = this.textColor || this.primaryTextColor, this.border2 = this.border2 || this.tertiaryBorderColor, this.nodeBkg = this.nodeBkg || this.primaryColor, this.mainBkg = this.mainBkg || this.primaryColor, this.nodeBorder = this.nodeBorder || this.primaryBorderColor, this.clusterBkg = this.clusterBkg || this.tertiaryColor, this.clusterBorder = this.clusterBorder || this.tertiaryBorderColor, this.defaultLinkColor = this.defaultLinkColor || this.lineColor, this.titleColor = this.titleColor || this.tertiaryTextColor, this.edgeLabelBackground = this.edgeLabelBackground || (this.darkMode ? wt(this.secondaryColor, 30) : this.secondaryColor), this.nodeTextColor = this.nodeTextColor || this.primaryTextColor, this.actorBorder = this.actorBorder || this.primaryBorderColor, this.actorBkg = this.actorBkg || this.mainBkg, this.actorTextColor = this.actorTextColor || this.primaryTextColor, this.actorLineColor = this.actorLineColor || this.actorBorder, this.labelBoxBkgColor = this.labelBoxBkgColor || this.actorBkg, this.signalColor = this.signalColor || this.textColor, this.signalTextColor = this.signalTextColor || this.textColor, this.labelBoxBorderColor = this.labelBoxBorderColor || this.actorBorder, this.labelTextColor = this.labelTextColor || this.actorTextColor, this.loopTextColor = this.loopTextColor || this.actorTextColor, this.activationBorderColor = this.activationBorderColor || wt(this.secondaryColor, 10), this.activationBkgColor = this.activationBkgColor || this.secondaryColor, this.sequenceNumberColor = this.sequenceNumberColor || ht(this.lineColor), this.sectionBkgColor = this.sectionBkgColor || this.tertiaryColor, this.altSectionBkgColor = this.altSectionBkgColor || "white", this.sectionBkgColor = this.sectionBkgColor || this.secondaryColor, this.sectionBkgColor2 = this.sectionBkgColor2 || this.primaryColor, this.excludeBkgColor = this.excludeBkgColor || "#eeeeee", this.taskBorderColor = this.taskBorderColor || this.primaryBorderColor, this.taskBkgColor = this.taskBkgColor || this.primaryColor, this.activeTaskBorderColor = this.activeTaskBorderColor || this.primaryColor, this.activeTaskBkgColor = this.activeTaskBkgColor || mt(this.primaryColor, 23), this.gridColor = this.gridColor || "lightgrey", this.doneTaskBkgColor = this.doneTaskBkgColor || "lightgrey", this.doneTaskBorderColor = this.doneTaskBorderColor || "grey", this.critBorderColor = this.critBorderColor || "#ff8888", this.critBkgColor = this.critBkgColor || "red", this.todayLineColor = this.todayLineColor || "red", this.vertLineColor = this.vertLineColor || "navy", this.taskTextColor = this.taskTextColor || this.textColor, this.taskTextOutsideColor = this.taskTextOutsideColor || this.textColor, this.taskTextLightColor = this.taskTextLightColor || this.textColor, this.taskTextColor = this.taskTextColor || this.primaryTextColor, this.taskTextDarkColor = this.taskTextDarkColor || this.textColor, this.taskTextClickableColor = this.taskTextClickableColor || "#003163", this.personBorder = this.personBorder || this.primaryBorderColor, this.personBkg = this.personBkg || this.mainBkg, this.darkMode ? (this.rowOdd = this.rowOdd || wt(this.mainBkg, 5) || "#ffffff", this.rowEven = this.rowEven || wt(this.mainBkg, 10)) : (this.rowOdd = this.rowOdd || mt(this.mainBkg, 75) || "#ffffff", this.rowEven = this.rowEven || mt(this.mainBkg, 5)), this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || this.tertiaryColor, this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.nodeBorder, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.specialStateColor = this.lineColor, this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || q(this.primaryColor, {
        h: 30
      }), this.cScale4 = this.cScale4 || q(this.primaryColor, {
        h: 60
      }), this.cScale5 = this.cScale5 || q(this.primaryColor, {
        h: 90
      }), this.cScale6 = this.cScale6 || q(this.primaryColor, {
        h: 120
      }), this.cScale7 = this.cScale7 || q(this.primaryColor, {
        h: 150
      }), this.cScale8 = this.cScale8 || q(this.primaryColor, {
        h: 210,
        l: 150
      }), this.cScale9 = this.cScale9 || q(this.primaryColor, {
        h: 270
      }), this.cScale10 = this.cScale10 || q(this.primaryColor, {
        h: 300
      }), this.cScale11 = this.cScale11 || q(this.primaryColor, {
        h: 330
      }), this.darkMode) for (let e = 0; e < this.THEME_COLOR_LIMIT; e++) this["cScale" + e] = wt(this["cScale" + e], 75);
      else for (let e = 0; e < this.THEME_COLOR_LIMIT; e++) this["cScale" + e] = wt(this["cScale" + e], 25);
      for (let e = 0; e < this.THEME_COLOR_LIMIT; e++) this["cScaleInv" + e] = this["cScaleInv" + e] || ht(this["cScale" + e]);
      for (let e = 0; e < this.THEME_COLOR_LIMIT; e++) this.darkMode ? this["cScalePeer" + e] = this["cScalePeer" + e] || mt(this["cScale" + e], 10) : this["cScalePeer" + e] = this["cScalePeer" + e] || wt(this["cScale" + e], 10);
      this.scaleLabelColor = this.scaleLabelColor || this.labelTextColor;
      for (let e = 0; e < this.THEME_COLOR_LIMIT; e++) this["cScaleLabel" + e] = this["cScaleLabel" + e] || this.scaleLabelColor;
      const t = this.darkMode ? -4 : -1;
      for (let e = 0; e < 5; e++) this["surface" + e] = this["surface" + e] || q(this.mainBkg, {
        h: 180,
        s: -15,
        l: t * (5 + e * 3)
      }), this["surfacePeer" + e] = this["surfacePeer" + e] || q(this.mainBkg, {
        h: 180,
        s: -15,
        l: t * (8 + e * 3)
      });
      this.classText = this.classText || this.textColor, this.fillType0 = this.fillType0 || this.primaryColor, this.fillType1 = this.fillType1 || this.secondaryColor, this.fillType2 = this.fillType2 || q(this.primaryColor, {
        h: 64
      }), this.fillType3 = this.fillType3 || q(this.secondaryColor, {
        h: 64
      }), this.fillType4 = this.fillType4 || q(this.primaryColor, {
        h: -64
      }), this.fillType5 = this.fillType5 || q(this.secondaryColor, {
        h: -64
      }), this.fillType6 = this.fillType6 || q(this.primaryColor, {
        h: 128
      }), this.fillType7 = this.fillType7 || q(this.secondaryColor, {
        h: 128
      }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || this.tertiaryColor, this.pie4 = this.pie4 || q(this.primaryColor, {
        l: -10
      }), this.pie5 = this.pie5 || q(this.secondaryColor, {
        l: -10
      }), this.pie6 = this.pie6 || q(this.tertiaryColor, {
        l: -10
      }), this.pie7 = this.pie7 || q(this.primaryColor, {
        h: 60,
        l: -10
      }), this.pie8 = this.pie8 || q(this.primaryColor, {
        h: -60,
        l: -10
      }), this.pie9 = this.pie9 || q(this.primaryColor, {
        h: 120,
        l: 0
      }), this.pie10 = this.pie10 || q(this.primaryColor, {
        h: 60,
        l: -20
      }), this.pie11 = this.pie11 || q(this.primaryColor, {
        h: -60,
        l: -20
      }), this.pie12 = this.pie12 || q(this.primaryColor, {
        h: 120,
        l: -10
      }), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.radar = {
        axisColor: ((_a2 = this.radar) == null ? void 0 : _a2.axisColor) || this.lineColor,
        axisStrokeWidth: ((_b2 = this.radar) == null ? void 0 : _b2.axisStrokeWidth) || 2,
        axisLabelFontSize: ((_c2 = this.radar) == null ? void 0 : _c2.axisLabelFontSize) || 12,
        curveOpacity: ((_d2 = this.radar) == null ? void 0 : _d2.curveOpacity) || 0.5,
        curveStrokeWidth: ((_e2 = this.radar) == null ? void 0 : _e2.curveStrokeWidth) || 2,
        graticuleColor: ((_f2 = this.radar) == null ? void 0 : _f2.graticuleColor) || "#DEDEDE",
        graticuleStrokeWidth: ((_g3 = this.radar) == null ? void 0 : _g3.graticuleStrokeWidth) || 1,
        graticuleOpacity: ((_h3 = this.radar) == null ? void 0 : _h3.graticuleOpacity) || 0.3,
        legendBoxSize: ((_i2 = this.radar) == null ? void 0 : _i2.legendBoxSize) || 12,
        legendFontSize: ((_j2 = this.radar) == null ? void 0 : _j2.legendFontSize) || 12
      }, this.archEdgeColor = this.archEdgeColor || "#777", this.archEdgeArrowColor = this.archEdgeArrowColor || "#777", this.archEdgeWidth = this.archEdgeWidth || "3", this.archGroupBorderColor = this.archGroupBorderColor || "#000", this.archGroupBorderWidth = this.archGroupBorderWidth || "2px", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || q(this.primaryColor, {
        r: 5,
        g: 5,
        b: 5
      }), this.quadrant3Fill = this.quadrant3Fill || q(this.primaryColor, {
        r: 10,
        g: 10,
        b: 10
      }), this.quadrant4Fill = this.quadrant4Fill || q(this.primaryColor, {
        r: 15,
        g: 15,
        b: 15
      }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || q(this.primaryTextColor, {
        r: -5,
        g: -5,
        b: -5
      }), this.quadrant3TextFill = this.quadrant3TextFill || q(this.primaryTextColor, {
        r: -10,
        g: -10,
        b: -10
      }), this.quadrant4TextFill = this.quadrant4TextFill || q(this.primaryTextColor, {
        r: -15,
        g: -15,
        b: -15
      }), this.quadrantPointFill = this.quadrantPointFill || wo(this.quadrant1Fill) ? mt(this.quadrant1Fill) : wt(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.xyChart = {
        backgroundColor: ((_k = this.xyChart) == null ? void 0 : _k.backgroundColor) || this.background,
        titleColor: ((_l2 = this.xyChart) == null ? void 0 : _l2.titleColor) || this.primaryTextColor,
        xAxisTitleColor: ((_m = this.xyChart) == null ? void 0 : _m.xAxisTitleColor) || this.primaryTextColor,
        xAxisLabelColor: ((_n2 = this.xyChart) == null ? void 0 : _n2.xAxisLabelColor) || this.primaryTextColor,
        xAxisTickColor: ((_o2 = this.xyChart) == null ? void 0 : _o2.xAxisTickColor) || this.primaryTextColor,
        xAxisLineColor: ((_p2 = this.xyChart) == null ? void 0 : _p2.xAxisLineColor) || this.primaryTextColor,
        yAxisTitleColor: ((_q = this.xyChart) == null ? void 0 : _q.yAxisTitleColor) || this.primaryTextColor,
        yAxisLabelColor: ((_r = this.xyChart) == null ? void 0 : _r.yAxisLabelColor) || this.primaryTextColor,
        yAxisTickColor: ((_s = this.xyChart) == null ? void 0 : _s.yAxisTickColor) || this.primaryTextColor,
        yAxisLineColor: ((_t = this.xyChart) == null ? void 0 : _t.yAxisLineColor) || this.primaryTextColor,
        plotColorPalette: ((_u2 = this.xyChart) == null ? void 0 : _u2.plotColorPalette) || "#FFF4DD,#FFD8B1,#FFA07A,#ECEFF1,#D6DBDF,#C3E0A8,#FFB6A4,#FFD74D,#738FA7,#FFFFF0"
      }, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? wt(this.secondaryColor, 30) : this.secondaryColor), this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || q(this.primaryColor, {
        h: -30
      }), this.git4 = this.git4 || q(this.primaryColor, {
        h: -60
      }), this.git5 = this.git5 || q(this.primaryColor, {
        h: -90
      }), this.git6 = this.git6 || q(this.primaryColor, {
        h: 60
      }), this.git7 = this.git7 || q(this.primaryColor, {
        h: 120
      }), this.darkMode ? (this.git0 = mt(this.git0, 25), this.git1 = mt(this.git1, 25), this.git2 = mt(this.git2, 25), this.git3 = mt(this.git3, 25), this.git4 = mt(this.git4, 25), this.git5 = mt(this.git5, 25), this.git6 = mt(this.git6, 25), this.git7 = mt(this.git7, 25)) : (this.git0 = wt(this.git0, 25), this.git1 = wt(this.git1, 25), this.git2 = wt(this.git2, 25), this.git3 = wt(this.git3, 25), this.git4 = wt(this.git4, 25), this.git5 = wt(this.git5, 25), this.git6 = wt(this.git6, 25), this.git7 = wt(this.git7, 25)), this.gitInv0 = this.gitInv0 || ht(this.git0), this.gitInv1 = this.gitInv1 || ht(this.git1), this.gitInv2 = this.gitInv2 || ht(this.git2), this.gitInv3 = this.gitInv3 || ht(this.git3), this.gitInv4 = this.gitInv4 || ht(this.git4), this.gitInv5 = this.gitInv5 || ht(this.git5), this.gitInv6 = this.gitInv6 || ht(this.git6), this.gitInv7 = this.gitInv7 || ht(this.git7), this.branchLabelColor = this.branchLabelColor || (this.darkMode ? "black" : this.labelTextColor), this.gitBranchLabel0 = this.gitBranchLabel0 || this.branchLabelColor, this.gitBranchLabel1 = this.gitBranchLabel1 || this.branchLabelColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.branchLabelColor, this.gitBranchLabel3 = this.gitBranchLabel3 || this.branchLabelColor, this.gitBranchLabel4 = this.gitBranchLabel4 || this.branchLabelColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.branchLabelColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.branchLabelColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.branchLabelColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || ih, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || rh;
    }
    calculate(t) {
      if (typeof t != "object") {
        this.updateColors();
        return;
      }
      const e = Object.keys(t);
      e.forEach((a) => {
        this[a] = t[a];
      }), this.updateColors(), e.forEach((a) => {
        this[a] = t[a];
      });
    }
  }, v(_b, "Theme"), _b);
  JA = v((t) => {
    const e = new KA();
    return e.calculate(t), e;
  }, "getThemeVariables");
  tE = (_c = class {
    constructor() {
      this.background = "#333", this.primaryColor = "#1f2020", this.secondaryColor = mt(this.primaryColor, 16), this.tertiaryColor = q(this.primaryColor, {
        h: -160
      }), this.primaryBorderColor = ht(this.background), this.secondaryBorderColor = ti(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = ti(this.tertiaryColor, this.darkMode), this.primaryTextColor = ht(this.primaryColor), this.secondaryTextColor = ht(this.secondaryColor), this.tertiaryTextColor = ht(this.tertiaryColor), this.lineColor = ht(this.background), this.textColor = ht(this.background), this.mainBkg = "#1f2020", this.secondBkg = "calculated", this.mainContrastColor = "lightgrey", this.darkTextColor = mt(ht("#323D47"), 10), this.lineColor = "calculated", this.border1 = "#ccc", this.border2 = no(255, 255, 255, 0.25), this.arrowheadColor = "calculated", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.labelBackground = "#181818", this.textColor = "#ccc", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "#F9FFFE", this.edgeLabelBackground = "calculated", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "calculated", this.actorLineColor = "calculated", this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "calculated", this.activationBkgColor = "calculated", this.sequenceNumberColor = "black", this.sectionBkgColor = wt("#EAE8D9", 30), this.altSectionBkgColor = "calculated", this.sectionBkgColor2 = "#EAE8D9", this.excludeBkgColor = wt(this.sectionBkgColor, 10), this.taskBorderColor = no(255, 255, 255, 70), this.taskBkgColor = "calculated", this.taskTextColor = "calculated", this.taskTextLightColor = "calculated", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = no(255, 255, 255, 50), this.activeTaskBkgColor = "#81B1DB", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "grey", this.critBorderColor = "#E83737", this.critBkgColor = "#E83737", this.taskTextDarkColor = "calculated", this.todayLineColor = "#DB5757", this.vertLineColor = "#00BFFF", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.rowOdd = this.rowOdd || mt(this.mainBkg, 5) || "#ffffff", this.rowEven = this.rowEven || wt(this.mainBkg, 10), this.labelColor = "calculated", this.errorBkgColor = "#a44141", this.errorTextColor = "#ddd";
    }
    updateColors() {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g3, _h3, _i2, _j2, _k, _l2, _m, _n2, _o2, _p2, _q, _r, _s, _t, _u2;
      this.secondBkg = mt(this.mainBkg, 16), this.lineColor = this.mainContrastColor, this.arrowheadColor = this.mainContrastColor, this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.edgeLabelBackground = mt(this.labelBackground, 25), this.actorBorder = this.border1, this.actorBkg = this.mainBkg, this.actorTextColor = this.mainContrastColor, this.actorLineColor = this.actorBorder, this.signalColor = this.mainContrastColor, this.signalTextColor = this.mainContrastColor, this.labelBoxBkgColor = this.actorBkg, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.mainContrastColor, this.loopTextColor = this.mainContrastColor, this.noteBorderColor = this.secondaryBorderColor, this.noteBkgColor = this.secondBkg, this.noteTextColor = this.secondaryTextColor, this.activationBorderColor = this.border1, this.activationBkgColor = this.secondBkg, this.altSectionBkgColor = this.background, this.taskBkgColor = mt(this.mainBkg, 23), this.taskTextColor = this.darkTextColor, this.taskTextLightColor = this.mainContrastColor, this.taskTextOutsideColor = this.taskTextLightColor, this.gridColor = this.mainContrastColor, this.doneTaskBkgColor = this.mainContrastColor, this.taskTextDarkColor = this.darkTextColor, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#555", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = "#f4f4f4", this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = q(this.primaryColor, {
        h: 64
      }), this.fillType3 = q(this.secondaryColor, {
        h: 64
      }), this.fillType4 = q(this.primaryColor, {
        h: -64
      }), this.fillType5 = q(this.secondaryColor, {
        h: -64
      }), this.fillType6 = q(this.primaryColor, {
        h: 128
      }), this.fillType7 = q(this.secondaryColor, {
        h: 128
      }), this.cScale1 = this.cScale1 || "#0b0000", this.cScale2 = this.cScale2 || "#4d1037", this.cScale3 = this.cScale3 || "#3f5258", this.cScale4 = this.cScale4 || "#4f2f1b", this.cScale5 = this.cScale5 || "#6e0a0a", this.cScale6 = this.cScale6 || "#3b0048", this.cScale7 = this.cScale7 || "#995a01", this.cScale8 = this.cScale8 || "#154706", this.cScale9 = this.cScale9 || "#161722", this.cScale10 = this.cScale10 || "#00296f", this.cScale11 = this.cScale11 || "#01629c", this.cScale12 = this.cScale12 || "#010029", this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || q(this.primaryColor, {
        h: 30
      }), this.cScale4 = this.cScale4 || q(this.primaryColor, {
        h: 60
      }), this.cScale5 = this.cScale5 || q(this.primaryColor, {
        h: 90
      }), this.cScale6 = this.cScale6 || q(this.primaryColor, {
        h: 120
      }), this.cScale7 = this.cScale7 || q(this.primaryColor, {
        h: 150
      }), this.cScale8 = this.cScale8 || q(this.primaryColor, {
        h: 210
      }), this.cScale9 = this.cScale9 || q(this.primaryColor, {
        h: 270
      }), this.cScale10 = this.cScale10 || q(this.primaryColor, {
        h: 300
      }), this.cScale11 = this.cScale11 || q(this.primaryColor, {
        h: 330
      });
      for (let t = 0; t < this.THEME_COLOR_LIMIT; t++) this["cScaleInv" + t] = this["cScaleInv" + t] || ht(this["cScale" + t]);
      for (let t = 0; t < this.THEME_COLOR_LIMIT; t++) this["cScalePeer" + t] = this["cScalePeer" + t] || mt(this["cScale" + t], 10);
      for (let t = 0; t < 5; t++) this["surface" + t] = this["surface" + t] || q(this.mainBkg, {
        h: 30,
        s: -30,
        l: -(-10 + t * 4)
      }), this["surfacePeer" + t] = this["surfacePeer" + t] || q(this.mainBkg, {
        h: 30,
        s: -30,
        l: -(-7 + t * 4)
      });
      this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor);
      for (let t = 0; t < this.THEME_COLOR_LIMIT; t++) this["cScaleLabel" + t] = this["cScaleLabel" + t] || this.scaleLabelColor;
      for (let t = 0; t < this.THEME_COLOR_LIMIT; t++) this["pie" + t] = this["cScale" + t];
      this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || q(this.primaryColor, {
        r: 5,
        g: 5,
        b: 5
      }), this.quadrant3Fill = this.quadrant3Fill || q(this.primaryColor, {
        r: 10,
        g: 10,
        b: 10
      }), this.quadrant4Fill = this.quadrant4Fill || q(this.primaryColor, {
        r: 15,
        g: 15,
        b: 15
      }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || q(this.primaryTextColor, {
        r: -5,
        g: -5,
        b: -5
      }), this.quadrant3TextFill = this.quadrant3TextFill || q(this.primaryTextColor, {
        r: -10,
        g: -10,
        b: -10
      }), this.quadrant4TextFill = this.quadrant4TextFill || q(this.primaryTextColor, {
        r: -15,
        g: -15,
        b: -15
      }), this.quadrantPointFill = this.quadrantPointFill || wo(this.quadrant1Fill) ? mt(this.quadrant1Fill) : wt(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.xyChart = {
        backgroundColor: ((_a2 = this.xyChart) == null ? void 0 : _a2.backgroundColor) || this.background,
        titleColor: ((_b2 = this.xyChart) == null ? void 0 : _b2.titleColor) || this.primaryTextColor,
        xAxisTitleColor: ((_c2 = this.xyChart) == null ? void 0 : _c2.xAxisTitleColor) || this.primaryTextColor,
        xAxisLabelColor: ((_d2 = this.xyChart) == null ? void 0 : _d2.xAxisLabelColor) || this.primaryTextColor,
        xAxisTickColor: ((_e2 = this.xyChart) == null ? void 0 : _e2.xAxisTickColor) || this.primaryTextColor,
        xAxisLineColor: ((_f2 = this.xyChart) == null ? void 0 : _f2.xAxisLineColor) || this.primaryTextColor,
        yAxisTitleColor: ((_g3 = this.xyChart) == null ? void 0 : _g3.yAxisTitleColor) || this.primaryTextColor,
        yAxisLabelColor: ((_h3 = this.xyChart) == null ? void 0 : _h3.yAxisLabelColor) || this.primaryTextColor,
        yAxisTickColor: ((_i2 = this.xyChart) == null ? void 0 : _i2.yAxisTickColor) || this.primaryTextColor,
        yAxisLineColor: ((_j2 = this.xyChart) == null ? void 0 : _j2.yAxisLineColor) || this.primaryTextColor,
        plotColorPalette: ((_k = this.xyChart) == null ? void 0 : _k.plotColorPalette) || "#3498db,#2ecc71,#e74c3c,#f1c40f,#bdc3c7,#ffffff,#34495e,#9b59b6,#1abc9c,#e67e22"
      }, this.packet = {
        startByteColor: this.primaryTextColor,
        endByteColor: this.primaryTextColor,
        labelColor: this.primaryTextColor,
        titleColor: this.primaryTextColor,
        blockStrokeColor: this.primaryTextColor,
        blockFillColor: this.background
      }, this.radar = {
        axisColor: ((_l2 = this.radar) == null ? void 0 : _l2.axisColor) || this.lineColor,
        axisStrokeWidth: ((_m = this.radar) == null ? void 0 : _m.axisStrokeWidth) || 2,
        axisLabelFontSize: ((_n2 = this.radar) == null ? void 0 : _n2.axisLabelFontSize) || 12,
        curveOpacity: ((_o2 = this.radar) == null ? void 0 : _o2.curveOpacity) || 0.5,
        curveStrokeWidth: ((_p2 = this.radar) == null ? void 0 : _p2.curveStrokeWidth) || 2,
        graticuleColor: ((_q = this.radar) == null ? void 0 : _q.graticuleColor) || "#DEDEDE",
        graticuleStrokeWidth: ((_r = this.radar) == null ? void 0 : _r.graticuleStrokeWidth) || 1,
        graticuleOpacity: ((_s = this.radar) == null ? void 0 : _s.graticuleOpacity) || 0.3,
        legendBoxSize: ((_t = this.radar) == null ? void 0 : _t.legendBoxSize) || 12,
        legendFontSize: ((_u2 = this.radar) == null ? void 0 : _u2.legendFontSize) || 12
      }, this.classText = this.primaryTextColor, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? wt(this.secondaryColor, 30) : this.secondaryColor), this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = mt(this.secondaryColor, 20), this.git1 = mt(this.pie2 || this.secondaryColor, 20), this.git2 = mt(this.pie3 || this.tertiaryColor, 20), this.git3 = mt(this.pie4 || q(this.primaryColor, {
        h: -30
      }), 20), this.git4 = mt(this.pie5 || q(this.primaryColor, {
        h: -60
      }), 20), this.git5 = mt(this.pie6 || q(this.primaryColor, {
        h: -90
      }), 10), this.git6 = mt(this.pie7 || q(this.primaryColor, {
        h: 60
      }), 10), this.git7 = mt(this.pie8 || q(this.primaryColor, {
        h: 120
      }), 20), this.gitInv0 = this.gitInv0 || ht(this.git0), this.gitInv1 = this.gitInv1 || ht(this.git1), this.gitInv2 = this.gitInv2 || ht(this.git2), this.gitInv3 = this.gitInv3 || ht(this.git3), this.gitInv4 = this.gitInv4 || ht(this.git4), this.gitInv5 = this.gitInv5 || ht(this.git5), this.gitInv6 = this.gitInv6 || ht(this.git6), this.gitInv7 = this.gitInv7 || ht(this.git7), this.gitBranchLabel0 = this.gitBranchLabel0 || ht(this.labelTextColor), this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor, this.gitBranchLabel3 = this.gitBranchLabel3 || ht(this.labelTextColor), this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || mt(this.background, 12), this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || mt(this.background, 2), this.nodeBorder = this.nodeBorder || "#999";
    }
    calculate(t) {
      if (typeof t != "object") {
        this.updateColors();
        return;
      }
      const e = Object.keys(t);
      e.forEach((a) => {
        this[a] = t[a];
      }), this.updateColors(), e.forEach((a) => {
        this[a] = t[a];
      });
    }
  }, v(_c, "Theme"), _c);
  eE = v((t) => {
    const e = new tE();
    return e.calculate(t), e;
  }, "getThemeVariables");
  iE = (_d = class {
    constructor() {
      this.background = "#f4f4f4", this.primaryColor = "#ECECFF", this.secondaryColor = q(this.primaryColor, {
        h: 120
      }), this.secondaryColor = "#ffffde", this.tertiaryColor = q(this.primaryColor, {
        h: -160
      }), this.primaryBorderColor = ti(this.primaryColor, this.darkMode), this.secondaryBorderColor = ti(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = ti(this.tertiaryColor, this.darkMode), this.primaryTextColor = ht(this.primaryColor), this.secondaryTextColor = ht(this.secondaryColor), this.tertiaryTextColor = ht(this.tertiaryColor), this.lineColor = ht(this.background), this.textColor = ht(this.background), this.background = "white", this.mainBkg = "#ECECFF", this.secondBkg = "#ffffde", this.lineColor = "#333333", this.border1 = "#9370DB", this.border2 = "#aaaa33", this.arrowheadColor = "#333333", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.labelBackground = "rgba(232,232,232, 0.8)", this.textColor = "#333", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "calculated", this.edgeLabelBackground = "calculated", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "black", this.actorLineColor = "calculated", this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "calculated", this.altSectionBkgColor = "calculated", this.sectionBkgColor2 = "calculated", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "calculated", this.taskTextLightColor = "calculated", this.taskTextColor = this.taskTextLightColor, this.taskTextDarkColor = "calculated", this.taskTextOutsideColor = this.taskTextDarkColor, this.taskTextClickableColor = "calculated", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "calculated", this.critBorderColor = "calculated", this.critBkgColor = "calculated", this.todayLineColor = "calculated", this.vertLineColor = "calculated", this.sectionBkgColor = no(102, 102, 255, 0.49), this.altSectionBkgColor = "white", this.sectionBkgColor2 = "#fff400", this.taskBorderColor = "#534fbc", this.taskBkgColor = "#8a90dd", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "black", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "#534fbc", this.activeTaskBkgColor = "#bfc7ff", this.gridColor = "lightgrey", this.doneTaskBkgColor = "lightgrey", this.doneTaskBorderColor = "grey", this.critBorderColor = "#ff8888", this.critBkgColor = "red", this.todayLineColor = "red", this.vertLineColor = "navy", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.rowOdd = "calculated", this.rowEven = "calculated", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222", this.updateColors();
    }
    updateColors() {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g3, _h3, _i2, _j2, _k, _l2, _m, _n2, _o2, _p2, _q, _r, _s, _t, _u2;
      this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || q(this.primaryColor, {
        h: 30
      }), this.cScale4 = this.cScale4 || q(this.primaryColor, {
        h: 60
      }), this.cScale5 = this.cScale5 || q(this.primaryColor, {
        h: 90
      }), this.cScale6 = this.cScale6 || q(this.primaryColor, {
        h: 120
      }), this.cScale7 = this.cScale7 || q(this.primaryColor, {
        h: 150
      }), this.cScale8 = this.cScale8 || q(this.primaryColor, {
        h: 210
      }), this.cScale9 = this.cScale9 || q(this.primaryColor, {
        h: 270
      }), this.cScale10 = this.cScale10 || q(this.primaryColor, {
        h: 300
      }), this.cScale11 = this.cScale11 || q(this.primaryColor, {
        h: 330
      }), this.cScalePeer1 = this.cScalePeer1 || wt(this.secondaryColor, 45), this.cScalePeer2 = this.cScalePeer2 || wt(this.tertiaryColor, 40);
      for (let t = 0; t < this.THEME_COLOR_LIMIT; t++) this["cScale" + t] = wt(this["cScale" + t], 10), this["cScalePeer" + t] = this["cScalePeer" + t] || wt(this["cScale" + t], 25);
      for (let t = 0; t < this.THEME_COLOR_LIMIT; t++) this["cScaleInv" + t] = this["cScaleInv" + t] || q(this["cScale" + t], {
        h: 180
      });
      for (let t = 0; t < 5; t++) this["surface" + t] = this["surface" + t] || q(this.mainBkg, {
        h: 30,
        l: -(5 + t * 5)
      }), this["surfacePeer" + t] = this["surfacePeer" + t] || q(this.mainBkg, {
        h: 30,
        l: -(7 + t * 5)
      });
      if (this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor, this.labelTextColor !== "calculated") {
        this.cScaleLabel0 = this.cScaleLabel0 || ht(this.labelTextColor), this.cScaleLabel3 = this.cScaleLabel3 || ht(this.labelTextColor);
        for (let t = 0; t < this.THEME_COLOR_LIMIT; t++) this["cScaleLabel" + t] = this["cScaleLabel" + t] || this.labelTextColor;
      }
      this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.titleColor = this.textColor, this.edgeLabelBackground = this.labelBackground, this.actorBorder = mt(this.border1, 23), this.actorBkg = this.mainBkg, this.labelBoxBkgColor = this.actorBkg, this.signalColor = this.textColor, this.signalTextColor = this.textColor, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.actorTextColor, this.loopTextColor = this.actorTextColor, this.noteBorderColor = this.border2, this.noteTextColor = this.actorTextColor, this.actorLineColor = this.actorBorder, this.taskTextColor = this.taskTextLightColor, this.taskTextOutsideColor = this.taskTextDarkColor, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.rowOdd = this.rowOdd || mt(this.primaryColor, 75) || "#ffffff", this.rowEven = this.rowEven || mt(this.primaryColor, 1), this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f0f0f0", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.nodeBorder, this.specialStateColor = this.lineColor, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = q(this.primaryColor, {
        h: 64
      }), this.fillType3 = q(this.secondaryColor, {
        h: 64
      }), this.fillType4 = q(this.primaryColor, {
        h: -64
      }), this.fillType5 = q(this.secondaryColor, {
        h: -64
      }), this.fillType6 = q(this.primaryColor, {
        h: 128
      }), this.fillType7 = q(this.secondaryColor, {
        h: 128
      }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || q(this.tertiaryColor, {
        l: -40
      }), this.pie4 = this.pie4 || q(this.primaryColor, {
        l: -10
      }), this.pie5 = this.pie5 || q(this.secondaryColor, {
        l: -30
      }), this.pie6 = this.pie6 || q(this.tertiaryColor, {
        l: -20
      }), this.pie7 = this.pie7 || q(this.primaryColor, {
        h: 60,
        l: -20
      }), this.pie8 = this.pie8 || q(this.primaryColor, {
        h: -60,
        l: -40
      }), this.pie9 = this.pie9 || q(this.primaryColor, {
        h: 120,
        l: -40
      }), this.pie10 = this.pie10 || q(this.primaryColor, {
        h: 60,
        l: -40
      }), this.pie11 = this.pie11 || q(this.primaryColor, {
        h: -90,
        l: -40
      }), this.pie12 = this.pie12 || q(this.primaryColor, {
        h: 120,
        l: -30
      }), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || q(this.primaryColor, {
        r: 5,
        g: 5,
        b: 5
      }), this.quadrant3Fill = this.quadrant3Fill || q(this.primaryColor, {
        r: 10,
        g: 10,
        b: 10
      }), this.quadrant4Fill = this.quadrant4Fill || q(this.primaryColor, {
        r: 15,
        g: 15,
        b: 15
      }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || q(this.primaryTextColor, {
        r: -5,
        g: -5,
        b: -5
      }), this.quadrant3TextFill = this.quadrant3TextFill || q(this.primaryTextColor, {
        r: -10,
        g: -10,
        b: -10
      }), this.quadrant4TextFill = this.quadrant4TextFill || q(this.primaryTextColor, {
        r: -15,
        g: -15,
        b: -15
      }), this.quadrantPointFill = this.quadrantPointFill || wo(this.quadrant1Fill) ? mt(this.quadrant1Fill) : wt(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.radar = {
        axisColor: ((_a2 = this.radar) == null ? void 0 : _a2.axisColor) || this.lineColor,
        axisStrokeWidth: ((_b2 = this.radar) == null ? void 0 : _b2.axisStrokeWidth) || 2,
        axisLabelFontSize: ((_c2 = this.radar) == null ? void 0 : _c2.axisLabelFontSize) || 12,
        curveOpacity: ((_d2 = this.radar) == null ? void 0 : _d2.curveOpacity) || 0.5,
        curveStrokeWidth: ((_e2 = this.radar) == null ? void 0 : _e2.curveStrokeWidth) || 2,
        graticuleColor: ((_f2 = this.radar) == null ? void 0 : _f2.graticuleColor) || "#DEDEDE",
        graticuleStrokeWidth: ((_g3 = this.radar) == null ? void 0 : _g3.graticuleStrokeWidth) || 1,
        graticuleOpacity: ((_h3 = this.radar) == null ? void 0 : _h3.graticuleOpacity) || 0.3,
        legendBoxSize: ((_i2 = this.radar) == null ? void 0 : _i2.legendBoxSize) || 12,
        legendFontSize: ((_j2 = this.radar) == null ? void 0 : _j2.legendFontSize) || 12
      }, this.xyChart = {
        backgroundColor: ((_k = this.xyChart) == null ? void 0 : _k.backgroundColor) || this.background,
        titleColor: ((_l2 = this.xyChart) == null ? void 0 : _l2.titleColor) || this.primaryTextColor,
        xAxisTitleColor: ((_m = this.xyChart) == null ? void 0 : _m.xAxisTitleColor) || this.primaryTextColor,
        xAxisLabelColor: ((_n2 = this.xyChart) == null ? void 0 : _n2.xAxisLabelColor) || this.primaryTextColor,
        xAxisTickColor: ((_o2 = this.xyChart) == null ? void 0 : _o2.xAxisTickColor) || this.primaryTextColor,
        xAxisLineColor: ((_p2 = this.xyChart) == null ? void 0 : _p2.xAxisLineColor) || this.primaryTextColor,
        yAxisTitleColor: ((_q = this.xyChart) == null ? void 0 : _q.yAxisTitleColor) || this.primaryTextColor,
        yAxisLabelColor: ((_r = this.xyChart) == null ? void 0 : _r.yAxisLabelColor) || this.primaryTextColor,
        yAxisTickColor: ((_s = this.xyChart) == null ? void 0 : _s.yAxisTickColor) || this.primaryTextColor,
        yAxisLineColor: ((_t = this.xyChart) == null ? void 0 : _t.yAxisLineColor) || this.primaryTextColor,
        plotColorPalette: ((_u2 = this.xyChart) == null ? void 0 : _u2.plotColorPalette) || "#ECECFF,#8493A6,#FFC3A0,#DCDDE1,#B8E994,#D1A36F,#C3CDE6,#FFB6C1,#496078,#F8F3E3"
      }, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.labelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || q(this.primaryColor, {
        h: -30
      }), this.git4 = this.git4 || q(this.primaryColor, {
        h: -60
      }), this.git5 = this.git5 || q(this.primaryColor, {
        h: -90
      }), this.git6 = this.git6 || q(this.primaryColor, {
        h: 60
      }), this.git7 = this.git7 || q(this.primaryColor, {
        h: 120
      }), this.darkMode ? (this.git0 = mt(this.git0, 25), this.git1 = mt(this.git1, 25), this.git2 = mt(this.git2, 25), this.git3 = mt(this.git3, 25), this.git4 = mt(this.git4, 25), this.git5 = mt(this.git5, 25), this.git6 = mt(this.git6, 25), this.git7 = mt(this.git7, 25)) : (this.git0 = wt(this.git0, 25), this.git1 = wt(this.git1, 25), this.git2 = wt(this.git2, 25), this.git3 = wt(this.git3, 25), this.git4 = wt(this.git4, 25), this.git5 = wt(this.git5, 25), this.git6 = wt(this.git6, 25), this.git7 = wt(this.git7, 25)), this.gitInv0 = this.gitInv0 || wt(ht(this.git0), 25), this.gitInv1 = this.gitInv1 || ht(this.git1), this.gitInv2 = this.gitInv2 || ht(this.git2), this.gitInv3 = this.gitInv3 || ht(this.git3), this.gitInv4 = this.gitInv4 || ht(this.git4), this.gitInv5 = this.gitInv5 || ht(this.git5), this.gitInv6 = this.gitInv6 || ht(this.git6), this.gitInv7 = this.gitInv7 || ht(this.git7), this.gitBranchLabel0 = this.gitBranchLabel0 || ht(this.labelTextColor), this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor, this.gitBranchLabel3 = this.gitBranchLabel3 || ht(this.labelTextColor), this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || ih, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || rh;
    }
    calculate(t) {
      if (Object.keys(this).forEach((a) => {
        this[a] === "calculated" && (this[a] = void 0);
      }), typeof t != "object") {
        this.updateColors();
        return;
      }
      const e = Object.keys(t);
      e.forEach((a) => {
        this[a] = t[a];
      }), this.updateColors(), e.forEach((a) => {
        this[a] = t[a];
      });
    }
  }, v(_d, "Theme"), _d);
  rE = v((t) => {
    const e = new iE();
    return e.calculate(t), e;
  }, "getThemeVariables");
  aE = (_e = class {
    constructor() {
      this.background = "#f4f4f4", this.primaryColor = "#cde498", this.secondaryColor = "#cdffb2", this.background = "white", this.mainBkg = "#cde498", this.secondBkg = "#cdffb2", this.lineColor = "green", this.border1 = "#13540c", this.border2 = "#6eaa49", this.arrowheadColor = "green", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.tertiaryColor = mt("#cde498", 10), this.primaryBorderColor = ti(this.primaryColor, this.darkMode), this.secondaryBorderColor = ti(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = ti(this.tertiaryColor, this.darkMode), this.primaryTextColor = ht(this.primaryColor), this.secondaryTextColor = ht(this.secondaryColor), this.tertiaryTextColor = ht(this.primaryColor), this.lineColor = ht(this.background), this.textColor = ht(this.background), this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "#333", this.edgeLabelBackground = "#e8e8e8", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "black", this.actorLineColor = "calculated", this.signalColor = "#333", this.signalTextColor = "#333", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "#326932", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "#6eaa49", this.altSectionBkgColor = "white", this.sectionBkgColor2 = "#6eaa49", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "#487e3a", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "black", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "lightgrey", this.doneTaskBkgColor = "lightgrey", this.doneTaskBorderColor = "grey", this.critBorderColor = "#ff8888", this.critBkgColor = "red", this.todayLineColor = "red", this.vertLineColor = "#00BFFF", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222";
    }
    updateColors() {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g3, _h3, _i2, _j2, _k, _l2, _m, _n2, _o2, _p2, _q, _r, _s, _t, _u2;
      this.actorBorder = wt(this.mainBkg, 20), this.actorBkg = this.mainBkg, this.labelBoxBkgColor = this.actorBkg, this.labelTextColor = this.actorTextColor, this.loopTextColor = this.actorTextColor, this.noteBorderColor = this.border2, this.noteTextColor = this.actorTextColor, this.actorLineColor = this.actorBorder, this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || q(this.primaryColor, {
        h: 30
      }), this.cScale4 = this.cScale4 || q(this.primaryColor, {
        h: 60
      }), this.cScale5 = this.cScale5 || q(this.primaryColor, {
        h: 90
      }), this.cScale6 = this.cScale6 || q(this.primaryColor, {
        h: 120
      }), this.cScale7 = this.cScale7 || q(this.primaryColor, {
        h: 150
      }), this.cScale8 = this.cScale8 || q(this.primaryColor, {
        h: 210
      }), this.cScale9 = this.cScale9 || q(this.primaryColor, {
        h: 270
      }), this.cScale10 = this.cScale10 || q(this.primaryColor, {
        h: 300
      }), this.cScale11 = this.cScale11 || q(this.primaryColor, {
        h: 330
      }), this.cScalePeer1 = this.cScalePeer1 || wt(this.secondaryColor, 45), this.cScalePeer2 = this.cScalePeer2 || wt(this.tertiaryColor, 40);
      for (let t = 0; t < this.THEME_COLOR_LIMIT; t++) this["cScale" + t] = wt(this["cScale" + t], 10), this["cScalePeer" + t] = this["cScalePeer" + t] || wt(this["cScale" + t], 25);
      for (let t = 0; t < this.THEME_COLOR_LIMIT; t++) this["cScaleInv" + t] = this["cScaleInv" + t] || q(this["cScale" + t], {
        h: 180
      });
      this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor;
      for (let t = 0; t < this.THEME_COLOR_LIMIT; t++) this["cScaleLabel" + t] = this["cScaleLabel" + t] || this.scaleLabelColor;
      for (let t = 0; t < 5; t++) this["surface" + t] = this["surface" + t] || q(this.mainBkg, {
        h: 30,
        s: -30,
        l: -(5 + t * 5)
      }), this["surfacePeer" + t] = this["surfacePeer" + t] || q(this.mainBkg, {
        h: 30,
        s: -30,
        l: -(8 + t * 5)
      });
      this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.taskBorderColor = this.border1, this.taskTextColor = this.taskTextLightColor, this.taskTextOutsideColor = this.taskTextDarkColor, this.activeTaskBorderColor = this.taskBorderColor, this.activeTaskBkgColor = this.mainBkg, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.rowOdd = this.rowOdd || mt(this.mainBkg, 75) || "#ffffff", this.rowEven = this.rowEven || mt(this.mainBkg, 20), this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f0f0f0", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = this.lineColor, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = q(this.primaryColor, {
        h: 64
      }), this.fillType3 = q(this.secondaryColor, {
        h: 64
      }), this.fillType4 = q(this.primaryColor, {
        h: -64
      }), this.fillType5 = q(this.secondaryColor, {
        h: -64
      }), this.fillType6 = q(this.primaryColor, {
        h: 128
      }), this.fillType7 = q(this.secondaryColor, {
        h: 128
      }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || this.tertiaryColor, this.pie4 = this.pie4 || q(this.primaryColor, {
        l: -30
      }), this.pie5 = this.pie5 || q(this.secondaryColor, {
        l: -30
      }), this.pie6 = this.pie6 || q(this.tertiaryColor, {
        h: 40,
        l: -40
      }), this.pie7 = this.pie7 || q(this.primaryColor, {
        h: 60,
        l: -10
      }), this.pie8 = this.pie8 || q(this.primaryColor, {
        h: -60,
        l: -10
      }), this.pie9 = this.pie9 || q(this.primaryColor, {
        h: 120,
        l: 0
      }), this.pie10 = this.pie10 || q(this.primaryColor, {
        h: 60,
        l: -50
      }), this.pie11 = this.pie11 || q(this.primaryColor, {
        h: -60,
        l: -50
      }), this.pie12 = this.pie12 || q(this.primaryColor, {
        h: 120,
        l: -50
      }), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || q(this.primaryColor, {
        r: 5,
        g: 5,
        b: 5
      }), this.quadrant3Fill = this.quadrant3Fill || q(this.primaryColor, {
        r: 10,
        g: 10,
        b: 10
      }), this.quadrant4Fill = this.quadrant4Fill || q(this.primaryColor, {
        r: 15,
        g: 15,
        b: 15
      }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || q(this.primaryTextColor, {
        r: -5,
        g: -5,
        b: -5
      }), this.quadrant3TextFill = this.quadrant3TextFill || q(this.primaryTextColor, {
        r: -10,
        g: -10,
        b: -10
      }), this.quadrant4TextFill = this.quadrant4TextFill || q(this.primaryTextColor, {
        r: -15,
        g: -15,
        b: -15
      }), this.quadrantPointFill = this.quadrantPointFill || wo(this.quadrant1Fill) ? mt(this.quadrant1Fill) : wt(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.packet = {
        startByteColor: this.primaryTextColor,
        endByteColor: this.primaryTextColor,
        labelColor: this.primaryTextColor,
        titleColor: this.primaryTextColor,
        blockStrokeColor: this.primaryTextColor,
        blockFillColor: this.mainBkg
      }, this.radar = {
        axisColor: ((_a2 = this.radar) == null ? void 0 : _a2.axisColor) || this.lineColor,
        axisStrokeWidth: ((_b2 = this.radar) == null ? void 0 : _b2.axisStrokeWidth) || 2,
        axisLabelFontSize: ((_c2 = this.radar) == null ? void 0 : _c2.axisLabelFontSize) || 12,
        curveOpacity: ((_d2 = this.radar) == null ? void 0 : _d2.curveOpacity) || 0.5,
        curveStrokeWidth: ((_e2 = this.radar) == null ? void 0 : _e2.curveStrokeWidth) || 2,
        graticuleColor: ((_f2 = this.radar) == null ? void 0 : _f2.graticuleColor) || "#DEDEDE",
        graticuleStrokeWidth: ((_g3 = this.radar) == null ? void 0 : _g3.graticuleStrokeWidth) || 1,
        graticuleOpacity: ((_h3 = this.radar) == null ? void 0 : _h3.graticuleOpacity) || 0.3,
        legendBoxSize: ((_i2 = this.radar) == null ? void 0 : _i2.legendBoxSize) || 12,
        legendFontSize: ((_j2 = this.radar) == null ? void 0 : _j2.legendFontSize) || 12
      }, this.xyChart = {
        backgroundColor: ((_k = this.xyChart) == null ? void 0 : _k.backgroundColor) || this.background,
        titleColor: ((_l2 = this.xyChart) == null ? void 0 : _l2.titleColor) || this.primaryTextColor,
        xAxisTitleColor: ((_m = this.xyChart) == null ? void 0 : _m.xAxisTitleColor) || this.primaryTextColor,
        xAxisLabelColor: ((_n2 = this.xyChart) == null ? void 0 : _n2.xAxisLabelColor) || this.primaryTextColor,
        xAxisTickColor: ((_o2 = this.xyChart) == null ? void 0 : _o2.xAxisTickColor) || this.primaryTextColor,
        xAxisLineColor: ((_p2 = this.xyChart) == null ? void 0 : _p2.xAxisLineColor) || this.primaryTextColor,
        yAxisTitleColor: ((_q = this.xyChart) == null ? void 0 : _q.yAxisTitleColor) || this.primaryTextColor,
        yAxisLabelColor: ((_r = this.xyChart) == null ? void 0 : _r.yAxisLabelColor) || this.primaryTextColor,
        yAxisTickColor: ((_s = this.xyChart) == null ? void 0 : _s.yAxisTickColor) || this.primaryTextColor,
        yAxisLineColor: ((_t = this.xyChart) == null ? void 0 : _t.yAxisLineColor) || this.primaryTextColor,
        plotColorPalette: ((_u2 = this.xyChart) == null ? void 0 : _u2.plotColorPalette) || "#CDE498,#FF6B6B,#A0D2DB,#D7BDE2,#F0F0F0,#FFC3A0,#7FD8BE,#FF9A8B,#FAF3E0,#FFF176"
      }, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || q(this.primaryColor, {
        h: -30
      }), this.git4 = this.git4 || q(this.primaryColor, {
        h: -60
      }), this.git5 = this.git5 || q(this.primaryColor, {
        h: -90
      }), this.git6 = this.git6 || q(this.primaryColor, {
        h: 60
      }), this.git7 = this.git7 || q(this.primaryColor, {
        h: 120
      }), this.darkMode ? (this.git0 = mt(this.git0, 25), this.git1 = mt(this.git1, 25), this.git2 = mt(this.git2, 25), this.git3 = mt(this.git3, 25), this.git4 = mt(this.git4, 25), this.git5 = mt(this.git5, 25), this.git6 = mt(this.git6, 25), this.git7 = mt(this.git7, 25)) : (this.git0 = wt(this.git0, 25), this.git1 = wt(this.git1, 25), this.git2 = wt(this.git2, 25), this.git3 = wt(this.git3, 25), this.git4 = wt(this.git4, 25), this.git5 = wt(this.git5, 25), this.git6 = wt(this.git6, 25), this.git7 = wt(this.git7, 25)), this.gitInv0 = this.gitInv0 || ht(this.git0), this.gitInv1 = this.gitInv1 || ht(this.git1), this.gitInv2 = this.gitInv2 || ht(this.git2), this.gitInv3 = this.gitInv3 || ht(this.git3), this.gitInv4 = this.gitInv4 || ht(this.git4), this.gitInv5 = this.gitInv5 || ht(this.git5), this.gitInv6 = this.gitInv6 || ht(this.git6), this.gitInv7 = this.gitInv7 || ht(this.git7), this.gitBranchLabel0 = this.gitBranchLabel0 || ht(this.labelTextColor), this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor, this.gitBranchLabel3 = this.gitBranchLabel3 || ht(this.labelTextColor), this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || ih, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || rh;
    }
    calculate(t) {
      if (typeof t != "object") {
        this.updateColors();
        return;
      }
      const e = Object.keys(t);
      e.forEach((a) => {
        this[a] = t[a];
      }), this.updateColors(), e.forEach((a) => {
        this[a] = t[a];
      });
    }
  }, v(_e, "Theme"), _e);
  nE = v((t) => {
    const e = new aE();
    return e.calculate(t), e;
  }, "getThemeVariables");
  lE = (_f = class {
    constructor() {
      this.primaryColor = "#eee", this.contrast = "#707070", this.secondaryColor = mt(this.contrast, 55), this.background = "#ffffff", this.tertiaryColor = q(this.primaryColor, {
        h: -160
      }), this.primaryBorderColor = ti(this.primaryColor, this.darkMode), this.secondaryBorderColor = ti(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = ti(this.tertiaryColor, this.darkMode), this.primaryTextColor = ht(this.primaryColor), this.secondaryTextColor = ht(this.secondaryColor), this.tertiaryTextColor = ht(this.tertiaryColor), this.lineColor = ht(this.background), this.textColor = ht(this.background), this.mainBkg = "#eee", this.secondBkg = "calculated", this.lineColor = "#666", this.border1 = "#999", this.border2 = "calculated", this.note = "#ffa", this.text = "#333", this.critical = "#d42", this.done = "#bbb", this.arrowheadColor = "#333333", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "calculated", this.edgeLabelBackground = "white", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "calculated", this.actorLineColor = this.actorBorder, this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "calculated", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "calculated", this.altSectionBkgColor = "white", this.sectionBkgColor2 = "calculated", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "calculated", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "calculated", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "calculated", this.critBkgColor = "calculated", this.critBorderColor = "calculated", this.todayLineColor = "calculated", this.vertLineColor = "calculated", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.rowOdd = this.rowOdd || mt(this.mainBkg, 75) || "#ffffff", this.rowEven = this.rowEven || "#f4f4f4", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222";
    }
    updateColors() {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g3, _h3, _i2, _j2, _k, _l2, _m, _n2, _o2, _p2, _q, _r, _s, _t, _u2;
      this.secondBkg = mt(this.contrast, 55), this.border2 = this.contrast, this.actorBorder = mt(this.border1, 23), this.actorBkg = this.mainBkg, this.actorTextColor = this.text, this.actorLineColor = this.actorBorder, this.signalColor = this.text, this.signalTextColor = this.text, this.labelBoxBkgColor = this.actorBkg, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.text, this.loopTextColor = this.text, this.noteBorderColor = "#999", this.noteBkgColor = "#666", this.noteTextColor = "#fff", this.cScale0 = this.cScale0 || "#555", this.cScale1 = this.cScale1 || "#F4F4F4", this.cScale2 = this.cScale2 || "#555", this.cScale3 = this.cScale3 || "#BBB", this.cScale4 = this.cScale4 || "#777", this.cScale5 = this.cScale5 || "#999", this.cScale6 = this.cScale6 || "#DDD", this.cScale7 = this.cScale7 || "#FFF", this.cScale8 = this.cScale8 || "#DDD", this.cScale9 = this.cScale9 || "#BBB", this.cScale10 = this.cScale10 || "#999", this.cScale11 = this.cScale11 || "#777";
      for (let t = 0; t < this.THEME_COLOR_LIMIT; t++) this["cScaleInv" + t] = this["cScaleInv" + t] || ht(this["cScale" + t]);
      for (let t = 0; t < this.THEME_COLOR_LIMIT; t++) this.darkMode ? this["cScalePeer" + t] = this["cScalePeer" + t] || mt(this["cScale" + t], 10) : this["cScalePeer" + t] = this["cScalePeer" + t] || wt(this["cScale" + t], 10);
      this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor), this.cScaleLabel0 = this.cScaleLabel0 || this.cScale1, this.cScaleLabel2 = this.cScaleLabel2 || this.cScale1;
      for (let t = 0; t < this.THEME_COLOR_LIMIT; t++) this["cScaleLabel" + t] = this["cScaleLabel" + t] || this.scaleLabelColor;
      for (let t = 0; t < 5; t++) this["surface" + t] = this["surface" + t] || q(this.mainBkg, {
        l: -(5 + t * 5)
      }), this["surfacePeer" + t] = this["surfacePeer" + t] || q(this.mainBkg, {
        l: -(8 + t * 5)
      });
      this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.titleColor = this.text, this.sectionBkgColor = mt(this.contrast, 30), this.sectionBkgColor2 = mt(this.contrast, 30), this.taskBorderColor = wt(this.contrast, 10), this.taskBkgColor = this.contrast, this.taskTextColor = this.taskTextLightColor, this.taskTextDarkColor = this.text, this.taskTextOutsideColor = this.taskTextDarkColor, this.activeTaskBorderColor = this.taskBorderColor, this.activeTaskBkgColor = this.mainBkg, this.gridColor = mt(this.border1, 30), this.doneTaskBkgColor = this.done, this.doneTaskBorderColor = this.lineColor, this.critBkgColor = this.critical, this.critBorderColor = wt(this.critBkgColor, 10), this.todayLineColor = this.critBkgColor, this.vertLineColor = this.critBkgColor, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.transitionColor = this.transitionColor || "#000", this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f4f4f4", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.stateBorder = this.stateBorder || "#000", this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = "#222", this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = q(this.primaryColor, {
        h: 64
      }), this.fillType3 = q(this.secondaryColor, {
        h: 64
      }), this.fillType4 = q(this.primaryColor, {
        h: -64
      }), this.fillType5 = q(this.secondaryColor, {
        h: -64
      }), this.fillType6 = q(this.primaryColor, {
        h: 128
      }), this.fillType7 = q(this.secondaryColor, {
        h: 128
      });
      for (let t = 0; t < this.THEME_COLOR_LIMIT; t++) this["pie" + t] = this["cScale" + t];
      this.pie12 = this.pie0, this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || q(this.primaryColor, {
        r: 5,
        g: 5,
        b: 5
      }), this.quadrant3Fill = this.quadrant3Fill || q(this.primaryColor, {
        r: 10,
        g: 10,
        b: 10
      }), this.quadrant4Fill = this.quadrant4Fill || q(this.primaryColor, {
        r: 15,
        g: 15,
        b: 15
      }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || q(this.primaryTextColor, {
        r: -5,
        g: -5,
        b: -5
      }), this.quadrant3TextFill = this.quadrant3TextFill || q(this.primaryTextColor, {
        r: -10,
        g: -10,
        b: -10
      }), this.quadrant4TextFill = this.quadrant4TextFill || q(this.primaryTextColor, {
        r: -15,
        g: -15,
        b: -15
      }), this.quadrantPointFill = this.quadrantPointFill || wo(this.quadrant1Fill) ? mt(this.quadrant1Fill) : wt(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.xyChart = {
        backgroundColor: ((_a2 = this.xyChart) == null ? void 0 : _a2.backgroundColor) || this.background,
        titleColor: ((_b2 = this.xyChart) == null ? void 0 : _b2.titleColor) || this.primaryTextColor,
        xAxisTitleColor: ((_c2 = this.xyChart) == null ? void 0 : _c2.xAxisTitleColor) || this.primaryTextColor,
        xAxisLabelColor: ((_d2 = this.xyChart) == null ? void 0 : _d2.xAxisLabelColor) || this.primaryTextColor,
        xAxisTickColor: ((_e2 = this.xyChart) == null ? void 0 : _e2.xAxisTickColor) || this.primaryTextColor,
        xAxisLineColor: ((_f2 = this.xyChart) == null ? void 0 : _f2.xAxisLineColor) || this.primaryTextColor,
        yAxisTitleColor: ((_g3 = this.xyChart) == null ? void 0 : _g3.yAxisTitleColor) || this.primaryTextColor,
        yAxisLabelColor: ((_h3 = this.xyChart) == null ? void 0 : _h3.yAxisLabelColor) || this.primaryTextColor,
        yAxisTickColor: ((_i2 = this.xyChart) == null ? void 0 : _i2.yAxisTickColor) || this.primaryTextColor,
        yAxisLineColor: ((_j2 = this.xyChart) == null ? void 0 : _j2.yAxisLineColor) || this.primaryTextColor,
        plotColorPalette: ((_k = this.xyChart) == null ? void 0 : _k.plotColorPalette) || "#EEE,#6BB8E4,#8ACB88,#C7ACD6,#E8DCC2,#FFB2A8,#FFF380,#7E8D91,#FFD8B1,#FAF3E0"
      }, this.radar = {
        axisColor: ((_l2 = this.radar) == null ? void 0 : _l2.axisColor) || this.lineColor,
        axisStrokeWidth: ((_m = this.radar) == null ? void 0 : _m.axisStrokeWidth) || 2,
        axisLabelFontSize: ((_n2 = this.radar) == null ? void 0 : _n2.axisLabelFontSize) || 12,
        curveOpacity: ((_o2 = this.radar) == null ? void 0 : _o2.curveOpacity) || 0.5,
        curveStrokeWidth: ((_p2 = this.radar) == null ? void 0 : _p2.curveStrokeWidth) || 2,
        graticuleColor: ((_q = this.radar) == null ? void 0 : _q.graticuleColor) || "#DEDEDE",
        graticuleStrokeWidth: ((_r = this.radar) == null ? void 0 : _r.graticuleStrokeWidth) || 1,
        graticuleOpacity: ((_s = this.radar) == null ? void 0 : _s.graticuleOpacity) || 0.3,
        legendBoxSize: ((_t = this.radar) == null ? void 0 : _t.legendBoxSize) || 12,
        legendFontSize: ((_u2 = this.radar) == null ? void 0 : _u2.legendFontSize) || 12
      }, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = wt(this.pie1, 25) || this.primaryColor, this.git1 = this.pie2 || this.secondaryColor, this.git2 = this.pie3 || this.tertiaryColor, this.git3 = this.pie4 || q(this.primaryColor, {
        h: -30
      }), this.git4 = this.pie5 || q(this.primaryColor, {
        h: -60
      }), this.git5 = this.pie6 || q(this.primaryColor, {
        h: -90
      }), this.git6 = this.pie7 || q(this.primaryColor, {
        h: 60
      }), this.git7 = this.pie8 || q(this.primaryColor, {
        h: 120
      }), this.gitInv0 = this.gitInv0 || ht(this.git0), this.gitInv1 = this.gitInv1 || ht(this.git1), this.gitInv2 = this.gitInv2 || ht(this.git2), this.gitInv3 = this.gitInv3 || ht(this.git3), this.gitInv4 = this.gitInv4 || ht(this.git4), this.gitInv5 = this.gitInv5 || ht(this.git5), this.gitInv6 = this.gitInv6 || ht(this.git6), this.gitInv7 = this.gitInv7 || ht(this.git7), this.branchLabelColor = this.branchLabelColor || this.labelTextColor, this.gitBranchLabel0 = this.branchLabelColor, this.gitBranchLabel1 = "white", this.gitBranchLabel2 = this.branchLabelColor, this.gitBranchLabel3 = "white", this.gitBranchLabel4 = this.branchLabelColor, this.gitBranchLabel5 = this.branchLabelColor, this.gitBranchLabel6 = this.branchLabelColor, this.gitBranchLabel7 = this.branchLabelColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || ih, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || rh;
    }
    calculate(t) {
      if (typeof t != "object") {
        this.updateColors();
        return;
      }
      const e = Object.keys(t);
      e.forEach((a) => {
        this[a] = t[a];
      }), this.updateColors(), e.forEach((a) => {
        this[a] = t[a];
      });
    }
  }, v(_f, "Theme"), _f);
  sE = v((t) => {
    const e = new lE();
    return e.calculate(t), e;
  }, "getThemeVariables");
  Xr = {
    base: {
      getThemeVariables: JA
    },
    dark: {
      getThemeVariables: eE
    },
    default: {
      getThemeVariables: rE
    },
    forest: {
      getThemeVariables: nE
    },
    neutral: {
      getThemeVariables: sE
    }
  };
  fr = {
    flowchart: {
      useMaxWidth: true,
      titleTopMargin: 25,
      subGraphTitleMargin: {
        top: 0,
        bottom: 0
      },
      diagramPadding: 8,
      htmlLabels: true,
      nodeSpacing: 50,
      rankSpacing: 50,
      curve: "basis",
      padding: 15,
      defaultRenderer: "dagre-wrapper",
      wrappingWidth: 200,
      inheritDir: false
    },
    sequence: {
      useMaxWidth: true,
      hideUnusedParticipants: false,
      activationWidth: 10,
      diagramMarginX: 50,
      diagramMarginY: 10,
      actorMargin: 50,
      width: 150,
      height: 65,
      boxMargin: 10,
      boxTextMargin: 5,
      noteMargin: 10,
      messageMargin: 35,
      messageAlign: "center",
      mirrorActors: true,
      forceMenus: false,
      bottomMarginAdj: 1,
      rightAngles: false,
      showSequenceNumbers: false,
      actorFontSize: 14,
      actorFontFamily: '"Open Sans", sans-serif',
      actorFontWeight: 400,
      noteFontSize: 14,
      noteFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
      noteFontWeight: 400,
      noteAlign: "center",
      messageFontSize: 16,
      messageFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
      messageFontWeight: 400,
      wrap: false,
      wrapPadding: 10,
      labelBoxWidth: 50,
      labelBoxHeight: 20
    },
    gantt: {
      useMaxWidth: true,
      titleTopMargin: 25,
      barHeight: 20,
      barGap: 4,
      topPadding: 50,
      rightPadding: 75,
      leftPadding: 75,
      gridLineStartPadding: 35,
      fontSize: 11,
      sectionFontSize: 11,
      numberSectionStyles: 4,
      axisFormat: "%Y-%m-%d",
      topAxis: false,
      displayMode: "",
      weekday: "sunday"
    },
    journey: {
      useMaxWidth: true,
      diagramMarginX: 50,
      diagramMarginY: 10,
      leftMargin: 150,
      maxLabelWidth: 360,
      width: 150,
      height: 50,
      boxMargin: 10,
      boxTextMargin: 5,
      noteMargin: 10,
      messageMargin: 35,
      messageAlign: "center",
      bottomMarginAdj: 1,
      rightAngles: false,
      taskFontSize: 14,
      taskFontFamily: '"Open Sans", sans-serif',
      taskMargin: 50,
      activationWidth: 10,
      textPlacement: "fo",
      actorColours: [
        "#8FBC8F",
        "#7CFC00",
        "#00FFFF",
        "#20B2AA",
        "#B0E0E6",
        "#FFFFE0"
      ],
      sectionFills: [
        "#191970",
        "#8B008B",
        "#4B0082",
        "#2F4F4F",
        "#800000",
        "#8B4513",
        "#00008B"
      ],
      sectionColours: [
        "#fff"
      ],
      titleColor: "",
      titleFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
      titleFontSize: "4ex"
    },
    class: {
      useMaxWidth: true,
      titleTopMargin: 25,
      arrowMarkerAbsolute: false,
      dividerMargin: 10,
      padding: 5,
      textHeight: 10,
      defaultRenderer: "dagre-wrapper",
      htmlLabels: false,
      hideEmptyMembersBox: false
    },
    state: {
      useMaxWidth: true,
      titleTopMargin: 25,
      dividerMargin: 10,
      sizeUnit: 5,
      padding: 8,
      textHeight: 10,
      titleShift: -15,
      noteMargin: 10,
      forkWidth: 70,
      forkHeight: 7,
      miniPadding: 2,
      fontSizeFactor: 5.02,
      fontSize: 24,
      labelHeight: 16,
      edgeLengthFactor: "20",
      compositTitleSize: 35,
      radius: 5,
      defaultRenderer: "dagre-wrapper"
    },
    er: {
      useMaxWidth: true,
      titleTopMargin: 25,
      diagramPadding: 20,
      layoutDirection: "TB",
      minEntityWidth: 100,
      minEntityHeight: 75,
      entityPadding: 15,
      nodeSpacing: 140,
      rankSpacing: 80,
      stroke: "gray",
      fill: "honeydew",
      fontSize: 12
    },
    pie: {
      useMaxWidth: true,
      textPosition: 0.75
    },
    quadrantChart: {
      useMaxWidth: true,
      chartWidth: 500,
      chartHeight: 500,
      titleFontSize: 20,
      titlePadding: 10,
      quadrantPadding: 5,
      xAxisLabelPadding: 5,
      yAxisLabelPadding: 5,
      xAxisLabelFontSize: 16,
      yAxisLabelFontSize: 16,
      quadrantLabelFontSize: 16,
      quadrantTextTopPadding: 5,
      pointTextPadding: 5,
      pointLabelFontSize: 12,
      pointRadius: 5,
      xAxisPosition: "top",
      yAxisPosition: "left",
      quadrantInternalBorderStrokeWidth: 1,
      quadrantExternalBorderStrokeWidth: 2
    },
    xyChart: {
      useMaxWidth: true,
      width: 700,
      height: 500,
      titleFontSize: 20,
      titlePadding: 10,
      showDataLabel: false,
      showTitle: true,
      xAxis: {
        $ref: "#/$defs/XYChartAxisConfig",
        showLabel: true,
        labelFontSize: 14,
        labelPadding: 5,
        showTitle: true,
        titleFontSize: 16,
        titlePadding: 5,
        showTick: true,
        tickLength: 5,
        tickWidth: 2,
        showAxisLine: true,
        axisLineWidth: 2
      },
      yAxis: {
        $ref: "#/$defs/XYChartAxisConfig",
        showLabel: true,
        labelFontSize: 14,
        labelPadding: 5,
        showTitle: true,
        titleFontSize: 16,
        titlePadding: 5,
        showTick: true,
        tickLength: 5,
        tickWidth: 2,
        showAxisLine: true,
        axisLineWidth: 2
      },
      chartOrientation: "vertical",
      plotReservedSpacePercent: 50
    },
    requirement: {
      useMaxWidth: true,
      rect_fill: "#f9f9f9",
      text_color: "#333",
      rect_border_size: "0.5px",
      rect_border_color: "#bbb",
      rect_min_width: 200,
      rect_min_height: 200,
      fontSize: 14,
      rect_padding: 10,
      line_height: 20
    },
    mindmap: {
      useMaxWidth: true,
      padding: 10,
      maxNodeWidth: 200,
      layoutAlgorithm: "cose-bilkent"
    },
    kanban: {
      useMaxWidth: true,
      padding: 8,
      sectionWidth: 200,
      ticketBaseUrl: ""
    },
    timeline: {
      useMaxWidth: true,
      diagramMarginX: 50,
      diagramMarginY: 10,
      leftMargin: 150,
      width: 150,
      height: 50,
      boxMargin: 10,
      boxTextMargin: 5,
      noteMargin: 10,
      messageMargin: 35,
      messageAlign: "center",
      bottomMarginAdj: 1,
      rightAngles: false,
      taskFontSize: 14,
      taskFontFamily: '"Open Sans", sans-serif',
      taskMargin: 50,
      activationWidth: 10,
      textPlacement: "fo",
      actorColours: [
        "#8FBC8F",
        "#7CFC00",
        "#00FFFF",
        "#20B2AA",
        "#B0E0E6",
        "#FFFFE0"
      ],
      sectionFills: [
        "#191970",
        "#8B008B",
        "#4B0082",
        "#2F4F4F",
        "#800000",
        "#8B4513",
        "#00008B"
      ],
      sectionColours: [
        "#fff"
      ],
      disableMulticolor: false
    },
    gitGraph: {
      useMaxWidth: true,
      titleTopMargin: 25,
      diagramPadding: 8,
      nodeLabel: {
        width: 75,
        height: 100,
        x: -25,
        y: 0
      },
      mainBranchName: "main",
      mainBranchOrder: 0,
      showCommitLabel: true,
      showBranches: true,
      rotateCommitLabel: true,
      parallelCommits: false,
      arrowMarkerAbsolute: false
    },
    c4: {
      useMaxWidth: true,
      diagramMarginX: 50,
      diagramMarginY: 10,
      c4ShapeMargin: 50,
      c4ShapePadding: 20,
      width: 216,
      height: 60,
      boxMargin: 10,
      c4ShapeInRow: 4,
      nextLinePaddingX: 0,
      c4BoundaryInRow: 2,
      personFontSize: 14,
      personFontFamily: '"Open Sans", sans-serif',
      personFontWeight: "normal",
      external_personFontSize: 14,
      external_personFontFamily: '"Open Sans", sans-serif',
      external_personFontWeight: "normal",
      systemFontSize: 14,
      systemFontFamily: '"Open Sans", sans-serif',
      systemFontWeight: "normal",
      external_systemFontSize: 14,
      external_systemFontFamily: '"Open Sans", sans-serif',
      external_systemFontWeight: "normal",
      system_dbFontSize: 14,
      system_dbFontFamily: '"Open Sans", sans-serif',
      system_dbFontWeight: "normal",
      external_system_dbFontSize: 14,
      external_system_dbFontFamily: '"Open Sans", sans-serif',
      external_system_dbFontWeight: "normal",
      system_queueFontSize: 14,
      system_queueFontFamily: '"Open Sans", sans-serif',
      system_queueFontWeight: "normal",
      external_system_queueFontSize: 14,
      external_system_queueFontFamily: '"Open Sans", sans-serif',
      external_system_queueFontWeight: "normal",
      boundaryFontSize: 14,
      boundaryFontFamily: '"Open Sans", sans-serif',
      boundaryFontWeight: "normal",
      messageFontSize: 12,
      messageFontFamily: '"Open Sans", sans-serif',
      messageFontWeight: "normal",
      containerFontSize: 14,
      containerFontFamily: '"Open Sans", sans-serif',
      containerFontWeight: "normal",
      external_containerFontSize: 14,
      external_containerFontFamily: '"Open Sans", sans-serif',
      external_containerFontWeight: "normal",
      container_dbFontSize: 14,
      container_dbFontFamily: '"Open Sans", sans-serif',
      container_dbFontWeight: "normal",
      external_container_dbFontSize: 14,
      external_container_dbFontFamily: '"Open Sans", sans-serif',
      external_container_dbFontWeight: "normal",
      container_queueFontSize: 14,
      container_queueFontFamily: '"Open Sans", sans-serif',
      container_queueFontWeight: "normal",
      external_container_queueFontSize: 14,
      external_container_queueFontFamily: '"Open Sans", sans-serif',
      external_container_queueFontWeight: "normal",
      componentFontSize: 14,
      componentFontFamily: '"Open Sans", sans-serif',
      componentFontWeight: "normal",
      external_componentFontSize: 14,
      external_componentFontFamily: '"Open Sans", sans-serif',
      external_componentFontWeight: "normal",
      component_dbFontSize: 14,
      component_dbFontFamily: '"Open Sans", sans-serif',
      component_dbFontWeight: "normal",
      external_component_dbFontSize: 14,
      external_component_dbFontFamily: '"Open Sans", sans-serif',
      external_component_dbFontWeight: "normal",
      component_queueFontSize: 14,
      component_queueFontFamily: '"Open Sans", sans-serif',
      component_queueFontWeight: "normal",
      external_component_queueFontSize: 14,
      external_component_queueFontFamily: '"Open Sans", sans-serif',
      external_component_queueFontWeight: "normal",
      wrap: true,
      wrapPadding: 10,
      person_bg_color: "#08427B",
      person_border_color: "#073B6F",
      external_person_bg_color: "#686868",
      external_person_border_color: "#8A8A8A",
      system_bg_color: "#1168BD",
      system_border_color: "#3C7FC0",
      system_db_bg_color: "#1168BD",
      system_db_border_color: "#3C7FC0",
      system_queue_bg_color: "#1168BD",
      system_queue_border_color: "#3C7FC0",
      external_system_bg_color: "#999999",
      external_system_border_color: "#8A8A8A",
      external_system_db_bg_color: "#999999",
      external_system_db_border_color: "#8A8A8A",
      external_system_queue_bg_color: "#999999",
      external_system_queue_border_color: "#8A8A8A",
      container_bg_color: "#438DD5",
      container_border_color: "#3C7FC0",
      container_db_bg_color: "#438DD5",
      container_db_border_color: "#3C7FC0",
      container_queue_bg_color: "#438DD5",
      container_queue_border_color: "#3C7FC0",
      external_container_bg_color: "#B3B3B3",
      external_container_border_color: "#A6A6A6",
      external_container_db_bg_color: "#B3B3B3",
      external_container_db_border_color: "#A6A6A6",
      external_container_queue_bg_color: "#B3B3B3",
      external_container_queue_border_color: "#A6A6A6",
      component_bg_color: "#85BBF0",
      component_border_color: "#78A8D8",
      component_db_bg_color: "#85BBF0",
      component_db_border_color: "#78A8D8",
      component_queue_bg_color: "#85BBF0",
      component_queue_border_color: "#78A8D8",
      external_component_bg_color: "#CCCCCC",
      external_component_border_color: "#BFBFBF",
      external_component_db_bg_color: "#CCCCCC",
      external_component_db_border_color: "#BFBFBF",
      external_component_queue_bg_color: "#CCCCCC",
      external_component_queue_border_color: "#BFBFBF"
    },
    sankey: {
      useMaxWidth: true,
      width: 600,
      height: 400,
      linkColor: "gradient",
      nodeAlignment: "justify",
      showValues: true,
      prefix: "",
      suffix: ""
    },
    block: {
      useMaxWidth: true,
      padding: 8
    },
    packet: {
      useMaxWidth: true,
      rowHeight: 32,
      bitWidth: 32,
      bitsPerRow: 32,
      showBits: true,
      paddingX: 5,
      paddingY: 5
    },
    architecture: {
      useMaxWidth: true,
      padding: 40,
      iconSize: 80,
      fontSize: 16
    },
    radar: {
      useMaxWidth: true,
      width: 600,
      height: 600,
      marginTop: 50,
      marginRight: 50,
      marginBottom: 50,
      marginLeft: 50,
      axisScaleFactor: 1,
      axisLabelFactor: 1.05,
      curveTension: 0.17
    },
    theme: "default",
    look: "classic",
    handDrawnSeed: 0,
    layout: "dagre",
    maxTextSize: 5e4,
    maxEdges: 500,
    darkMode: false,
    fontFamily: '"trebuchet ms", verdana, arial, sans-serif;',
    logLevel: 5,
    securityLevel: "strict",
    startOnLoad: true,
    arrowMarkerAbsolute: false,
    secure: [
      "secure",
      "securityLevel",
      "startOnLoad",
      "maxTextSize",
      "suppressErrorRendering",
      "maxEdges"
    ],
    legacyMathML: false,
    forceLegacyMathML: false,
    deterministicIds: false,
    fontSize: 16,
    markdownAutoWrap: true,
    suppressErrorRendering: false
  };
  Ix = {
    ...fr,
    deterministicIDSeed: void 0,
    elk: {
      mergeEdges: false,
      nodePlacementStrategy: "BRANDES_KOEPF",
      forceNodeModelOrder: false,
      considerModelOrder: "NODES_AND_EDGES"
    },
    themeCSS: void 0,
    themeVariables: Xr.default.getThemeVariables(),
    sequence: {
      ...fr.sequence,
      messageFont: v(function() {
        return {
          fontFamily: this.messageFontFamily,
          fontSize: this.messageFontSize,
          fontWeight: this.messageFontWeight
        };
      }, "messageFont"),
      noteFont: v(function() {
        return {
          fontFamily: this.noteFontFamily,
          fontSize: this.noteFontSize,
          fontWeight: this.noteFontWeight
        };
      }, "noteFont"),
      actorFont: v(function() {
        return {
          fontFamily: this.actorFontFamily,
          fontSize: this.actorFontSize,
          fontWeight: this.actorFontWeight
        };
      }, "actorFont")
    },
    class: {
      hideEmptyMembersBox: false
    },
    gantt: {
      ...fr.gantt,
      tickInterval: void 0,
      useWidth: void 0
    },
    c4: {
      ...fr.c4,
      useWidth: void 0,
      personFont: v(function() {
        return {
          fontFamily: this.personFontFamily,
          fontSize: this.personFontSize,
          fontWeight: this.personFontWeight
        };
      }, "personFont"),
      flowchart: {
        ...fr.flowchart,
        inheritDir: false
      },
      external_personFont: v(function() {
        return {
          fontFamily: this.external_personFontFamily,
          fontSize: this.external_personFontSize,
          fontWeight: this.external_personFontWeight
        };
      }, "external_personFont"),
      systemFont: v(function() {
        return {
          fontFamily: this.systemFontFamily,
          fontSize: this.systemFontSize,
          fontWeight: this.systemFontWeight
        };
      }, "systemFont"),
      external_systemFont: v(function() {
        return {
          fontFamily: this.external_systemFontFamily,
          fontSize: this.external_systemFontSize,
          fontWeight: this.external_systemFontWeight
        };
      }, "external_systemFont"),
      system_dbFont: v(function() {
        return {
          fontFamily: this.system_dbFontFamily,
          fontSize: this.system_dbFontSize,
          fontWeight: this.system_dbFontWeight
        };
      }, "system_dbFont"),
      external_system_dbFont: v(function() {
        return {
          fontFamily: this.external_system_dbFontFamily,
          fontSize: this.external_system_dbFontSize,
          fontWeight: this.external_system_dbFontWeight
        };
      }, "external_system_dbFont"),
      system_queueFont: v(function() {
        return {
          fontFamily: this.system_queueFontFamily,
          fontSize: this.system_queueFontSize,
          fontWeight: this.system_queueFontWeight
        };
      }, "system_queueFont"),
      external_system_queueFont: v(function() {
        return {
          fontFamily: this.external_system_queueFontFamily,
          fontSize: this.external_system_queueFontSize,
          fontWeight: this.external_system_queueFontWeight
        };
      }, "external_system_queueFont"),
      containerFont: v(function() {
        return {
          fontFamily: this.containerFontFamily,
          fontSize: this.containerFontSize,
          fontWeight: this.containerFontWeight
        };
      }, "containerFont"),
      external_containerFont: v(function() {
        return {
          fontFamily: this.external_containerFontFamily,
          fontSize: this.external_containerFontSize,
          fontWeight: this.external_containerFontWeight
        };
      }, "external_containerFont"),
      container_dbFont: v(function() {
        return {
          fontFamily: this.container_dbFontFamily,
          fontSize: this.container_dbFontSize,
          fontWeight: this.container_dbFontWeight
        };
      }, "container_dbFont"),
      external_container_dbFont: v(function() {
        return {
          fontFamily: this.external_container_dbFontFamily,
          fontSize: this.external_container_dbFontSize,
          fontWeight: this.external_container_dbFontWeight
        };
      }, "external_container_dbFont"),
      container_queueFont: v(function() {
        return {
          fontFamily: this.container_queueFontFamily,
          fontSize: this.container_queueFontSize,
          fontWeight: this.container_queueFontWeight
        };
      }, "container_queueFont"),
      external_container_queueFont: v(function() {
        return {
          fontFamily: this.external_container_queueFontFamily,
          fontSize: this.external_container_queueFontSize,
          fontWeight: this.external_container_queueFontWeight
        };
      }, "external_container_queueFont"),
      componentFont: v(function() {
        return {
          fontFamily: this.componentFontFamily,
          fontSize: this.componentFontSize,
          fontWeight: this.componentFontWeight
        };
      }, "componentFont"),
      external_componentFont: v(function() {
        return {
          fontFamily: this.external_componentFontFamily,
          fontSize: this.external_componentFontSize,
          fontWeight: this.external_componentFontWeight
        };
      }, "external_componentFont"),
      component_dbFont: v(function() {
        return {
          fontFamily: this.component_dbFontFamily,
          fontSize: this.component_dbFontSize,
          fontWeight: this.component_dbFontWeight
        };
      }, "component_dbFont"),
      external_component_dbFont: v(function() {
        return {
          fontFamily: this.external_component_dbFontFamily,
          fontSize: this.external_component_dbFontSize,
          fontWeight: this.external_component_dbFontWeight
        };
      }, "external_component_dbFont"),
      component_queueFont: v(function() {
        return {
          fontFamily: this.component_queueFontFamily,
          fontSize: this.component_queueFontSize,
          fontWeight: this.component_queueFontWeight
        };
      }, "component_queueFont"),
      external_component_queueFont: v(function() {
        return {
          fontFamily: this.external_component_queueFontFamily,
          fontSize: this.external_component_queueFontSize,
          fontWeight: this.external_component_queueFontWeight
        };
      }, "external_component_queueFont"),
      boundaryFont: v(function() {
        return {
          fontFamily: this.boundaryFontFamily,
          fontSize: this.boundaryFontSize,
          fontWeight: this.boundaryFontWeight
        };
      }, "boundaryFont"),
      messageFont: v(function() {
        return {
          fontFamily: this.messageFontFamily,
          fontSize: this.messageFontSize,
          fontWeight: this.messageFontWeight
        };
      }, "messageFont")
    },
    pie: {
      ...fr.pie,
      useWidth: 984
    },
    xyChart: {
      ...fr.xyChart,
      useWidth: void 0
    },
    requirement: {
      ...fr.requirement,
      useWidth: void 0
    },
    packet: {
      ...fr.packet
    },
    radar: {
      ...fr.radar
    },
    treemap: {
      useMaxWidth: true,
      padding: 10,
      diagramPadding: 8,
      showValues: true,
      nodeWidth: 100,
      nodeHeight: 40,
      borderWidth: 1,
      valueFontSize: 12,
      labelFontSize: 14,
      valueFormat: ","
    }
  };
  Px = v((t, e = "") => Object.keys(t).reduce((a, n) => Array.isArray(t[n]) ? a : typeof t[n] == "object" && t[n] !== null ? [
    ...a,
    e + n,
    ...Px(t[n], "")
  ] : [
    ...a,
    e + n
  ], []), "keyify");
  oE = new Set(Px(Ix, ""));
  Gx = Ix;
  xu = v((t) => {
    if (it.debug("sanitizeDirective called with", t), !(typeof t != "object" || t == null)) {
      if (Array.isArray(t)) {
        t.forEach((e) => xu(e));
        return;
      }
      for (const e of Object.keys(t)) {
        if (it.debug("Checking key", e), e.startsWith("__") || e.includes("proto") || e.includes("constr") || !oE.has(e) || t[e] == null) {
          it.debug("sanitize deleting key: ", e), delete t[e];
          continue;
        }
        if (typeof t[e] == "object") {
          it.debug("sanitizing object", e), xu(t[e]);
          continue;
        }
        const a = [
          "themeCSS",
          "fontFamily",
          "altFontFamily"
        ];
        for (const n of a) e.includes(n) && (it.debug("sanitizing css option", e), t[e] = cE(t[e]));
      }
      if (t.themeVariables) for (const e of Object.keys(t.themeVariables)) {
        const a = t.themeVariables[e];
        (a == null ? void 0 : a.match) && !a.match(/^[\d "#%(),.;A-Za-z]+$/) && (t.themeVariables[e] = "");
      }
      it.debug("After sanitization", t);
    }
  }, "sanitizeDirective");
  cE = v((t) => {
    let e = 0, a = 0;
    for (const n of t) {
      if (e < a) return "{ /* ERROR: Unbalanced CSS */ }";
      n === "{" ? e++ : n === "}" && a++;
    }
    return e !== a ? "{ /* ERROR: Unbalanced CSS */ }" : t;
  }, "sanitizeCss");
  vl = Object.freeze(Gx);
  di = ke({}, vl);
  yn = [];
  so = ke({}, vl);
  ah = v((t, e) => {
    let a = ke({}, t), n = {};
    for (const l of e) Vx(l), n = ke(n, l);
    if (a = ke(a, n), n.theme && n.theme in Xr) {
      const l = ke({}, vu), o = ke(l.themeVariables || {}, n.themeVariables);
      a.theme && a.theme in Xr && (a.themeVariables = Xr[a.theme].getThemeVariables(o));
    }
    return so = a, Zx(so), so;
  }, "updateCurrentConfig");
  uE = v((t) => (di = ke({}, vl), di = ke(di, t), t.theme && Xr[t.theme] && (di.themeVariables = Xr[t.theme].getThemeVariables(t.themeVariables)), ah(di, yn), di), "setSiteConfig");
  hE = v((t) => {
    vu = ke({}, t);
  }, "saveConfigFromInitialize");
  fE = v((t) => (di = ke(di, t), ah(di, yn), di), "updateSiteConfig");
  Wx = v(() => ke({}, di), "getSiteConfig");
  Xx = v((t) => (Zx(t), ke(so, t), Xe()), "setConfig");
  Xe = v(() => ke({}, so), "getConfig");
  Vx = v((t) => {
    t && ([
      "secure",
      ...di.secure ?? []
    ].forEach((e) => {
      Object.hasOwn(t, e) && (it.debug(`Denied attempt to modify a secure key ${e}`, t[e]), delete t[e]);
    }), Object.keys(t).forEach((e) => {
      e.startsWith("__") && delete t[e];
    }), Object.keys(t).forEach((e) => {
      typeof t[e] == "string" && (t[e].includes("<") || t[e].includes(">") || t[e].includes("url(data:")) && delete t[e], typeof t[e] == "object" && Vx(t[e]);
    }));
  }, "sanitize");
  dE = v((t) => {
    var _a2;
    xu(t), t.fontFamily && !((_a2 = t.themeVariables) == null ? void 0 : _a2.fontFamily) && (t.themeVariables = {
      ...t.themeVariables,
      fontFamily: t.fontFamily
    }), yn.push(t), ah(di, yn);
  }, "addDirective");
  _u = v((t = di) => {
    yn = [], ah(t, yn);
  }, "reset");
  pE = {
    LAZY_LOAD_DEPRECATED: "The configuration options lazyLoadedDiagrams and loadExternalDiagramsAtStartup are deprecated. Please use registerExternalDiagrams instead."
  };
  u1 = {};
  gE = v((t) => {
    u1[t] || (it.warn(pE[t]), u1[t] = true);
  }, "issueWarning");
  Zx = v((t) => {
    t && (t.lazyLoadedDiagrams || t.loadExternalDiagramsAtStartup) && gE("LAZY_LOAD_DEPRECATED");
  }, "checkConfig");
  hz = v(() => {
    let t = {};
    vu && (t = ke(t, vu));
    for (const e of yn) t = ke(t, e);
    return t;
  }, "getUserDefinedConfig");
  To = /<br\s*\/?>/gi;
  mE = v((t) => t ? Jx(t).replace(/\\n/g, "#br#").split("#br#") : [
    ""
  ], "getRows");
  yE = /* @__PURE__ */ (() => {
    let t = false;
    return () => {
      t || (Qx(), t = true);
    };
  })();
  function Qx() {
    const t = "data-temp-href-target";
    xl.addHook("beforeSanitizeAttributes", (e) => {
      e.tagName === "A" && e.hasAttribute("target") && e.setAttribute(t, e.getAttribute("target") ?? "");
    }), xl.addHook("afterSanitizeAttributes", (e) => {
      e.tagName === "A" && e.hasAttribute(t) && (e.setAttribute("target", e.getAttribute(t) ?? ""), e.removeAttribute(t), e.getAttribute("target") === "_blank" && e.setAttribute("rel", "noopener"));
    });
  }
  v(Qx, "setupDompurifyHooks");
  let Kx, h1, bE, xE, vE, _E, Jx, SE, CE, pp, wE, TE, d1, gp, kE, AE, EE, lu, BE, LE, OE;
  Kx = v((t) => (yE(), xl.sanitize(t)), "removeScript");
  h1 = v((t, e) => {
    var _a2;
    if (((_a2 = e.flowchart) == null ? void 0 : _a2.htmlLabels) !== false) {
      const a = e.securityLevel;
      a === "antiscript" || a === "strict" ? t = Kx(t) : a !== "loose" && (t = Jx(t), t = t.replace(/</g, "&lt;").replace(/>/g, "&gt;"), t = t.replace(/=/g, "&equals;"), t = _E(t));
    }
    return t;
  }, "sanitizeMore");
  ji = v((t, e) => t && (e.dompurifyConfig ? t = xl.sanitize(h1(t, e), e.dompurifyConfig).toString() : t = xl.sanitize(h1(t, e), {
    FORBID_TAGS: [
      "style"
    ]
  }).toString(), t), "sanitizeText");
  bE = v((t, e) => typeof t == "string" ? ji(t, e) : t.flat().map((a) => ji(a, e)), "sanitizeTextOrArray");
  xE = v((t) => To.test(t), "hasBreaks");
  vE = v((t) => t.split(To), "splitBreaks");
  _E = v((t) => t.replace(/#br#/g, "<br/>"), "placeholderToBreak");
  Jx = v((t) => t.replace(To, "#br#"), "breakToPlaceholder");
  t2 = v((t) => {
    let e = "";
    return t && (e = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search, e = CSS.escape(e)), e;
  }, "getUrl");
  Ee = v((t) => !(t === false || [
    "false",
    "null",
    "0"
  ].includes(String(t).trim().toLowerCase())), "evaluate");
  SE = v(function(...t) {
    const e = t.filter((a) => !isNaN(a));
    return Math.max(...e);
  }, "getMax");
  CE = v(function(...t) {
    const e = t.filter((a) => !isNaN(a));
    return Math.min(...e);
  }, "getMin");
  f1 = v(function(t) {
    const e = t.split(/(,)/), a = [];
    for (let n = 0; n < e.length; n++) {
      let l = e[n];
      if (l === "," && n > 0 && n + 1 < e.length) {
        const o = e[n - 1], h = e[n + 1];
        wE(o, h) && (l = o + "," + h, n++, a.pop());
      }
      a.push(TE(l));
    }
    return a.join("");
  }, "parseGenericTypes");
  pp = v((t, e) => Math.max(0, t.split(e).length - 1), "countOccurrence");
  wE = v((t, e) => {
    const a = pp(t, "~"), n = pp(e, "~");
    return a === 1 && n === 1;
  }, "shouldCombineSets");
  TE = v((t) => {
    const e = pp(t, "~");
    let a = false;
    if (e <= 1) return t;
    e % 2 !== 0 && t.startsWith("~") && (t = t.substring(1), a = true);
    const n = [
      ...t
    ];
    let l = n.indexOf("~"), o = n.lastIndexOf("~");
    for (; l !== -1 && o !== -1 && l !== o; ) n[l] = "<", n[o] = ">", l = n.indexOf("~"), o = n.lastIndexOf("~");
    return a && n.unshift("~"), n.join("");
  }, "processSet");
  d1 = v(() => window.MathMLElement !== void 0, "isMathMLSupported");
  gp = /\$\$(.*)\$\$/g;
  _l = v((t) => {
    var _a2;
    return (((_a2 = t.match(gp)) == null ? void 0 : _a2.length) ?? 0) > 0;
  }, "hasKatex");
  fz = v(async (t, e) => {
    var _a2;
    const a = document.createElement("div");
    a.innerHTML = await ug(t, e), a.id = "katex-temp", a.style.visibility = "hidden", a.style.position = "absolute", a.style.top = "0", (_a2 = document.querySelector("body")) == null ? void 0 : _a2.insertAdjacentElement("beforeend", a);
    const l = {
      width: a.clientWidth,
      height: a.clientHeight
    };
    return a.remove(), l;
  }, "calculateMathMLDimensions");
  kE = v(async (t, e) => {
    if (!_l(t)) return t;
    if (!(d1() || e.legacyMathML || e.forceLegacyMathML)) return t.replace(gp, "MathML is unsupported in this environment.");
    {
      const { default: a } = await Wt(async () => {
        const { default: l } = await import("./katex-DsmCZfJr.js");
        return {
          default: l
        };
      }, []), n = e.forceLegacyMathML || !d1() && e.legacyMathML ? "htmlAndMathml" : "mathml";
      return t.split(To).map((l) => _l(l) ? `<div style="display: flex; align-items: center; justify-content: center; white-space: nowrap;">${l}</div>` : `<div>${l}</div>`).join("").replace(gp, (l, o) => a.renderToString(o, {
        throwOnError: true,
        displayMode: true,
        output: n
      }).replace(/\n/g, " ").replace(/<annotation.*<\/annotation>/g, ""));
    }
  }, "renderKatexUnsanitized");
  ug = v(async (t, e) => ji(await kE(t, e), e), "renderKatexSanitized");
  El = {
    getRows: mE,
    sanitizeText: ji,
    sanitizeTextOrArray: bE,
    hasBreaks: xE,
    splitBreaks: vE,
    lineBreakRegex: To,
    removeScript: Kx,
    getUrl: t2,
    evaluate: Ee,
    getMax: SE,
    getMin: CE
  };
  AE = v(function(t, e) {
    for (let a of e) t.attr(a[0], a[1]);
  }, "d3Attrs");
  EE = v(function(t, e, a) {
    let n = /* @__PURE__ */ new Map();
    return a ? (n.set("width", "100%"), n.set("style", `max-width: ${e}px;`)) : (n.set("height", t), n.set("width", e)), n;
  }, "calculateSvgSizeAttrs");
  e2 = v(function(t, e, a, n) {
    const l = EE(e, a, n);
    AE(t, l);
  }, "configureSvgSize");
  ME = v(function(t, e, a, n) {
    const l = e.node().getBBox(), o = l.width, h = l.height;
    it.info(`SVG bounds: ${o}x${h}`, l);
    let u = 0, d = 0;
    it.info(`Graph bounds: ${u}x${d}`, t), u = o + a * 2, d = h + a * 2, it.info(`Calculated bounds: ${u}x${d}`), e2(e, d, u, n);
    const f = `${l.x - a} ${l.y - a} ${l.width + 2 * a} ${l.height + 2 * a}`;
    e.attr("viewBox", f);
  }, "setupGraphViewbox");
  lu = {};
  BE = v((t, e, a) => {
    let n = "";
    return t in lu && lu[t] ? n = lu[t](a) : it.warn(`No theme found for ${t}`), ` & {
    font-family: ${a.fontFamily};
    font-size: ${a.fontSize};
    fill: ${a.textColor}
  }
  @keyframes edge-animation-frame {
    from {
      stroke-dashoffset: 0;
    }
  }
  @keyframes dash {
    to {
      stroke-dashoffset: 0;
    }
  }
  & .edge-animation-slow {
    stroke-dasharray: 9,5 !important;
    stroke-dashoffset: 900;
    animation: dash 50s linear infinite;
    stroke-linecap: round;
  }
  & .edge-animation-fast {
    stroke-dasharray: 9,5 !important;
    stroke-dashoffset: 900;
    animation: dash 20s linear infinite;
    stroke-linecap: round;
  }
  /* Classes common for multiple diagrams */

  & .error-icon {
    fill: ${a.errorBkgColor};
  }
  & .error-text {
    fill: ${a.errorTextColor};
    stroke: ${a.errorTextColor};
  }

  & .edge-thickness-normal {
    stroke-width: 1px;
  }
  & .edge-thickness-thick {
    stroke-width: 3.5px
  }
  & .edge-pattern-solid {
    stroke-dasharray: 0;
  }
  & .edge-thickness-invisible {
    stroke-width: 0;
    fill: none;
  }
  & .edge-pattern-dashed{
    stroke-dasharray: 3;
  }
  .edge-pattern-dotted {
    stroke-dasharray: 2;
  }

  & .marker {
    fill: ${a.lineColor};
    stroke: ${a.lineColor};
  }
  & .marker.cross {
    stroke: ${a.lineColor};
  }

  & svg {
    font-family: ${a.fontFamily};
    font-size: ${a.fontSize};
  }
   & p {
    margin: 0
   }

  ${n}

  ${e}
`;
  }, "getStyles");
  LE = v((t, e) => {
    e !== void 0 && (lu[t] = e);
  }, "addStylesForDiagram");
  OE = BE;
  i2 = {};
  _A(i2, {
    clear: () => DE,
    getAccDescription: () => zE,
    getAccTitle: () => $E,
    getDiagramTitle: () => qE,
    setAccDescription: () => NE,
    setAccTitle: () => RE,
    setDiagramTitle: () => FE
  });
  let hg, fg, dg, pg, p1, HE, gg, jE, Su, Cu, mp, YE, IE;
  hg = "";
  fg = "";
  dg = "";
  pg = v((t) => ji(t, Xe()), "sanitizeText");
  DE = v(() => {
    hg = "", dg = "", fg = "";
  }, "clear");
  RE = v((t) => {
    hg = pg(t).replace(/^\s+/g, "");
  }, "setAccTitle");
  $E = v(() => hg, "getAccTitle");
  NE = v((t) => {
    dg = pg(t).replace(/\n\s+/g, `
`);
  }, "setAccDescription");
  zE = v(() => dg, "getAccDescription");
  FE = v((t) => {
    fg = pg(t);
  }, "setDiagramTitle");
  qE = v(() => fg, "getDiagramTitle");
  p1 = it;
  HE = og;
  Pt = Xe;
  dz = Xx;
  pz = vl;
  gg = v((t) => ji(t, Pt()), "sanitizeText");
  UE = ME;
  jE = v(() => i2, "getCommonDb");
  Su = {};
  Cu = v((t, e, a) => {
    var _a2;
    Su[t] && p1.warn(`Diagram with id ${t} already registered. Overwriting.`), Su[t] = e, a && Yx(t, a), LE(t, e.styles), (_a2 = e.injectUtils) == null ? void 0 : _a2.call(e, p1, HE, Pt, gg, UE, jE(), () => {
    });
  }, "registerDiagram");
  mp = v((t) => {
    if (t in Su) return Su[t];
    throw new YE(t);
  }, "getDiagram");
  YE = (_g2 = class extends Error {
    constructor(t) {
      super(`Diagram ${t} not found.`);
    }
  }, v(_g2, "DiagramNotFoundError"), _g2);
  IE = {
    value: () => {
    }
  };
  function r2() {
    for (var t = 0, e = arguments.length, a = {}, n; t < e; ++t) {
      if (!(n = arguments[t] + "") || n in a || /[\s.]/.test(n)) throw new Error("illegal type: " + n);
      a[n] = [];
    }
    return new su(a);
  }
  function su(t) {
    this._ = t;
  }
  function PE(t, e) {
    return t.trim().split(/^|\s+/).map(function(a) {
      var n = "", l = a.indexOf(".");
      if (l >= 0 && (n = a.slice(l + 1), a = a.slice(0, l)), a && !e.hasOwnProperty(a)) throw new Error("unknown type: " + a);
      return {
        type: a,
        name: n
      };
    });
  }
  su.prototype = r2.prototype = {
    constructor: su,
    on: function(t, e) {
      var a = this._, n = PE(t + "", a), l, o = -1, h = n.length;
      if (arguments.length < 2) {
        for (; ++o < h; ) if ((l = (t = n[o]).type) && (l = GE(a[l], t.name))) return l;
        return;
      }
      if (e != null && typeof e != "function") throw new Error("invalid callback: " + e);
      for (; ++o < h; ) if (l = (t = n[o]).type) a[l] = g1(a[l], t.name, e);
      else if (e == null) for (l in a) a[l] = g1(a[l], t.name, null);
      return this;
    },
    copy: function() {
      var t = {}, e = this._;
      for (var a in e) t[a] = e[a].slice();
      return new su(t);
    },
    call: function(t, e) {
      if ((l = arguments.length - 2) > 0) for (var a = new Array(l), n = 0, l, o; n < l; ++n) a[n] = arguments[n + 2];
      if (!this._.hasOwnProperty(t)) throw new Error("unknown type: " + t);
      for (o = this._[t], n = 0, l = o.length; n < l; ++n) o[n].value.apply(e, a);
    },
    apply: function(t, e, a) {
      if (!this._.hasOwnProperty(t)) throw new Error("unknown type: " + t);
      for (var n = this._[t], l = 0, o = n.length; l < o; ++l) n[l].value.apply(e, a);
    }
  };
  function GE(t, e) {
    for (var a = 0, n = t.length, l; a < n; ++a) if ((l = t[a]).name === e) return l.value;
  }
  function g1(t, e, a) {
    for (var n = 0, l = t.length; n < l; ++n) if (t[n].name === e) {
      t[n] = IE, t = t.slice(0, n).concat(t.slice(n + 1));
      break;
    }
    return a != null && t.push({
      name: e,
      value: a
    }), t;
  }
  var yp = "http://www.w3.org/1999/xhtml";
  const m1 = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: yp,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  function nh(t) {
    var e = t += "", a = e.indexOf(":");
    return a >= 0 && (e = t.slice(0, a)) !== "xmlns" && (t = t.slice(a + 1)), m1.hasOwnProperty(e) ? {
      space: m1[e],
      local: t
    } : t;
  }
  function WE(t) {
    return function() {
      var e = this.ownerDocument, a = this.namespaceURI;
      return a === yp && e.documentElement.namespaceURI === yp ? e.createElement(t) : e.createElementNS(a, t);
    };
  }
  function XE(t) {
    return function() {
      return this.ownerDocument.createElementNS(t.space, t.local);
    };
  }
  function a2(t) {
    var e = nh(t);
    return (e.local ? XE : WE)(e);
  }
  function VE() {
  }
  function mg(t) {
    return t == null ? VE : function() {
      return this.querySelector(t);
    };
  }
  function ZE(t) {
    typeof t != "function" && (t = mg(t));
    for (var e = this._groups, a = e.length, n = new Array(a), l = 0; l < a; ++l) for (var o = e[l], h = o.length, u = n[l] = new Array(h), d, f, p = 0; p < h; ++p) (d = o[p]) && (f = t.call(d, d.__data__, p, o)) && ("__data__" in d && (f.__data__ = d.__data__), u[p] = f);
    return new Ei(n, this._parents);
  }
  function QE(t) {
    return t == null ? [] : Array.isArray(t) ? t : Array.from(t);
  }
  function KE() {
    return [];
  }
  function n2(t) {
    return t == null ? KE : function() {
      return this.querySelectorAll(t);
    };
  }
  function JE(t) {
    return function() {
      return QE(t.apply(this, arguments));
    };
  }
  function tM(t) {
    typeof t == "function" ? t = JE(t) : t = n2(t);
    for (var e = this._groups, a = e.length, n = [], l = [], o = 0; o < a; ++o) for (var h = e[o], u = h.length, d, f = 0; f < u; ++f) (d = h[f]) && (n.push(t.call(d, d.__data__, f, h)), l.push(d));
    return new Ei(n, l);
  }
  function l2(t) {
    return function() {
      return this.matches(t);
    };
  }
  function s2(t) {
    return function(e) {
      return e.matches(t);
    };
  }
  var eM = Array.prototype.find;
  function iM(t) {
    return function() {
      return eM.call(this.children, t);
    };
  }
  function rM() {
    return this.firstElementChild;
  }
  function aM(t) {
    return this.select(t == null ? rM : iM(typeof t == "function" ? t : s2(t)));
  }
  var nM = Array.prototype.filter;
  function lM() {
    return Array.from(this.children);
  }
  function sM(t) {
    return function() {
      return nM.call(this.children, t);
    };
  }
  function oM(t) {
    return this.selectAll(t == null ? lM : sM(typeof t == "function" ? t : s2(t)));
  }
  function cM(t) {
    typeof t != "function" && (t = l2(t));
    for (var e = this._groups, a = e.length, n = new Array(a), l = 0; l < a; ++l) for (var o = e[l], h = o.length, u = n[l] = [], d, f = 0; f < h; ++f) (d = o[f]) && t.call(d, d.__data__, f, o) && u.push(d);
    return new Ei(n, this._parents);
  }
  function o2(t) {
    return new Array(t.length);
  }
  function uM() {
    return new Ei(this._enter || this._groups.map(o2), this._parents);
  }
  function wu(t, e) {
    this.ownerDocument = t.ownerDocument, this.namespaceURI = t.namespaceURI, this._next = null, this._parent = t, this.__data__ = e;
  }
  wu.prototype = {
    constructor: wu,
    appendChild: function(t) {
      return this._parent.insertBefore(t, this._next);
    },
    insertBefore: function(t, e) {
      return this._parent.insertBefore(t, e);
    },
    querySelector: function(t) {
      return this._parent.querySelector(t);
    },
    querySelectorAll: function(t) {
      return this._parent.querySelectorAll(t);
    }
  };
  function hM(t) {
    return function() {
      return t;
    };
  }
  function fM(t, e, a, n, l, o) {
    for (var h = 0, u, d = e.length, f = o.length; h < f; ++h) (u = e[h]) ? (u.__data__ = o[h], n[h] = u) : a[h] = new wu(t, o[h]);
    for (; h < d; ++h) (u = e[h]) && (l[h] = u);
  }
  function dM(t, e, a, n, l, o, h) {
    var u, d, f = /* @__PURE__ */ new Map(), p = e.length, m = o.length, b = new Array(p), x;
    for (u = 0; u < p; ++u) (d = e[u]) && (b[u] = x = h.call(d, d.__data__, u, e) + "", f.has(x) ? l[u] = d : f.set(x, d));
    for (u = 0; u < m; ++u) x = h.call(t, o[u], u, o) + "", (d = f.get(x)) ? (n[u] = d, d.__data__ = o[u], f.delete(x)) : a[u] = new wu(t, o[u]);
    for (u = 0; u < p; ++u) (d = e[u]) && f.get(b[u]) === d && (l[u] = d);
  }
  function pM(t) {
    return t.__data__;
  }
  function gM(t, e) {
    if (!arguments.length) return Array.from(this, pM);
    var a = e ? dM : fM, n = this._parents, l = this._groups;
    typeof t != "function" && (t = hM(t));
    for (var o = l.length, h = new Array(o), u = new Array(o), d = new Array(o), f = 0; f < o; ++f) {
      var p = n[f], m = l[f], b = m.length, x = mM(t.call(p, p && p.__data__, f, n)), _ = x.length, S = u[f] = new Array(_), w = h[f] = new Array(_), k = d[f] = new Array(b);
      a(p, m, S, w, k, x, e);
      for (var A = 0, L = 0, $, O; A < _; ++A) if ($ = S[A]) {
        for (A >= L && (L = A + 1); !(O = w[L]) && ++L < _; ) ;
        $._next = O || null;
      }
    }
    return h = new Ei(h, n), h._enter = u, h._exit = d, h;
  }
  function mM(t) {
    return typeof t == "object" && "length" in t ? t : Array.from(t);
  }
  function yM() {
    return new Ei(this._exit || this._groups.map(o2), this._parents);
  }
  function bM(t, e, a) {
    var n = this.enter(), l = this, o = this.exit();
    return typeof t == "function" ? (n = t(n), n && (n = n.selection())) : n = n.append(t + ""), e != null && (l = e(l), l && (l = l.selection())), a == null ? o.remove() : a(o), n && l ? n.merge(l).order() : l;
  }
  function xM(t) {
    for (var e = t.selection ? t.selection() : t, a = this._groups, n = e._groups, l = a.length, o = n.length, h = Math.min(l, o), u = new Array(l), d = 0; d < h; ++d) for (var f = a[d], p = n[d], m = f.length, b = u[d] = new Array(m), x, _ = 0; _ < m; ++_) (x = f[_] || p[_]) && (b[_] = x);
    for (; d < l; ++d) u[d] = a[d];
    return new Ei(u, this._parents);
  }
  function vM() {
    for (var t = this._groups, e = -1, a = t.length; ++e < a; ) for (var n = t[e], l = n.length - 1, o = n[l], h; --l >= 0; ) (h = n[l]) && (o && h.compareDocumentPosition(o) ^ 4 && o.parentNode.insertBefore(h, o), o = h);
    return this;
  }
  function _M(t) {
    t || (t = SM);
    function e(m, b) {
      return m && b ? t(m.__data__, b.__data__) : !m - !b;
    }
    for (var a = this._groups, n = a.length, l = new Array(n), o = 0; o < n; ++o) {
      for (var h = a[o], u = h.length, d = l[o] = new Array(u), f, p = 0; p < u; ++p) (f = h[p]) && (d[p] = f);
      d.sort(e);
    }
    return new Ei(l, this._parents).order();
  }
  function SM(t, e) {
    return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
  }
  function CM() {
    var t = arguments[0];
    return arguments[0] = this, t.apply(null, arguments), this;
  }
  function wM() {
    return Array.from(this);
  }
  function TM() {
    for (var t = this._groups, e = 0, a = t.length; e < a; ++e) for (var n = t[e], l = 0, o = n.length; l < o; ++l) {
      var h = n[l];
      if (h) return h;
    }
    return null;
  }
  function kM() {
    let t = 0;
    for (const e of this) ++t;
    return t;
  }
  function AM() {
    return !this.node();
  }
  function EM(t) {
    for (var e = this._groups, a = 0, n = e.length; a < n; ++a) for (var l = e[a], o = 0, h = l.length, u; o < h; ++o) (u = l[o]) && t.call(u, u.__data__, o, l);
    return this;
  }
  function MM(t) {
    return function() {
      this.removeAttribute(t);
    };
  }
  function BM(t) {
    return function() {
      this.removeAttributeNS(t.space, t.local);
    };
  }
  function LM(t, e) {
    return function() {
      this.setAttribute(t, e);
    };
  }
  function OM(t, e) {
    return function() {
      this.setAttributeNS(t.space, t.local, e);
    };
  }
  function DM(t, e) {
    return function() {
      var a = e.apply(this, arguments);
      a == null ? this.removeAttribute(t) : this.setAttribute(t, a);
    };
  }
  function RM(t, e) {
    return function() {
      var a = e.apply(this, arguments);
      a == null ? this.removeAttributeNS(t.space, t.local) : this.setAttributeNS(t.space, t.local, a);
    };
  }
  function $M(t, e) {
    var a = nh(t);
    if (arguments.length < 2) {
      var n = this.node();
      return a.local ? n.getAttributeNS(a.space, a.local) : n.getAttribute(a);
    }
    return this.each((e == null ? a.local ? BM : MM : typeof e == "function" ? a.local ? RM : DM : a.local ? OM : LM)(a, e));
  }
  function c2(t) {
    return t.ownerDocument && t.ownerDocument.defaultView || t.document && t || t.defaultView;
  }
  function NM(t) {
    return function() {
      this.style.removeProperty(t);
    };
  }
  function zM(t, e, a) {
    return function() {
      this.style.setProperty(t, e, a);
    };
  }
  function FM(t, e, a) {
    return function() {
      var n = e.apply(this, arguments);
      n == null ? this.style.removeProperty(t) : this.style.setProperty(t, n, a);
    };
  }
  function qM(t, e, a) {
    return arguments.length > 1 ? this.each((e == null ? NM : typeof e == "function" ? FM : zM)(t, e, a ?? "")) : Sl(this.node(), t);
  }
  function Sl(t, e) {
    return t.style.getPropertyValue(e) || c2(t).getComputedStyle(t, null).getPropertyValue(e);
  }
  function HM(t) {
    return function() {
      delete this[t];
    };
  }
  function UM(t, e) {
    return function() {
      this[t] = e;
    };
  }
  function jM(t, e) {
    return function() {
      var a = e.apply(this, arguments);
      a == null ? delete this[t] : this[t] = a;
    };
  }
  function YM(t, e) {
    return arguments.length > 1 ? this.each((e == null ? HM : typeof e == "function" ? jM : UM)(t, e)) : this.node()[t];
  }
  function u2(t) {
    return t.trim().split(/^|\s+/);
  }
  function yg(t) {
    return t.classList || new h2(t);
  }
  function h2(t) {
    this._node = t, this._names = u2(t.getAttribute("class") || "");
  }
  h2.prototype = {
    add: function(t) {
      var e = this._names.indexOf(t);
      e < 0 && (this._names.push(t), this._node.setAttribute("class", this._names.join(" ")));
    },
    remove: function(t) {
      var e = this._names.indexOf(t);
      e >= 0 && (this._names.splice(e, 1), this._node.setAttribute("class", this._names.join(" ")));
    },
    contains: function(t) {
      return this._names.indexOf(t) >= 0;
    }
  };
  function f2(t, e) {
    for (var a = yg(t), n = -1, l = e.length; ++n < l; ) a.add(e[n]);
  }
  function d2(t, e) {
    for (var a = yg(t), n = -1, l = e.length; ++n < l; ) a.remove(e[n]);
  }
  function IM(t) {
    return function() {
      f2(this, t);
    };
  }
  function PM(t) {
    return function() {
      d2(this, t);
    };
  }
  function GM(t, e) {
    return function() {
      (e.apply(this, arguments) ? f2 : d2)(this, t);
    };
  }
  function WM(t, e) {
    var a = u2(t + "");
    if (arguments.length < 2) {
      for (var n = yg(this.node()), l = -1, o = a.length; ++l < o; ) if (!n.contains(a[l])) return false;
      return true;
    }
    return this.each((typeof e == "function" ? GM : e ? IM : PM)(a, e));
  }
  function XM() {
    this.textContent = "";
  }
  function VM(t) {
    return function() {
      this.textContent = t;
    };
  }
  function ZM(t) {
    return function() {
      var e = t.apply(this, arguments);
      this.textContent = e ?? "";
    };
  }
  function QM(t) {
    return arguments.length ? this.each(t == null ? XM : (typeof t == "function" ? ZM : VM)(t)) : this.node().textContent;
  }
  function KM() {
    this.innerHTML = "";
  }
  function JM(t) {
    return function() {
      this.innerHTML = t;
    };
  }
  function t3(t) {
    return function() {
      var e = t.apply(this, arguments);
      this.innerHTML = e ?? "";
    };
  }
  function e3(t) {
    return arguments.length ? this.each(t == null ? KM : (typeof t == "function" ? t3 : JM)(t)) : this.node().innerHTML;
  }
  function i3() {
    this.nextSibling && this.parentNode.appendChild(this);
  }
  function r3() {
    return this.each(i3);
  }
  function a3() {
    this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }
  function n3() {
    return this.each(a3);
  }
  function l3(t) {
    var e = typeof t == "function" ? t : a2(t);
    return this.select(function() {
      return this.appendChild(e.apply(this, arguments));
    });
  }
  function s3() {
    return null;
  }
  function o3(t, e) {
    var a = typeof t == "function" ? t : a2(t), n = e == null ? s3 : typeof e == "function" ? e : mg(e);
    return this.select(function() {
      return this.insertBefore(a.apply(this, arguments), n.apply(this, arguments) || null);
    });
  }
  function c3() {
    var t = this.parentNode;
    t && t.removeChild(this);
  }
  function u3() {
    return this.each(c3);
  }
  function h3() {
    var t = this.cloneNode(false), e = this.parentNode;
    return e ? e.insertBefore(t, this.nextSibling) : t;
  }
  function f3() {
    var t = this.cloneNode(true), e = this.parentNode;
    return e ? e.insertBefore(t, this.nextSibling) : t;
  }
  function d3(t) {
    return this.select(t ? f3 : h3);
  }
  function p3(t) {
    return arguments.length ? this.property("__data__", t) : this.node().__data__;
  }
  function g3(t) {
    return function(e) {
      t.call(this, e, this.__data__);
    };
  }
  function m3(t) {
    return t.trim().split(/^|\s+/).map(function(e) {
      var a = "", n = e.indexOf(".");
      return n >= 0 && (a = e.slice(n + 1), e = e.slice(0, n)), {
        type: e,
        name: a
      };
    });
  }
  function y3(t) {
    return function() {
      var e = this.__on;
      if (e) {
        for (var a = 0, n = -1, l = e.length, o; a < l; ++a) o = e[a], (!t.type || o.type === t.type) && o.name === t.name ? this.removeEventListener(o.type, o.listener, o.options) : e[++n] = o;
        ++n ? e.length = n : delete this.__on;
      }
    };
  }
  function b3(t, e, a) {
    return function() {
      var n = this.__on, l, o = g3(e);
      if (n) {
        for (var h = 0, u = n.length; h < u; ++h) if ((l = n[h]).type === t.type && l.name === t.name) {
          this.removeEventListener(l.type, l.listener, l.options), this.addEventListener(l.type, l.listener = o, l.options = a), l.value = e;
          return;
        }
      }
      this.addEventListener(t.type, o, a), l = {
        type: t.type,
        name: t.name,
        value: e,
        listener: o,
        options: a
      }, n ? n.push(l) : this.__on = [
        l
      ];
    };
  }
  function x3(t, e, a) {
    var n = m3(t + ""), l, o = n.length, h;
    if (arguments.length < 2) {
      var u = this.node().__on;
      if (u) {
        for (var d = 0, f = u.length, p; d < f; ++d) for (l = 0, p = u[d]; l < o; ++l) if ((h = n[l]).type === p.type && h.name === p.name) return p.value;
      }
      return;
    }
    for (u = e ? b3 : y3, l = 0; l < o; ++l) this.each(u(n[l], e, a));
    return this;
  }
  function p2(t, e, a) {
    var n = c2(t), l = n.CustomEvent;
    typeof l == "function" ? l = new l(e, a) : (l = n.document.createEvent("Event"), a ? (l.initEvent(e, a.bubbles, a.cancelable), l.detail = a.detail) : l.initEvent(e, false, false)), t.dispatchEvent(l);
  }
  function v3(t, e) {
    return function() {
      return p2(this, t, e);
    };
  }
  function _3(t, e) {
    return function() {
      return p2(this, t, e.apply(this, arguments));
    };
  }
  function S3(t, e) {
    return this.each((typeof e == "function" ? _3 : v3)(t, e));
  }
  function* C3() {
    for (var t = this._groups, e = 0, a = t.length; e < a; ++e) for (var n = t[e], l = 0, o = n.length, h; l < o; ++l) (h = n[l]) && (yield h);
  }
  var g2 = [
    null
  ];
  function Ei(t, e) {
    this._groups = t, this._parents = e;
  }
  function ko() {
    return new Ei([
      [
        document.documentElement
      ]
    ], g2);
  }
  function w3() {
    return this;
  }
  Ei.prototype = ko.prototype = {
    constructor: Ei,
    select: ZE,
    selectAll: tM,
    selectChild: aM,
    selectChildren: oM,
    filter: cM,
    data: gM,
    enter: uM,
    exit: yM,
    join: bM,
    merge: xM,
    selection: w3,
    order: vM,
    sort: _M,
    call: CM,
    nodes: wM,
    node: TM,
    size: kM,
    empty: AM,
    each: EM,
    attr: $M,
    style: qM,
    property: YM,
    classed: WM,
    text: QM,
    html: e3,
    raise: r3,
    lower: n3,
    append: l3,
    insert: o3,
    remove: u3,
    clone: d3,
    datum: p3,
    on: x3,
    dispatch: S3,
    [Symbol.iterator]: C3
  };
  jt = function(t) {
    return typeof t == "string" ? new Ei([
      [
        document.querySelector(t)
      ]
    ], [
      document.documentElement
    ]) : new Ei([
      [
        t
      ]
    ], g2);
  };
  bg = function(t, e, a) {
    t.prototype = e.prototype = a, a.constructor = t;
  };
  m2 = function(t, e) {
    var a = Object.create(t.prototype);
    for (var n in e) a[n] = e[n];
    return a;
  };
  Ao = function() {
  };
  var uo = 0.7, Tu = 1 / uo, yl = "\\s*([+-]?\\d+)\\s*", ho = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", mr = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", T3 = /^#([0-9a-f]{3,8})$/, k3 = new RegExp(`^rgb\\(${yl},${yl},${yl}\\)$`), A3 = new RegExp(`^rgb\\(${mr},${mr},${mr}\\)$`), E3 = new RegExp(`^rgba\\(${yl},${yl},${yl},${ho}\\)$`), M3 = new RegExp(`^rgba\\(${mr},${mr},${mr},${ho}\\)$`), B3 = new RegExp(`^hsl\\(${ho},${mr},${mr}\\)$`), L3 = new RegExp(`^hsla\\(${ho},${mr},${mr},${ho}\\)$`), y1 = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  bg(Ao, fo, {
    copy(t) {
      return Object.assign(new this.constructor(), this, t);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: b1,
    formatHex: b1,
    formatHex8: O3,
    formatHsl: D3,
    formatRgb: x1,
    toString: x1
  });
  function b1() {
    return this.rgb().formatHex();
  }
  function O3() {
    return this.rgb().formatHex8();
  }
  function D3() {
    return y2(this).formatHsl();
  }
  function x1() {
    return this.rgb().formatRgb();
  }
  fo = function(t) {
    var e, a;
    return t = (t + "").trim().toLowerCase(), (e = T3.exec(t)) ? (a = e[1].length, e = parseInt(e[1], 16), a === 6 ? v1(e) : a === 3 ? new gi(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : a === 8 ? Xc(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : a === 4 ? Xc(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = k3.exec(t)) ? new gi(e[1], e[2], e[3], 1) : (e = A3.exec(t)) ? new gi(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = E3.exec(t)) ? Xc(e[1], e[2], e[3], e[4]) : (e = M3.exec(t)) ? Xc(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = B3.exec(t)) ? C1(e[1], e[2] / 100, e[3] / 100, 1) : (e = L3.exec(t)) ? C1(e[1], e[2] / 100, e[3] / 100, e[4]) : y1.hasOwnProperty(t) ? v1(y1[t]) : t === "transparent" ? new gi(NaN, NaN, NaN, 0) : null;
  };
  function v1(t) {
    return new gi(t >> 16 & 255, t >> 8 & 255, t & 255, 1);
  }
  function Xc(t, e, a, n) {
    return n <= 0 && (t = e = a = NaN), new gi(t, e, a, n);
  }
  R3 = function(t) {
    return t instanceof Ao || (t = fo(t)), t ? (t = t.rgb(), new gi(t.r, t.g, t.b, t.opacity)) : new gi();
  };
  function bp(t, e, a, n) {
    return arguments.length === 1 ? R3(t) : new gi(t, e, a, n ?? 1);
  }
  gi = function(t, e, a, n) {
    this.r = +t, this.g = +e, this.b = +a, this.opacity = +n;
  };
  bg(gi, bp, m2(Ao, {
    brighter(t) {
      return t = t == null ? Tu : Math.pow(Tu, t), new gi(this.r * t, this.g * t, this.b * t, this.opacity);
    },
    darker(t) {
      return t = t == null ? uo : Math.pow(uo, t), new gi(this.r * t, this.g * t, this.b * t, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new gi(gn(this.r), gn(this.g), gn(this.b), ku(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
    },
    hex: _1,
    formatHex: _1,
    formatHex8: $3,
    formatRgb: S1,
    toString: S1
  }));
  function _1() {
    return `#${hn(this.r)}${hn(this.g)}${hn(this.b)}`;
  }
  function $3() {
    return `#${hn(this.r)}${hn(this.g)}${hn(this.b)}${hn((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function S1() {
    const t = ku(this.opacity);
    return `${t === 1 ? "rgb(" : "rgba("}${gn(this.r)}, ${gn(this.g)}, ${gn(this.b)}${t === 1 ? ")" : `, ${t})`}`;
  }
  function ku(t) {
    return isNaN(t) ? 1 : Math.max(0, Math.min(1, t));
  }
  function gn(t) {
    return Math.max(0, Math.min(255, Math.round(t) || 0));
  }
  function hn(t) {
    return t = gn(t), (t < 16 ? "0" : "") + t.toString(16);
  }
  function C1(t, e, a, n) {
    return n <= 0 ? t = e = a = NaN : a <= 0 || a >= 1 ? t = e = NaN : e <= 0 && (t = NaN), new Ji(t, e, a, n);
  }
  function y2(t) {
    if (t instanceof Ji) return new Ji(t.h, t.s, t.l, t.opacity);
    if (t instanceof Ao || (t = fo(t)), !t) return new Ji();
    if (t instanceof Ji) return t;
    t = t.rgb();
    var e = t.r / 255, a = t.g / 255, n = t.b / 255, l = Math.min(e, a, n), o = Math.max(e, a, n), h = NaN, u = o - l, d = (o + l) / 2;
    return u ? (e === o ? h = (a - n) / u + (a < n) * 6 : a === o ? h = (n - e) / u + 2 : h = (e - a) / u + 4, u /= d < 0.5 ? o + l : 2 - o - l, h *= 60) : u = d > 0 && d < 1 ? 0 : h, new Ji(h, u, d, t.opacity);
  }
  function N3(t, e, a, n) {
    return arguments.length === 1 ? y2(t) : new Ji(t, e, a, n ?? 1);
  }
  function Ji(t, e, a, n) {
    this.h = +t, this.s = +e, this.l = +a, this.opacity = +n;
  }
  bg(Ji, N3, m2(Ao, {
    brighter(t) {
      return t = t == null ? Tu : Math.pow(Tu, t), new Ji(this.h, this.s, this.l * t, this.opacity);
    },
    darker(t) {
      return t = t == null ? uo : Math.pow(uo, t), new Ji(this.h, this.s, this.l * t, this.opacity);
    },
    rgb() {
      var t = this.h % 360 + (this.h < 0) * 360, e = isNaN(t) || isNaN(this.s) ? 0 : this.s, a = this.l, n = a + (a < 0.5 ? a : 1 - a) * e, l = 2 * a - n;
      return new gi(Xd(t >= 240 ? t - 240 : t + 120, l, n), Xd(t, l, n), Xd(t < 120 ? t + 240 : t - 120, l, n), this.opacity);
    },
    clamp() {
      return new Ji(w1(this.h), Vc(this.s), Vc(this.l), ku(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
    },
    formatHsl() {
      const t = ku(this.opacity);
      return `${t === 1 ? "hsl(" : "hsla("}${w1(this.h)}, ${Vc(this.s) * 100}%, ${Vc(this.l) * 100}%${t === 1 ? ")" : `, ${t})`}`;
    }
  }));
  function w1(t) {
    return t = (t || 0) % 360, t < 0 ? t + 360 : t;
  }
  function Vc(t) {
    return Math.max(0, Math.min(1, t || 0));
  }
  function Xd(t, e, a) {
    return (t < 60 ? e + (a - e) * t / 60 : t < 180 ? a : t < 240 ? e + (a - e) * (240 - t) / 60 : e) * 255;
  }
  xg = (t) => () => t;
  function b2(t, e) {
    return function(a) {
      return t + a * e;
    };
  }
  function z3(t, e, a) {
    return t = Math.pow(t, a), e = Math.pow(e, a) - t, a = 1 / a, function(n) {
      return Math.pow(t + n * e, a);
    };
  }
  gz = function(t, e) {
    var a = e - t;
    return a ? b2(t, a > 180 || a < -180 ? a - 360 * Math.round(a / 360) : a) : xg(isNaN(t) ? e : t);
  };
  function F3(t) {
    return (t = +t) == 1 ? x2 : function(e, a) {
      return a - e ? z3(e, a, t) : xg(isNaN(e) ? a : e);
    };
  }
  x2 = function(t, e) {
    var a = e - t;
    return a ? b2(t, a) : xg(isNaN(t) ? e : t);
  };
  T1 = (function t(e) {
    var a = F3(e);
    function n(l, o) {
      var h = a((l = bp(l)).r, (o = bp(o)).r), u = a(l.g, o.g), d = a(l.b, o.b), f = x2(l.opacity, o.opacity);
      return function(p) {
        return l.r = h(p), l.g = u(p), l.b = d(p), l.opacity = f(p), l + "";
      };
    }
    return n.gamma = t, n;
  })(1);
  Aa = function(t, e) {
    return t = +t, e = +e, function(a) {
      return t * (1 - a) + e * a;
    };
  };
  var xp = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Vd = new RegExp(xp.source, "g");
  function q3(t) {
    return function() {
      return t;
    };
  }
  function H3(t) {
    return function(e) {
      return t(e) + "";
    };
  }
  U3 = function(t, e) {
    var a = xp.lastIndex = Vd.lastIndex = 0, n, l, o, h = -1, u = [], d = [];
    for (t = t + "", e = e + ""; (n = xp.exec(t)) && (l = Vd.exec(e)); ) (o = l.index) > a && (o = e.slice(a, o), u[h] ? u[h] += o : u[++h] = o), (n = n[0]) === (l = l[0]) ? u[h] ? u[h] += l : u[++h] = l : (u[++h] = null, d.push({
      i: h,
      x: Aa(n, l)
    })), a = Vd.lastIndex;
    return a < e.length && (o = e.slice(a), u[h] ? u[h] += o : u[++h] = o), u.length < 2 ? d[0] ? H3(d[0].x) : q3(e) : (e = d.length, function(f) {
      for (var p = 0, m; p < e; ++p) u[(m = d[p]).i] = m.x(f);
      return u.join("");
    });
  };
  var k1 = 180 / Math.PI, vp = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
  };
  function v2(t, e, a, n, l, o) {
    var h, u, d;
    return (h = Math.sqrt(t * t + e * e)) && (t /= h, e /= h), (d = t * a + e * n) && (a -= t * d, n -= e * d), (u = Math.sqrt(a * a + n * n)) && (a /= u, n /= u, d /= u), t * n < e * a && (t = -t, e = -e, d = -d, h = -h), {
      translateX: l,
      translateY: o,
      rotate: Math.atan2(e, t) * k1,
      skewX: Math.atan(d) * k1,
      scaleX: h,
      scaleY: u
    };
  }
  var Zc;
  function j3(t) {
    const e = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(t + "");
    return e.isIdentity ? vp : v2(e.a, e.b, e.c, e.d, e.e, e.f);
  }
  function Y3(t) {
    return t == null || (Zc || (Zc = document.createElementNS("http://www.w3.org/2000/svg", "g")), Zc.setAttribute("transform", t), !(t = Zc.transform.baseVal.consolidate())) ? vp : (t = t.matrix, v2(t.a, t.b, t.c, t.d, t.e, t.f));
  }
  function _2(t, e, a, n) {
    function l(f) {
      return f.length ? f.pop() + " " : "";
    }
    function o(f, p, m, b, x, _) {
      if (f !== m || p !== b) {
        var S = x.push("translate(", null, e, null, a);
        _.push({
          i: S - 4,
          x: Aa(f, m)
        }, {
          i: S - 2,
          x: Aa(p, b)
        });
      } else (m || b) && x.push("translate(" + m + e + b + a);
    }
    function h(f, p, m, b) {
      f !== p ? (f - p > 180 ? p += 360 : p - f > 180 && (f += 360), b.push({
        i: m.push(l(m) + "rotate(", null, n) - 2,
        x: Aa(f, p)
      })) : p && m.push(l(m) + "rotate(" + p + n);
    }
    function u(f, p, m, b) {
      f !== p ? b.push({
        i: m.push(l(m) + "skewX(", null, n) - 2,
        x: Aa(f, p)
      }) : p && m.push(l(m) + "skewX(" + p + n);
    }
    function d(f, p, m, b, x, _) {
      if (f !== m || p !== b) {
        var S = x.push(l(x) + "scale(", null, ",", null, ")");
        _.push({
          i: S - 4,
          x: Aa(f, m)
        }, {
          i: S - 2,
          x: Aa(p, b)
        });
      } else (m !== 1 || b !== 1) && x.push(l(x) + "scale(" + m + "," + b + ")");
    }
    return function(f, p) {
      var m = [], b = [];
      return f = t(f), p = t(p), o(f.translateX, f.translateY, p.translateX, p.translateY, m, b), h(f.rotate, p.rotate, m, b), u(f.skewX, p.skewX, m, b), d(f.scaleX, f.scaleY, p.scaleX, p.scaleY, m, b), f = p = null, function(x) {
        for (var _ = -1, S = b.length, w; ++_ < S; ) m[(w = b[_]).i] = w.x(x);
        return m.join("");
      };
    };
  }
  var I3 = _2(j3, "px, ", "px)", "deg)"), P3 = _2(Y3, ", ", ")", ")"), Cl = 0, Qs = 0, js = 0, S2 = 1e3, Au, Ks, Eu = 0, bn = 0, lh = 0, po = typeof performance == "object" && performance.now ? performance : Date, C2 = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(t) {
    setTimeout(t, 17);
  };
  function vg() {
    return bn || (C2(G3), bn = po.now() + lh);
  }
  function G3() {
    bn = 0;
  }
  function Mu() {
    this._call = this._time = this._next = null;
  }
  Mu.prototype = w2.prototype = {
    constructor: Mu,
    restart: function(t, e, a) {
      if (typeof t != "function") throw new TypeError("callback is not a function");
      a = (a == null ? vg() : +a) + (e == null ? 0 : +e), !this._next && Ks !== this && (Ks ? Ks._next = this : Au = this, Ks = this), this._call = t, this._time = a, _p();
    },
    stop: function() {
      this._call && (this._call = null, this._time = 1 / 0, _p());
    }
  };
  function w2(t, e, a) {
    var n = new Mu();
    return n.restart(t, e, a), n;
  }
  function W3() {
    vg(), ++Cl;
    for (var t = Au, e; t; ) (e = bn - t._time) >= 0 && t._call.call(void 0, e), t = t._next;
    --Cl;
  }
  function A1() {
    bn = (Eu = po.now()) + lh, Cl = Qs = 0;
    try {
      W3();
    } finally {
      Cl = 0, V3(), bn = 0;
    }
  }
  function X3() {
    var t = po.now(), e = t - Eu;
    e > S2 && (lh -= e, Eu = t);
  }
  function V3() {
    for (var t, e = Au, a, n = 1 / 0; e; ) e._call ? (n > e._time && (n = e._time), t = e, e = e._next) : (a = e._next, e._next = null, e = t ? t._next = a : Au = a);
    Ks = t, _p(n);
  }
  function _p(t) {
    if (!Cl) {
      Qs && (Qs = clearTimeout(Qs));
      var e = t - bn;
      e > 24 ? (t < 1 / 0 && (Qs = setTimeout(A1, t - po.now() - lh)), js && (js = clearInterval(js))) : (js || (Eu = po.now(), js = setInterval(X3, S2)), Cl = 1, C2(A1));
    }
  }
  function E1(t, e, a) {
    var n = new Mu();
    return e = e == null ? 0 : +e, n.restart((l) => {
      n.stop(), t(l + e);
    }, e, a), n;
  }
  var Z3 = r2("start", "end", "cancel", "interrupt"), Q3 = [], T2 = 0, M1 = 1, Sp = 2, ou = 3, B1 = 4, Cp = 5, cu = 6;
  function sh(t, e, a, n, l, o) {
    var h = t.__transition;
    if (!h) t.__transition = {};
    else if (a in h) return;
    K3(t, a, {
      name: e,
      index: n,
      group: l,
      on: Z3,
      tween: Q3,
      time: o.time,
      delay: o.delay,
      duration: o.duration,
      ease: o.ease,
      timer: null,
      state: T2
    });
  }
  function _g(t, e) {
    var a = rr(t, e);
    if (a.state > T2) throw new Error("too late; already scheduled");
    return a;
  }
  function xr(t, e) {
    var a = rr(t, e);
    if (a.state > ou) throw new Error("too late; already running");
    return a;
  }
  function rr(t, e) {
    var a = t.__transition;
    if (!a || !(a = a[e])) throw new Error("transition not found");
    return a;
  }
  function K3(t, e, a) {
    var n = t.__transition, l;
    n[e] = a, a.timer = w2(o, 0, a.time);
    function o(f) {
      a.state = M1, a.timer.restart(h, a.delay, a.time), a.delay <= f && h(f - a.delay);
    }
    function h(f) {
      var p, m, b, x;
      if (a.state !== M1) return d();
      for (p in n) if (x = n[p], x.name === a.name) {
        if (x.state === ou) return E1(h);
        x.state === B1 ? (x.state = cu, x.timer.stop(), x.on.call("interrupt", t, t.__data__, x.index, x.group), delete n[p]) : +p < e && (x.state = cu, x.timer.stop(), x.on.call("cancel", t, t.__data__, x.index, x.group), delete n[p]);
      }
      if (E1(function() {
        a.state === ou && (a.state = B1, a.timer.restart(u, a.delay, a.time), u(f));
      }), a.state = Sp, a.on.call("start", t, t.__data__, a.index, a.group), a.state === Sp) {
        for (a.state = ou, l = new Array(b = a.tween.length), p = 0, m = -1; p < b; ++p) (x = a.tween[p].value.call(t, t.__data__, a.index, a.group)) && (l[++m] = x);
        l.length = m + 1;
      }
    }
    function u(f) {
      for (var p = f < a.duration ? a.ease.call(null, f / a.duration) : (a.timer.restart(d), a.state = Cp, 1), m = -1, b = l.length; ++m < b; ) l[m].call(t, p);
      a.state === Cp && (a.on.call("end", t, t.__data__, a.index, a.group), d());
    }
    function d() {
      a.state = cu, a.timer.stop(), delete n[e];
      for (var f in n) return;
      delete t.__transition;
    }
  }
  function J3(t, e) {
    var a = t.__transition, n, l, o = true, h;
    if (a) {
      e = e == null ? null : e + "";
      for (h in a) {
        if ((n = a[h]).name !== e) {
          o = false;
          continue;
        }
        l = n.state > Sp && n.state < Cp, n.state = cu, n.timer.stop(), n.on.call(l ? "interrupt" : "cancel", t, t.__data__, n.index, n.group), delete a[h];
      }
      o && delete t.__transition;
    }
  }
  function tB(t) {
    return this.each(function() {
      J3(this, t);
    });
  }
  function eB(t, e) {
    var a, n;
    return function() {
      var l = xr(this, t), o = l.tween;
      if (o !== a) {
        n = a = o;
        for (var h = 0, u = n.length; h < u; ++h) if (n[h].name === e) {
          n = n.slice(), n.splice(h, 1);
          break;
        }
      }
      l.tween = n;
    };
  }
  function iB(t, e, a) {
    var n, l;
    if (typeof a != "function") throw new Error();
    return function() {
      var o = xr(this, t), h = o.tween;
      if (h !== n) {
        l = (n = h).slice();
        for (var u = {
          name: e,
          value: a
        }, d = 0, f = l.length; d < f; ++d) if (l[d].name === e) {
          l[d] = u;
          break;
        }
        d === f && l.push(u);
      }
      o.tween = l;
    };
  }
  function rB(t, e) {
    var a = this._id;
    if (t += "", arguments.length < 2) {
      for (var n = rr(this.node(), a).tween, l = 0, o = n.length, h; l < o; ++l) if ((h = n[l]).name === t) return h.value;
      return null;
    }
    return this.each((e == null ? eB : iB)(a, t, e));
  }
  function Sg(t, e, a) {
    var n = t._id;
    return t.each(function() {
      var l = xr(this, n);
      (l.value || (l.value = {}))[e] = a.apply(this, arguments);
    }), function(l) {
      return rr(l, n).value[e];
    };
  }
  function k2(t, e) {
    var a;
    return (typeof e == "number" ? Aa : e instanceof fo ? T1 : (a = fo(e)) ? (e = a, T1) : U3)(t, e);
  }
  function aB(t) {
    return function() {
      this.removeAttribute(t);
    };
  }
  function nB(t) {
    return function() {
      this.removeAttributeNS(t.space, t.local);
    };
  }
  function lB(t, e, a) {
    var n, l = a + "", o;
    return function() {
      var h = this.getAttribute(t);
      return h === l ? null : h === n ? o : o = e(n = h, a);
    };
  }
  function sB(t, e, a) {
    var n, l = a + "", o;
    return function() {
      var h = this.getAttributeNS(t.space, t.local);
      return h === l ? null : h === n ? o : o = e(n = h, a);
    };
  }
  function oB(t, e, a) {
    var n, l, o;
    return function() {
      var h, u = a(this), d;
      return u == null ? void this.removeAttribute(t) : (h = this.getAttribute(t), d = u + "", h === d ? null : h === n && d === l ? o : (l = d, o = e(n = h, u)));
    };
  }
  function cB(t, e, a) {
    var n, l, o;
    return function() {
      var h, u = a(this), d;
      return u == null ? void this.removeAttributeNS(t.space, t.local) : (h = this.getAttributeNS(t.space, t.local), d = u + "", h === d ? null : h === n && d === l ? o : (l = d, o = e(n = h, u)));
    };
  }
  function uB(t, e) {
    var a = nh(t), n = a === "transform" ? P3 : k2;
    return this.attrTween(t, typeof e == "function" ? (a.local ? cB : oB)(a, n, Sg(this, "attr." + t, e)) : e == null ? (a.local ? nB : aB)(a) : (a.local ? sB : lB)(a, n, e));
  }
  function hB(t, e) {
    return function(a) {
      this.setAttribute(t, e.call(this, a));
    };
  }
  function fB(t, e) {
    return function(a) {
      this.setAttributeNS(t.space, t.local, e.call(this, a));
    };
  }
  function dB(t, e) {
    var a, n;
    function l() {
      var o = e.apply(this, arguments);
      return o !== n && (a = (n = o) && fB(t, o)), a;
    }
    return l._value = e, l;
  }
  function pB(t, e) {
    var a, n;
    function l() {
      var o = e.apply(this, arguments);
      return o !== n && (a = (n = o) && hB(t, o)), a;
    }
    return l._value = e, l;
  }
  function gB(t, e) {
    var a = "attr." + t;
    if (arguments.length < 2) return (a = this.tween(a)) && a._value;
    if (e == null) return this.tween(a, null);
    if (typeof e != "function") throw new Error();
    var n = nh(t);
    return this.tween(a, (n.local ? dB : pB)(n, e));
  }
  function mB(t, e) {
    return function() {
      _g(this, t).delay = +e.apply(this, arguments);
    };
  }
  function yB(t, e) {
    return e = +e, function() {
      _g(this, t).delay = e;
    };
  }
  function bB(t) {
    var e = this._id;
    return arguments.length ? this.each((typeof t == "function" ? mB : yB)(e, t)) : rr(this.node(), e).delay;
  }
  function xB(t, e) {
    return function() {
      xr(this, t).duration = +e.apply(this, arguments);
    };
  }
  function vB(t, e) {
    return e = +e, function() {
      xr(this, t).duration = e;
    };
  }
  function _B(t) {
    var e = this._id;
    return arguments.length ? this.each((typeof t == "function" ? xB : vB)(e, t)) : rr(this.node(), e).duration;
  }
  function SB(t, e) {
    if (typeof e != "function") throw new Error();
    return function() {
      xr(this, t).ease = e;
    };
  }
  function CB(t) {
    var e = this._id;
    return arguments.length ? this.each(SB(e, t)) : rr(this.node(), e).ease;
  }
  function wB(t, e) {
    return function() {
      var a = e.apply(this, arguments);
      if (typeof a != "function") throw new Error();
      xr(this, t).ease = a;
    };
  }
  function TB(t) {
    if (typeof t != "function") throw new Error();
    return this.each(wB(this._id, t));
  }
  function kB(t) {
    typeof t != "function" && (t = l2(t));
    for (var e = this._groups, a = e.length, n = new Array(a), l = 0; l < a; ++l) for (var o = e[l], h = o.length, u = n[l] = [], d, f = 0; f < h; ++f) (d = o[f]) && t.call(d, d.__data__, f, o) && u.push(d);
    return new Zr(n, this._parents, this._name, this._id);
  }
  function AB(t) {
    if (t._id !== this._id) throw new Error();
    for (var e = this._groups, a = t._groups, n = e.length, l = a.length, o = Math.min(n, l), h = new Array(n), u = 0; u < o; ++u) for (var d = e[u], f = a[u], p = d.length, m = h[u] = new Array(p), b, x = 0; x < p; ++x) (b = d[x] || f[x]) && (m[x] = b);
    for (; u < n; ++u) h[u] = e[u];
    return new Zr(h, this._parents, this._name, this._id);
  }
  function EB(t) {
    return (t + "").trim().split(/^|\s+/).every(function(e) {
      var a = e.indexOf(".");
      return a >= 0 && (e = e.slice(0, a)), !e || e === "start";
    });
  }
  function MB(t, e, a) {
    var n, l, o = EB(e) ? _g : xr;
    return function() {
      var h = o(this, t), u = h.on;
      u !== n && (l = (n = u).copy()).on(e, a), h.on = l;
    };
  }
  function BB(t, e) {
    var a = this._id;
    return arguments.length < 2 ? rr(this.node(), a).on.on(t) : this.each(MB(a, t, e));
  }
  function LB(t) {
    return function() {
      var e = this.parentNode;
      for (var a in this.__transition) if (+a !== t) return;
      e && e.removeChild(this);
    };
  }
  function OB() {
    return this.on("end.remove", LB(this._id));
  }
  function DB(t) {
    var e = this._name, a = this._id;
    typeof t != "function" && (t = mg(t));
    for (var n = this._groups, l = n.length, o = new Array(l), h = 0; h < l; ++h) for (var u = n[h], d = u.length, f = o[h] = new Array(d), p, m, b = 0; b < d; ++b) (p = u[b]) && (m = t.call(p, p.__data__, b, u)) && ("__data__" in p && (m.__data__ = p.__data__), f[b] = m, sh(f[b], e, a, b, f, rr(p, a)));
    return new Zr(o, this._parents, e, a);
  }
  function RB(t) {
    var e = this._name, a = this._id;
    typeof t != "function" && (t = n2(t));
    for (var n = this._groups, l = n.length, o = [], h = [], u = 0; u < l; ++u) for (var d = n[u], f = d.length, p, m = 0; m < f; ++m) if (p = d[m]) {
      for (var b = t.call(p, p.__data__, m, d), x, _ = rr(p, a), S = 0, w = b.length; S < w; ++S) (x = b[S]) && sh(x, e, a, S, b, _);
      o.push(b), h.push(p);
    }
    return new Zr(o, h, e, a);
  }
  var $B = ko.prototype.constructor;
  function NB() {
    return new $B(this._groups, this._parents);
  }
  function zB(t, e) {
    var a, n, l;
    return function() {
      var o = Sl(this, t), h = (this.style.removeProperty(t), Sl(this, t));
      return o === h ? null : o === a && h === n ? l : l = e(a = o, n = h);
    };
  }
  function A2(t) {
    return function() {
      this.style.removeProperty(t);
    };
  }
  function FB(t, e, a) {
    var n, l = a + "", o;
    return function() {
      var h = Sl(this, t);
      return h === l ? null : h === n ? o : o = e(n = h, a);
    };
  }
  function qB(t, e, a) {
    var n, l, o;
    return function() {
      var h = Sl(this, t), u = a(this), d = u + "";
      return u == null && (d = u = (this.style.removeProperty(t), Sl(this, t))), h === d ? null : h === n && d === l ? o : (l = d, o = e(n = h, u));
    };
  }
  function HB(t, e) {
    var a, n, l, o = "style." + e, h = "end." + o, u;
    return function() {
      var d = xr(this, t), f = d.on, p = d.value[o] == null ? u || (u = A2(e)) : void 0;
      (f !== a || l !== p) && (n = (a = f).copy()).on(h, l = p), d.on = n;
    };
  }
  function UB(t, e, a) {
    var n = (t += "") == "transform" ? I3 : k2;
    return e == null ? this.styleTween(t, zB(t, n)).on("end.style." + t, A2(t)) : typeof e == "function" ? this.styleTween(t, qB(t, n, Sg(this, "style." + t, e))).each(HB(this._id, t)) : this.styleTween(t, FB(t, n, e), a).on("end.style." + t, null);
  }
  function jB(t, e, a) {
    return function(n) {
      this.style.setProperty(t, e.call(this, n), a);
    };
  }
  function YB(t, e, a) {
    var n, l;
    function o() {
      var h = e.apply(this, arguments);
      return h !== l && (n = (l = h) && jB(t, h, a)), n;
    }
    return o._value = e, o;
  }
  function IB(t, e, a) {
    var n = "style." + (t += "");
    if (arguments.length < 2) return (n = this.tween(n)) && n._value;
    if (e == null) return this.tween(n, null);
    if (typeof e != "function") throw new Error();
    return this.tween(n, YB(t, e, a ?? ""));
  }
  function PB(t) {
    return function() {
      this.textContent = t;
    };
  }
  function GB(t) {
    return function() {
      var e = t(this);
      this.textContent = e ?? "";
    };
  }
  function WB(t) {
    return this.tween("text", typeof t == "function" ? GB(Sg(this, "text", t)) : PB(t == null ? "" : t + ""));
  }
  function XB(t) {
    return function(e) {
      this.textContent = t.call(this, e);
    };
  }
  function VB(t) {
    var e, a;
    function n() {
      var l = t.apply(this, arguments);
      return l !== a && (e = (a = l) && XB(l)), e;
    }
    return n._value = t, n;
  }
  function ZB(t) {
    var e = "text";
    if (arguments.length < 1) return (e = this.tween(e)) && e._value;
    if (t == null) return this.tween(e, null);
    if (typeof t != "function") throw new Error();
    return this.tween(e, VB(t));
  }
  function QB() {
    for (var t = this._name, e = this._id, a = E2(), n = this._groups, l = n.length, o = 0; o < l; ++o) for (var h = n[o], u = h.length, d, f = 0; f < u; ++f) if (d = h[f]) {
      var p = rr(d, e);
      sh(d, t, a, f, h, {
        time: p.time + p.delay + p.duration,
        delay: 0,
        duration: p.duration,
        ease: p.ease
      });
    }
    return new Zr(n, this._parents, t, a);
  }
  function KB() {
    var t, e, a = this, n = a._id, l = a.size();
    return new Promise(function(o, h) {
      var u = {
        value: h
      }, d = {
        value: function() {
          --l === 0 && o();
        }
      };
      a.each(function() {
        var f = xr(this, n), p = f.on;
        p !== t && (e = (t = p).copy(), e._.cancel.push(u), e._.interrupt.push(u), e._.end.push(d)), f.on = e;
      }), l === 0 && o();
    });
  }
  var JB = 0;
  function Zr(t, e, a, n) {
    this._groups = t, this._parents = e, this._name = a, this._id = n;
  }
  function E2() {
    return ++JB;
  }
  var jr = ko.prototype;
  Zr.prototype = {
    constructor: Zr,
    select: DB,
    selectAll: RB,
    selectChild: jr.selectChild,
    selectChildren: jr.selectChildren,
    filter: kB,
    merge: AB,
    selection: NB,
    transition: QB,
    call: jr.call,
    nodes: jr.nodes,
    node: jr.node,
    size: jr.size,
    empty: jr.empty,
    each: jr.each,
    on: BB,
    attr: uB,
    attrTween: gB,
    style: UB,
    styleTween: IB,
    text: WB,
    textTween: ZB,
    remove: OB,
    tween: rB,
    delay: bB,
    duration: _B,
    ease: CB,
    easeVarying: TB,
    end: KB,
    [Symbol.iterator]: jr[Symbol.iterator]
  };
  function tL(t) {
    return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
  }
  var eL = {
    time: null,
    delay: 0,
    duration: 250,
    ease: tL
  };
  function iL(t, e) {
    for (var a; !(a = t.__transition) || !(a = a[e]); ) if (!(t = t.parentNode)) throw new Error(`transition ${e} not found`);
    return a;
  }
  function rL(t) {
    var e, a;
    t instanceof Zr ? (e = t._id, t = t._name) : (e = E2(), (a = eL).time = vg(), t = t == null ? null : t + "");
    for (var n = this._groups, l = n.length, o = 0; o < l; ++o) for (var h = n[o], u = h.length, d, f = 0; f < u; ++f) (d = h[f]) && sh(d, t, e, f, h, a || iL(d, e));
    return new Zr(n, this._parents, t, e);
  }
  ko.prototype.interrupt = tB;
  ko.prototype.transition = rL;
  const wp = Math.PI, Tp = 2 * wp, sn = 1e-6, aL = Tp - sn;
  function M2(t) {
    this._ += t[0];
    for (let e = 1, a = t.length; e < a; ++e) this._ += arguments[e] + t[e];
  }
  function nL(t) {
    let e = Math.floor(t);
    if (!(e >= 0)) throw new Error(`invalid digits: ${t}`);
    if (e > 15) return M2;
    const a = 10 ** e;
    return function(n) {
      this._ += n[0];
      for (let l = 1, o = n.length; l < o; ++l) this._ += Math.round(arguments[l] * a) / a + n[l];
    };
  }
  class lL {
    constructor(e) {
      this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = "", this._append = e == null ? M2 : nL(e);
    }
    moveTo(e, a) {
      this._append`M${this._x0 = this._x1 = +e},${this._y0 = this._y1 = +a}`;
    }
    closePath() {
      this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
    }
    lineTo(e, a) {
      this._append`L${this._x1 = +e},${this._y1 = +a}`;
    }
    quadraticCurveTo(e, a, n, l) {
      this._append`Q${+e},${+a},${this._x1 = +n},${this._y1 = +l}`;
    }
    bezierCurveTo(e, a, n, l, o, h) {
      this._append`C${+e},${+a},${+n},${+l},${this._x1 = +o},${this._y1 = +h}`;
    }
    arcTo(e, a, n, l, o) {
      if (e = +e, a = +a, n = +n, l = +l, o = +o, o < 0) throw new Error(`negative radius: ${o}`);
      let h = this._x1, u = this._y1, d = n - e, f = l - a, p = h - e, m = u - a, b = p * p + m * m;
      if (this._x1 === null) this._append`M${this._x1 = e},${this._y1 = a}`;
      else if (b > sn) if (!(Math.abs(m * d - f * p) > sn) || !o) this._append`L${this._x1 = e},${this._y1 = a}`;
      else {
        let x = n - h, _ = l - u, S = d * d + f * f, w = x * x + _ * _, k = Math.sqrt(S), A = Math.sqrt(b), L = o * Math.tan((wp - Math.acos((S + b - w) / (2 * k * A))) / 2), $ = L / A, O = L / k;
        Math.abs($ - 1) > sn && this._append`L${e + $ * p},${a + $ * m}`, this._append`A${o},${o},0,0,${+(m * x > p * _)},${this._x1 = e + O * d},${this._y1 = a + O * f}`;
      }
    }
    arc(e, a, n, l, o, h) {
      if (e = +e, a = +a, n = +n, h = !!h, n < 0) throw new Error(`negative radius: ${n}`);
      let u = n * Math.cos(l), d = n * Math.sin(l), f = e + u, p = a + d, m = 1 ^ h, b = h ? l - o : o - l;
      this._x1 === null ? this._append`M${f},${p}` : (Math.abs(this._x1 - f) > sn || Math.abs(this._y1 - p) > sn) && this._append`L${f},${p}`, n && (b < 0 && (b = b % Tp + Tp), b > aL ? this._append`A${n},${n},0,1,${m},${e - u},${a - d}A${n},${n},0,1,${m},${this._x1 = f},${this._y1 = p}` : b > sn && this._append`A${n},${n},0,${+(b >= wp)},${m},${this._x1 = e + n * Math.cos(o)},${this._y1 = a + n * Math.sin(o)}`);
    }
    rect(e, a, n, l) {
      this._append`M${this._x0 = this._x1 = +e},${this._y0 = this._y1 = +a}h${n = +n}v${+l}h${-n}Z`;
    }
    toString() {
      return this._;
    }
  }
  hl = function(t) {
    return function() {
      return t;
    };
  };
  mz = Math.abs;
  yz = Math.atan2;
  bz = Math.cos;
  xz = Math.max;
  vz = Math.min;
  _z = Math.sin;
  Sz = Math.sqrt;
  L1 = 1e-12;
  Cg = Math.PI;
  O1 = Cg / 2;
  Cz = 2 * Cg;
  wz = function(t) {
    return t > 1 ? 0 : t < -1 ? Cg : Math.acos(t);
  };
  Tz = function(t) {
    return t >= 1 ? O1 : t <= -1 ? -O1 : Math.asin(t);
  };
  sL = function(t) {
    let e = 3;
    return t.digits = function(a) {
      if (!arguments.length) return e;
      if (a == null) e = null;
      else {
        const n = Math.floor(a);
        if (!(n >= 0)) throw new RangeError(`invalid digits: ${a}`);
        e = n;
      }
      return t;
    }, () => new lL(e);
  };
  oL = function(t) {
    return typeof t == "object" && "length" in t ? t : Array.from(t);
  };
  function B2(t) {
    this._context = t;
  }
  B2.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function(t, e) {
      switch (t = +t, e = +e, this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
          break;
        case 1:
          this._point = 2;
        default:
          this._context.lineTo(t, e);
          break;
      }
    }
  };
  function Bu(t) {
    return new B2(t);
  }
  function cL(t) {
    return t[0];
  }
  function uL(t) {
    return t[1];
  }
  hL = function(t, e) {
    var a = hl(true), n = null, l = Bu, o = null, h = sL(u);
    t = typeof t == "function" ? t : t === void 0 ? cL : hl(t), e = typeof e == "function" ? e : e === void 0 ? uL : hl(e);
    function u(d) {
      var f, p = (d = oL(d)).length, m, b = false, x;
      for (n == null && (o = l(x = h())), f = 0; f <= p; ++f) !(f < p && a(m = d[f], f, d)) === b && ((b = !b) ? o.lineStart() : o.lineEnd()), b && o.point(+t(m, f, d), +e(m, f, d));
      if (x) return o = null, x + "" || null;
    }
    return u.x = function(d) {
      return arguments.length ? (t = typeof d == "function" ? d : hl(+d), u) : t;
    }, u.y = function(d) {
      return arguments.length ? (e = typeof d == "function" ? d : hl(+d), u) : e;
    }, u.defined = function(d) {
      return arguments.length ? (a = typeof d == "function" ? d : hl(!!d), u) : a;
    }, u.curve = function(d) {
      return arguments.length ? (l = d, n != null && (o = l(n)), u) : l;
    }, u.context = function(d) {
      return arguments.length ? (d == null ? n = o = null : o = l(n = d), u) : n;
    }, u;
  };
  class L2 {
    constructor(e, a) {
      this._context = e, this._x = a;
    }
    areaStart() {
      this._line = 0;
    }
    areaEnd() {
      this._line = NaN;
    }
    lineStart() {
      this._point = 0;
    }
    lineEnd() {
      (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
    }
    point(e, a) {
      switch (e = +e, a = +a, this._point) {
        case 0: {
          this._point = 1, this._line ? this._context.lineTo(e, a) : this._context.moveTo(e, a);
          break;
        }
        case 1:
          this._point = 2;
        default: {
          this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + e) / 2, this._y0, this._x0, a, e, a) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + a) / 2, e, this._y0, e, a);
          break;
        }
      }
      this._x0 = e, this._y0 = a;
    }
  }
  function O2(t) {
    return new L2(t, true);
  }
  function D2(t) {
    return new L2(t, false);
  }
  function Ba() {
  }
  function Lu(t, e, a) {
    t._context.bezierCurveTo((2 * t._x0 + t._x1) / 3, (2 * t._y0 + t._y1) / 3, (t._x0 + 2 * t._x1) / 3, (t._y0 + 2 * t._y1) / 3, (t._x0 + 4 * t._x1 + e) / 6, (t._y0 + 4 * t._y1 + a) / 6);
  }
  function oh(t) {
    this._context = t;
  }
  oh.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 3:
          Lu(this, this._x1, this._y1);
        case 2:
          this._context.lineTo(this._x1, this._y1);
          break;
      }
      (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function(t, e) {
      switch (t = +t, e = +e, this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
        default:
          Lu(this, t, e);
          break;
      }
      this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e;
    }
  };
  uu = function(t) {
    return new oh(t);
  };
  function R2(t) {
    this._context = t;
  }
  R2.prototype = {
    areaStart: Ba,
    areaEnd: Ba,
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x2, this._y2), this._context.closePath();
          break;
        }
        case 2: {
          this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
          break;
        }
      }
    },
    point: function(t, e) {
      switch (t = +t, e = +e, this._point) {
        case 0:
          this._point = 1, this._x2 = t, this._y2 = e;
          break;
        case 1:
          this._point = 2, this._x3 = t, this._y3 = e;
          break;
        case 2:
          this._point = 3, this._x4 = t, this._y4 = e, this._context.moveTo((this._x0 + 4 * this._x1 + t) / 6, (this._y0 + 4 * this._y1 + e) / 6);
          break;
        default:
          Lu(this, t, e);
          break;
      }
      this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e;
    }
  };
  function fL(t) {
    return new R2(t);
  }
  function $2(t) {
    this._context = t;
  }
  $2.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
    },
    lineEnd: function() {
      (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function(t, e) {
      switch (t = +t, e = +e, this._point) {
        case 0:
          this._point = 1;
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          var a = (this._x0 + 4 * this._x1 + t) / 6, n = (this._y0 + 4 * this._y1 + e) / 6;
          this._line ? this._context.lineTo(a, n) : this._context.moveTo(a, n);
          break;
        case 3:
          this._point = 4;
        default:
          Lu(this, t, e);
          break;
      }
      this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e;
    }
  };
  function dL(t) {
    return new $2(t);
  }
  function N2(t, e) {
    this._basis = new oh(t), this._beta = e;
  }
  N2.prototype = {
    lineStart: function() {
      this._x = [], this._y = [], this._basis.lineStart();
    },
    lineEnd: function() {
      var t = this._x, e = this._y, a = t.length - 1;
      if (a > 0) for (var n = t[0], l = e[0], o = t[a] - n, h = e[a] - l, u = -1, d; ++u <= a; ) d = u / a, this._basis.point(this._beta * t[u] + (1 - this._beta) * (n + d * o), this._beta * e[u] + (1 - this._beta) * (l + d * h));
      this._x = this._y = null, this._basis.lineEnd();
    },
    point: function(t, e) {
      this._x.push(+t), this._y.push(+e);
    }
  };
  const pL = (function t(e) {
    function a(n) {
      return e === 1 ? new oh(n) : new N2(n, e);
    }
    return a.beta = function(n) {
      return t(+n);
    }, a;
  })(0.85);
  function Ou(t, e, a) {
    t._context.bezierCurveTo(t._x1 + t._k * (t._x2 - t._x0), t._y1 + t._k * (t._y2 - t._y0), t._x2 + t._k * (t._x1 - e), t._y2 + t._k * (t._y1 - a), t._x2, t._y2);
  }
  function wg(t, e) {
    this._context = t, this._k = (1 - e) / 6;
  }
  wg.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x2, this._y2);
          break;
        case 3:
          Ou(this, this._x1, this._y1);
          break;
      }
      (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function(t, e) {
      switch (t = +t, e = +e, this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
          break;
        case 1:
          this._point = 2, this._x1 = t, this._y1 = e;
          break;
        case 2:
          this._point = 3;
        default:
          Ou(this, t, e);
          break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
    }
  };
  const z2 = (function t(e) {
    function a(n) {
      return new wg(n, e);
    }
    return a.tension = function(n) {
      return t(+n);
    }, a;
  })(0);
  function Tg(t, e) {
    this._context = t, this._k = (1 - e) / 6;
  }
  Tg.prototype = {
    areaStart: Ba,
    areaEnd: Ba,
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x3, this._y3), this._context.closePath();
          break;
        }
        case 2: {
          this._context.lineTo(this._x3, this._y3), this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
          break;
        }
      }
    },
    point: function(t, e) {
      switch (t = +t, e = +e, this._point) {
        case 0:
          this._point = 1, this._x3 = t, this._y3 = e;
          break;
        case 1:
          this._point = 2, this._context.moveTo(this._x4 = t, this._y4 = e);
          break;
        case 2:
          this._point = 3, this._x5 = t, this._y5 = e;
          break;
        default:
          Ou(this, t, e);
          break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
    }
  };
  const gL = (function t(e) {
    function a(n) {
      return new Tg(n, e);
    }
    return a.tension = function(n) {
      return t(+n);
    }, a;
  })(0);
  function kg(t, e) {
    this._context = t, this._k = (1 - e) / 6;
  }
  kg.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
    },
    lineEnd: function() {
      (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function(t, e) {
      switch (t = +t, e = +e, this._point) {
        case 0:
          this._point = 1;
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
          break;
        case 3:
          this._point = 4;
        default:
          Ou(this, t, e);
          break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
    }
  };
  const mL = (function t(e) {
    function a(n) {
      return new kg(n, e);
    }
    return a.tension = function(n) {
      return t(+n);
    }, a;
  })(0);
  function Ag(t, e, a) {
    var n = t._x1, l = t._y1, o = t._x2, h = t._y2;
    if (t._l01_a > L1) {
      var u = 2 * t._l01_2a + 3 * t._l01_a * t._l12_a + t._l12_2a, d = 3 * t._l01_a * (t._l01_a + t._l12_a);
      n = (n * u - t._x0 * t._l12_2a + t._x2 * t._l01_2a) / d, l = (l * u - t._y0 * t._l12_2a + t._y2 * t._l01_2a) / d;
    }
    if (t._l23_a > L1) {
      var f = 2 * t._l23_2a + 3 * t._l23_a * t._l12_a + t._l12_2a, p = 3 * t._l23_a * (t._l23_a + t._l12_a);
      o = (o * f + t._x1 * t._l23_2a - e * t._l12_2a) / p, h = (h * f + t._y1 * t._l23_2a - a * t._l12_2a) / p;
    }
    t._context.bezierCurveTo(n, l, o, h, t._x2, t._y2);
  }
  function F2(t, e) {
    this._context = t, this._alpha = e;
  }
  F2.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x2, this._y2);
          break;
        case 3:
          this.point(this._x2, this._y2);
          break;
      }
      (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function(t, e) {
      if (t = +t, e = +e, this._point) {
        var a = this._x2 - t, n = this._y2 - e;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(a * a + n * n, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
        default:
          Ag(this, t, e);
          break;
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
    }
  };
  const q2 = (function t(e) {
    function a(n) {
      return e ? new F2(n, e) : new wg(n, 0);
    }
    return a.alpha = function(n) {
      return t(+n);
    }, a;
  })(0.5);
  function H2(t, e) {
    this._context = t, this._alpha = e;
  }
  H2.prototype = {
    areaStart: Ba,
    areaEnd: Ba,
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x3, this._y3), this._context.closePath();
          break;
        }
        case 2: {
          this._context.lineTo(this._x3, this._y3), this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
          break;
        }
      }
    },
    point: function(t, e) {
      if (t = +t, e = +e, this._point) {
        var a = this._x2 - t, n = this._y2 - e;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(a * a + n * n, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1, this._x3 = t, this._y3 = e;
          break;
        case 1:
          this._point = 2, this._context.moveTo(this._x4 = t, this._y4 = e);
          break;
        case 2:
          this._point = 3, this._x5 = t, this._y5 = e;
          break;
        default:
          Ag(this, t, e);
          break;
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
    }
  };
  const yL = (function t(e) {
    function a(n) {
      return e ? new H2(n, e) : new Tg(n, 0);
    }
    return a.alpha = function(n) {
      return t(+n);
    }, a;
  })(0.5);
  function U2(t, e) {
    this._context = t, this._alpha = e;
  }
  U2.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
      (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function(t, e) {
      if (t = +t, e = +e, this._point) {
        var a = this._x2 - t, n = this._y2 - e;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(a * a + n * n, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1;
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
          break;
        case 3:
          this._point = 4;
        default:
          Ag(this, t, e);
          break;
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
    }
  };
  const bL = (function t(e) {
    function a(n) {
      return e ? new U2(n, e) : new kg(n, 0);
    }
    return a.alpha = function(n) {
      return t(+n);
    }, a;
  })(0.5);
  function j2(t) {
    this._context = t;
  }
  j2.prototype = {
    areaStart: Ba,
    areaEnd: Ba,
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      this._point && this._context.closePath();
    },
    point: function(t, e) {
      t = +t, e = +e, this._point ? this._context.lineTo(t, e) : (this._point = 1, this._context.moveTo(t, e));
    }
  };
  function xL(t) {
    return new j2(t);
  }
  function D1(t) {
    return t < 0 ? -1 : 1;
  }
  function R1(t, e, a) {
    var n = t._x1 - t._x0, l = e - t._x1, o = (t._y1 - t._y0) / (n || l < 0 && -0), h = (a - t._y1) / (l || n < 0 && -0), u = (o * l + h * n) / (n + l);
    return (D1(o) + D1(h)) * Math.min(Math.abs(o), Math.abs(h), 0.5 * Math.abs(u)) || 0;
  }
  function $1(t, e) {
    var a = t._x1 - t._x0;
    return a ? (3 * (t._y1 - t._y0) / a - e) / 2 : e;
  }
  function Zd(t, e, a) {
    var n = t._x0, l = t._y0, o = t._x1, h = t._y1, u = (o - n) / 3;
    t._context.bezierCurveTo(n + u, l + u * e, o - u, h - u * a, o, h);
  }
  function Du(t) {
    this._context = t;
  }
  Du.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x1, this._y1);
          break;
        case 3:
          Zd(this, this._t0, $1(this, this._t0));
          break;
      }
      (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
    },
    point: function(t, e) {
      var a = NaN;
      if (t = +t, e = +e, !(t === this._x1 && e === this._y1)) {
        switch (this._point) {
          case 0:
            this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3, Zd(this, $1(this, a = R1(this, t, e)), a);
            break;
          default:
            Zd(this, this._t0, a = R1(this, t, e));
            break;
        }
        this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e, this._t0 = a;
      }
    }
  };
  function Y2(t) {
    this._context = new I2(t);
  }
  (Y2.prototype = Object.create(Du.prototype)).point = function(t, e) {
    Du.prototype.point.call(this, e, t);
  };
  function I2(t) {
    this._context = t;
  }
  I2.prototype = {
    moveTo: function(t, e) {
      this._context.moveTo(e, t);
    },
    closePath: function() {
      this._context.closePath();
    },
    lineTo: function(t, e) {
      this._context.lineTo(e, t);
    },
    bezierCurveTo: function(t, e, a, n, l, o) {
      this._context.bezierCurveTo(e, t, n, a, o, l);
    }
  };
  function P2(t) {
    return new Du(t);
  }
  function G2(t) {
    return new Y2(t);
  }
  function W2(t) {
    this._context = t;
  }
  W2.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x = [], this._y = [];
    },
    lineEnd: function() {
      var t = this._x, e = this._y, a = t.length;
      if (a) if (this._line ? this._context.lineTo(t[0], e[0]) : this._context.moveTo(t[0], e[0]), a === 2) this._context.lineTo(t[1], e[1]);
      else for (var n = N1(t), l = N1(e), o = 0, h = 1; h < a; ++o, ++h) this._context.bezierCurveTo(n[0][o], l[0][o], n[1][o], l[1][o], t[h], e[h]);
      (this._line || this._line !== 0 && a === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
    },
    point: function(t, e) {
      this._x.push(+t), this._y.push(+e);
    }
  };
  function N1(t) {
    var e, a = t.length - 1, n, l = new Array(a), o = new Array(a), h = new Array(a);
    for (l[0] = 0, o[0] = 2, h[0] = t[0] + 2 * t[1], e = 1; e < a - 1; ++e) l[e] = 1, o[e] = 4, h[e] = 4 * t[e] + 2 * t[e + 1];
    for (l[a - 1] = 2, o[a - 1] = 7, h[a - 1] = 8 * t[a - 1] + t[a], e = 1; e < a; ++e) n = l[e] / o[e - 1], o[e] -= n, h[e] -= n * h[e - 1];
    for (l[a - 1] = h[a - 1] / o[a - 1], e = a - 2; e >= 0; --e) l[e] = (h[e] - l[e + 1]) / o[e];
    for (o[a - 1] = (t[a] + l[a - 1]) / 2, e = 0; e < a - 1; ++e) o[e] = 2 * t[e + 1] - l[e + 1];
    return [
      l,
      o
    ];
  }
  function X2(t) {
    return new W2(t);
  }
  function ch(t, e) {
    this._context = t, this._t = e;
  }
  ch.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x = this._y = NaN, this._point = 0;
    },
    lineEnd: function() {
      0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
    },
    point: function(t, e) {
      switch (t = +t, e = +e, this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
          break;
        case 1:
          this._point = 2;
        default: {
          if (this._t <= 0) this._context.lineTo(this._x, e), this._context.lineTo(t, e);
          else {
            var a = this._x * (1 - this._t) + t * this._t;
            this._context.lineTo(a, this._y), this._context.lineTo(a, e);
          }
          break;
        }
      }
      this._x = t, this._y = e;
    }
  };
  function V2(t) {
    return new ch(t, 0.5);
  }
  function Z2(t) {
    return new ch(t, 0);
  }
  function Q2(t) {
    return new ch(t, 1);
  }
  function Js(t, e, a) {
    this.k = t, this.x = e, this.y = a;
  }
  Js.prototype = {
    constructor: Js,
    scale: function(t) {
      return t === 1 ? this : new Js(this.k * t, this.x, this.y);
    },
    translate: function(t, e) {
      return t === 0 & e === 0 ? this : new Js(this.k, this.x + this.k * t, this.y + this.k * e);
    },
    apply: function(t) {
      return [
        t[0] * this.k + this.x,
        t[1] * this.k + this.y
      ];
    },
    applyX: function(t) {
      return t * this.k + this.x;
    },
    applyY: function(t) {
      return t * this.k + this.y;
    },
    invert: function(t) {
      return [
        (t[0] - this.x) / this.k,
        (t[1] - this.y) / this.k
      ];
    },
    invertX: function(t) {
      return (t - this.x) / this.k;
    },
    invertY: function(t) {
      return (t - this.y) / this.k;
    },
    rescaleX: function(t) {
      return t.copy().domain(t.range().map(this.invertX, this).map(t.invert, t));
    },
    rescaleY: function(t) {
      return t.copy().domain(t.range().map(this.invertY, this).map(t.invert, t));
    },
    toString: function() {
      return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
    }
  };
  Js.prototype;
  vL = v((t) => {
    var _a2;
    const { securityLevel: e } = Pt();
    let a = jt("body");
    if (e === "sandbox") {
      const o = ((_a2 = jt(`#i${t}`).node()) == null ? void 0 : _a2.contentDocument) ?? document;
      a = jt(o.body);
    }
    return a.select(`#${t}`);
  }, "selectSvgElement");
  function Eg(t) {
    return typeof t > "u" || t === null;
  }
  v(Eg, "isNothing");
  function K2(t) {
    return typeof t == "object" && t !== null;
  }
  v(K2, "isObject");
  function J2(t) {
    return Array.isArray(t) ? t : Eg(t) ? [] : [
      t
    ];
  }
  v(J2, "toArray");
  function tv(t, e) {
    var a, n, l, o;
    if (e) for (o = Object.keys(e), a = 0, n = o.length; a < n; a += 1) l = o[a], t[l] = e[l];
    return t;
  }
  v(tv, "extend");
  function ev(t, e) {
    var a = "", n;
    for (n = 0; n < e; n += 1) a += t;
    return a;
  }
  v(ev, "repeat");
  function iv(t) {
    return t === 0 && Number.NEGATIVE_INFINITY === 1 / t;
  }
  v(iv, "isNegativeZero");
  var _L = Eg, SL = K2, CL = J2, wL = ev, TL = iv, kL = tv, Ae = {
    isNothing: _L,
    isObject: SL,
    toArray: CL,
    repeat: wL,
    isNegativeZero: TL,
    extend: kL
  };
  function Mg(t, e) {
    var a = "", n = t.reason || "(unknown reason)";
    return t.mark ? (t.mark.name && (a += 'in "' + t.mark.name + '" '), a += "(" + (t.mark.line + 1) + ":" + (t.mark.column + 1) + ")", !e && t.mark.snippet && (a += `

` + t.mark.snippet), n + " " + a) : n;
  }
  v(Mg, "formatError");
  function wl(t, e) {
    Error.call(this), this.name = "YAMLException", this.reason = t, this.mark = e, this.message = Mg(this, false), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
  }
  v(wl, "YAMLException$1");
  wl.prototype = Object.create(Error.prototype);
  wl.prototype.constructor = wl;
  wl.prototype.toString = v(function(e) {
    return this.name + ": " + Mg(this, e);
  }, "toString");
  var pi = wl;
  function hu(t, e, a, n, l) {
    var o = "", h = "", u = Math.floor(l / 2) - 1;
    return n - e > u && (o = " ... ", e = n - u + o.length), a - n > u && (h = " ...", a = n + u - h.length), {
      str: o + t.slice(e, a).replace(/\t/g, "\u2192") + h,
      pos: n - e + o.length
    };
  }
  v(hu, "getLine");
  function fu(t, e) {
    return Ae.repeat(" ", e - t.length) + t;
  }
  v(fu, "padStart");
  function rv(t, e) {
    if (e = Object.create(e || null), !t.buffer) return null;
    e.maxLength || (e.maxLength = 79), typeof e.indent != "number" && (e.indent = 1), typeof e.linesBefore != "number" && (e.linesBefore = 3), typeof e.linesAfter != "number" && (e.linesAfter = 2);
    for (var a = /\r?\n|\r|\0/g, n = [
      0
    ], l = [], o, h = -1; o = a.exec(t.buffer); ) l.push(o.index), n.push(o.index + o[0].length), t.position <= o.index && h < 0 && (h = n.length - 2);
    h < 0 && (h = n.length - 1);
    var u = "", d, f, p = Math.min(t.line + e.linesAfter, l.length).toString().length, m = e.maxLength - (e.indent + p + 3);
    for (d = 1; d <= e.linesBefore && !(h - d < 0); d++) f = hu(t.buffer, n[h - d], l[h - d], t.position - (n[h] - n[h - d]), m), u = Ae.repeat(" ", e.indent) + fu((t.line - d + 1).toString(), p) + " | " + f.str + `
` + u;
    for (f = hu(t.buffer, n[h], l[h], t.position, m), u += Ae.repeat(" ", e.indent) + fu((t.line + 1).toString(), p) + " | " + f.str + `
`, u += Ae.repeat("-", e.indent + p + 3 + f.pos) + `^
`, d = 1; d <= e.linesAfter && !(h + d >= l.length); d++) f = hu(t.buffer, n[h + d], l[h + d], t.position - (n[h] - n[h + d]), m), u += Ae.repeat(" ", e.indent) + fu((t.line + d + 1).toString(), p) + " | " + f.str + `
`;
    return u.replace(/\n$/, "");
  }
  v(rv, "makeSnippet");
  var AL = rv, EL = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases"
  ], ML = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function av(t) {
    var e = {};
    return t !== null && Object.keys(t).forEach(function(a) {
      t[a].forEach(function(n) {
        e[String(n)] = a;
      });
    }), e;
  }
  v(av, "compileStyleAliases");
  function nv(t, e) {
    if (e = e || {}, Object.keys(e).forEach(function(a) {
      if (EL.indexOf(a) === -1) throw new pi('Unknown option "' + a + '" is met in definition of "' + t + '" YAML type.');
    }), this.options = e, this.tag = t, this.kind = e.kind || null, this.resolve = e.resolve || function() {
      return true;
    }, this.construct = e.construct || function(a) {
      return a;
    }, this.instanceOf = e.instanceOf || null, this.predicate = e.predicate || null, this.represent = e.represent || null, this.representName = e.representName || null, this.defaultStyle = e.defaultStyle || null, this.multi = e.multi || false, this.styleAliases = av(e.styleAliases || null), ML.indexOf(this.kind) === -1) throw new pi('Unknown kind "' + this.kind + '" is specified for "' + t + '" YAML type.');
  }
  v(nv, "Type$1");
  var Ve = nv;
  function kp(t, e) {
    var a = [];
    return t[e].forEach(function(n) {
      var l = a.length;
      a.forEach(function(o, h) {
        o.tag === n.tag && o.kind === n.kind && o.multi === n.multi && (l = h);
      }), a[l] = n;
    }), a;
  }
  v(kp, "compileList");
  function lv() {
    var t = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: {
        scalar: [],
        sequence: [],
        mapping: [],
        fallback: []
      }
    }, e, a;
    function n(l) {
      l.multi ? (t.multi[l.kind].push(l), t.multi.fallback.push(l)) : t[l.kind][l.tag] = t.fallback[l.tag] = l;
    }
    for (v(n, "collectType"), e = 0, a = arguments.length; e < a; e += 1) arguments[e].forEach(n);
    return t;
  }
  v(lv, "compileMap");
  function Ru(t) {
    return this.extend(t);
  }
  v(Ru, "Schema$1");
  Ru.prototype.extend = v(function(e) {
    var a = [], n = [];
    if (e instanceof Ve) n.push(e);
    else if (Array.isArray(e)) n = n.concat(e);
    else if (e && (Array.isArray(e.implicit) || Array.isArray(e.explicit))) e.implicit && (a = a.concat(e.implicit)), e.explicit && (n = n.concat(e.explicit));
    else throw new pi("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
    a.forEach(function(o) {
      if (!(o instanceof Ve)) throw new pi("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      if (o.loadKind && o.loadKind !== "scalar") throw new pi("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      if (o.multi) throw new pi("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }), n.forEach(function(o) {
      if (!(o instanceof Ve)) throw new pi("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    });
    var l = Object.create(Ru.prototype);
    return l.implicit = (this.implicit || []).concat(a), l.explicit = (this.explicit || []).concat(n), l.compiledImplicit = kp(l, "implicit"), l.compiledExplicit = kp(l, "explicit"), l.compiledTypeMap = lv(l.compiledImplicit, l.compiledExplicit), l;
  }, "extend");
  var BL = Ru, LL = new Ve("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: v(function(t) {
      return t !== null ? t : "";
    }, "construct")
  }), OL = new Ve("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: v(function(t) {
      return t !== null ? t : [];
    }, "construct")
  }), DL = new Ve("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: v(function(t) {
      return t !== null ? t : {};
    }, "construct")
  }), RL = new BL({
    explicit: [
      LL,
      OL,
      DL
    ]
  });
  function sv(t) {
    if (t === null) return true;
    var e = t.length;
    return e === 1 && t === "~" || e === 4 && (t === "null" || t === "Null" || t === "NULL");
  }
  v(sv, "resolveYamlNull");
  function ov() {
    return null;
  }
  v(ov, "constructYamlNull");
  function cv(t) {
    return t === null;
  }
  v(cv, "isNull");
  var $L = new Ve("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: sv,
    construct: ov,
    predicate: cv,
    represent: {
      canonical: v(function() {
        return "~";
      }, "canonical"),
      lowercase: v(function() {
        return "null";
      }, "lowercase"),
      uppercase: v(function() {
        return "NULL";
      }, "uppercase"),
      camelcase: v(function() {
        return "Null";
      }, "camelcase"),
      empty: v(function() {
        return "";
      }, "empty")
    },
    defaultStyle: "lowercase"
  });
  function uv(t) {
    if (t === null) return false;
    var e = t.length;
    return e === 4 && (t === "true" || t === "True" || t === "TRUE") || e === 5 && (t === "false" || t === "False" || t === "FALSE");
  }
  v(uv, "resolveYamlBoolean");
  function hv(t) {
    return t === "true" || t === "True" || t === "TRUE";
  }
  v(hv, "constructYamlBoolean");
  function fv(t) {
    return Object.prototype.toString.call(t) === "[object Boolean]";
  }
  v(fv, "isBoolean");
  var NL = new Ve("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: uv,
    construct: hv,
    predicate: fv,
    represent: {
      lowercase: v(function(t) {
        return t ? "true" : "false";
      }, "lowercase"),
      uppercase: v(function(t) {
        return t ? "TRUE" : "FALSE";
      }, "uppercase"),
      camelcase: v(function(t) {
        return t ? "True" : "False";
      }, "camelcase")
    },
    defaultStyle: "lowercase"
  });
  function dv(t) {
    return 48 <= t && t <= 57 || 65 <= t && t <= 70 || 97 <= t && t <= 102;
  }
  v(dv, "isHexCode");
  function pv(t) {
    return 48 <= t && t <= 55;
  }
  v(pv, "isOctCode");
  function gv(t) {
    return 48 <= t && t <= 57;
  }
  v(gv, "isDecCode");
  function mv(t) {
    if (t === null) return false;
    var e = t.length, a = 0, n = false, l;
    if (!e) return false;
    if (l = t[a], (l === "-" || l === "+") && (l = t[++a]), l === "0") {
      if (a + 1 === e) return true;
      if (l = t[++a], l === "b") {
        for (a++; a < e; a++) if (l = t[a], l !== "_") {
          if (l !== "0" && l !== "1") return false;
          n = true;
        }
        return n && l !== "_";
      }
      if (l === "x") {
        for (a++; a < e; a++) if (l = t[a], l !== "_") {
          if (!dv(t.charCodeAt(a))) return false;
          n = true;
        }
        return n && l !== "_";
      }
      if (l === "o") {
        for (a++; a < e; a++) if (l = t[a], l !== "_") {
          if (!pv(t.charCodeAt(a))) return false;
          n = true;
        }
        return n && l !== "_";
      }
    }
    if (l === "_") return false;
    for (; a < e; a++) if (l = t[a], l !== "_") {
      if (!gv(t.charCodeAt(a))) return false;
      n = true;
    }
    return !(!n || l === "_");
  }
  v(mv, "resolveYamlInteger");
  function yv(t) {
    var e = t, a = 1, n;
    if (e.indexOf("_") !== -1 && (e = e.replace(/_/g, "")), n = e[0], (n === "-" || n === "+") && (n === "-" && (a = -1), e = e.slice(1), n = e[0]), e === "0") return 0;
    if (n === "0") {
      if (e[1] === "b") return a * parseInt(e.slice(2), 2);
      if (e[1] === "x") return a * parseInt(e.slice(2), 16);
      if (e[1] === "o") return a * parseInt(e.slice(2), 8);
    }
    return a * parseInt(e, 10);
  }
  v(yv, "constructYamlInteger");
  function bv(t) {
    return Object.prototype.toString.call(t) === "[object Number]" && t % 1 === 0 && !Ae.isNegativeZero(t);
  }
  v(bv, "isInteger");
  var zL = new Ve("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: mv,
    construct: yv,
    predicate: bv,
    represent: {
      binary: v(function(t) {
        return t >= 0 ? "0b" + t.toString(2) : "-0b" + t.toString(2).slice(1);
      }, "binary"),
      octal: v(function(t) {
        return t >= 0 ? "0o" + t.toString(8) : "-0o" + t.toString(8).slice(1);
      }, "octal"),
      decimal: v(function(t) {
        return t.toString(10);
      }, "decimal"),
      hexadecimal: v(function(t) {
        return t >= 0 ? "0x" + t.toString(16).toUpperCase() : "-0x" + t.toString(16).toUpperCase().slice(1);
      }, "hexadecimal")
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [
        2,
        "bin"
      ],
      octal: [
        8,
        "oct"
      ],
      decimal: [
        10,
        "dec"
      ],
      hexadecimal: [
        16,
        "hex"
      ]
    }
  }), FL = new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
  function xv(t) {
    return !(t === null || !FL.test(t) || t[t.length - 1] === "_");
  }
  v(xv, "resolveYamlFloat");
  function vv(t) {
    var e, a;
    return e = t.replace(/_/g, "").toLowerCase(), a = e[0] === "-" ? -1 : 1, "+-".indexOf(e[0]) >= 0 && (e = e.slice(1)), e === ".inf" ? a === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : e === ".nan" ? NaN : a * parseFloat(e, 10);
  }
  v(vv, "constructYamlFloat");
  var qL = /^[-+]?[0-9]+e/;
  function _v(t, e) {
    var a;
    if (isNaN(t)) switch (e) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
    else if (Number.POSITIVE_INFINITY === t) switch (e) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
    else if (Number.NEGATIVE_INFINITY === t) switch (e) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
    else if (Ae.isNegativeZero(t)) return "-0.0";
    return a = t.toString(10), qL.test(a) ? a.replace("e", ".e") : a;
  }
  v(_v, "representYamlFloat");
  function Sv(t) {
    return Object.prototype.toString.call(t) === "[object Number]" && (t % 1 !== 0 || Ae.isNegativeZero(t));
  }
  v(Sv, "isFloat");
  var HL = new Ve("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: xv,
    construct: vv,
    predicate: Sv,
    represent: _v,
    defaultStyle: "lowercase"
  }), Cv = RL.extend({
    implicit: [
      $L,
      NL,
      zL,
      HL
    ]
  }), UL = Cv, wv = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"), Tv = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
  function kv(t) {
    return t === null ? false : wv.exec(t) !== null || Tv.exec(t) !== null;
  }
  v(kv, "resolveYamlTimestamp");
  function Av(t) {
    var e, a, n, l, o, h, u, d = 0, f = null, p, m, b;
    if (e = wv.exec(t), e === null && (e = Tv.exec(t)), e === null) throw new Error("Date resolve error");
    if (a = +e[1], n = +e[2] - 1, l = +e[3], !e[4]) return new Date(Date.UTC(a, n, l));
    if (o = +e[4], h = +e[5], u = +e[6], e[7]) {
      for (d = e[7].slice(0, 3); d.length < 3; ) d += "0";
      d = +d;
    }
    return e[9] && (p = +e[10], m = +(e[11] || 0), f = (p * 60 + m) * 6e4, e[9] === "-" && (f = -f)), b = new Date(Date.UTC(a, n, l, o, h, u, d)), f && b.setTime(b.getTime() - f), b;
  }
  v(Av, "constructYamlTimestamp");
  function Ev(t) {
    return t.toISOString();
  }
  v(Ev, "representYamlTimestamp");
  var jL = new Ve("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: kv,
    construct: Av,
    instanceOf: Date,
    represent: Ev
  });
  function Mv(t) {
    return t === "<<" || t === null;
  }
  v(Mv, "resolveYamlMerge");
  var YL = new Ve("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: Mv
  }), Bg = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
  function Bv(t) {
    if (t === null) return false;
    var e, a, n = 0, l = t.length, o = Bg;
    for (a = 0; a < l; a++) if (e = o.indexOf(t.charAt(a)), !(e > 64)) {
      if (e < 0) return false;
      n += 6;
    }
    return n % 8 === 0;
  }
  v(Bv, "resolveYamlBinary");
  function Lv(t) {
    var e, a, n = t.replace(/[\r\n=]/g, ""), l = n.length, o = Bg, h = 0, u = [];
    for (e = 0; e < l; e++) e % 4 === 0 && e && (u.push(h >> 16 & 255), u.push(h >> 8 & 255), u.push(h & 255)), h = h << 6 | o.indexOf(n.charAt(e));
    return a = l % 4 * 6, a === 0 ? (u.push(h >> 16 & 255), u.push(h >> 8 & 255), u.push(h & 255)) : a === 18 ? (u.push(h >> 10 & 255), u.push(h >> 2 & 255)) : a === 12 && u.push(h >> 4 & 255), new Uint8Array(u);
  }
  v(Lv, "constructYamlBinary");
  function Ov(t) {
    var e = "", a = 0, n, l, o = t.length, h = Bg;
    for (n = 0; n < o; n++) n % 3 === 0 && n && (e += h[a >> 18 & 63], e += h[a >> 12 & 63], e += h[a >> 6 & 63], e += h[a & 63]), a = (a << 8) + t[n];
    return l = o % 3, l === 0 ? (e += h[a >> 18 & 63], e += h[a >> 12 & 63], e += h[a >> 6 & 63], e += h[a & 63]) : l === 2 ? (e += h[a >> 10 & 63], e += h[a >> 4 & 63], e += h[a << 2 & 63], e += h[64]) : l === 1 && (e += h[a >> 2 & 63], e += h[a << 4 & 63], e += h[64], e += h[64]), e;
  }
  v(Ov, "representYamlBinary");
  function Dv(t) {
    return Object.prototype.toString.call(t) === "[object Uint8Array]";
  }
  v(Dv, "isBinary");
  var IL = new Ve("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: Bv,
    construct: Lv,
    predicate: Dv,
    represent: Ov
  }), PL = Object.prototype.hasOwnProperty, GL = Object.prototype.toString;
  function Rv(t) {
    if (t === null) return true;
    var e = [], a, n, l, o, h, u = t;
    for (a = 0, n = u.length; a < n; a += 1) {
      if (l = u[a], h = false, GL.call(l) !== "[object Object]") return false;
      for (o in l) if (PL.call(l, o)) if (!h) h = true;
      else return false;
      if (!h) return false;
      if (e.indexOf(o) === -1) e.push(o);
      else return false;
    }
    return true;
  }
  v(Rv, "resolveYamlOmap");
  function $v(t) {
    return t !== null ? t : [];
  }
  v($v, "constructYamlOmap");
  var WL = new Ve("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: Rv,
    construct: $v
  }), XL = Object.prototype.toString;
  function Nv(t) {
    if (t === null) return true;
    var e, a, n, l, o, h = t;
    for (o = new Array(h.length), e = 0, a = h.length; e < a; e += 1) {
      if (n = h[e], XL.call(n) !== "[object Object]" || (l = Object.keys(n), l.length !== 1)) return false;
      o[e] = [
        l[0],
        n[l[0]]
      ];
    }
    return true;
  }
  v(Nv, "resolveYamlPairs");
  function zv(t) {
    if (t === null) return [];
    var e, a, n, l, o, h = t;
    for (o = new Array(h.length), e = 0, a = h.length; e < a; e += 1) n = h[e], l = Object.keys(n), o[e] = [
      l[0],
      n[l[0]]
    ];
    return o;
  }
  v(zv, "constructYamlPairs");
  var VL = new Ve("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: Nv,
    construct: zv
  }), ZL = Object.prototype.hasOwnProperty;
  function Fv(t) {
    if (t === null) return true;
    var e, a = t;
    for (e in a) if (ZL.call(a, e) && a[e] !== null) return false;
    return true;
  }
  v(Fv, "resolveYamlSet");
  function qv(t) {
    return t !== null ? t : {};
  }
  v(qv, "constructYamlSet");
  var QL = new Ve("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: Fv,
    construct: qv
  }), Hv = UL.extend({
    implicit: [
      jL,
      YL
    ],
    explicit: [
      IL,
      WL,
      VL,
      QL
    ]
  }), La = Object.prototype.hasOwnProperty, $u = 1, Uv = 2, jv = 3, Nu = 4, Qd = 1, KL = 2, z1 = 3, JL = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, t5 = /[\x85\u2028\u2029]/, e5 = /[,\[\]\{\}]/, Yv = /^(?:!|!!|![a-z\-]+!)$/i, Iv = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function Ap(t) {
    return Object.prototype.toString.call(t);
  }
  v(Ap, "_class");
  function er(t) {
    return t === 10 || t === 13;
  }
  v(er, "is_EOL");
  function Ma(t) {
    return t === 9 || t === 32;
  }
  v(Ma, "is_WHITE_SPACE");
  function ei(t) {
    return t === 9 || t === 32 || t === 10 || t === 13;
  }
  v(ei, "is_WS_OR_EOL");
  function fn(t) {
    return t === 44 || t === 91 || t === 93 || t === 123 || t === 125;
  }
  v(fn, "is_FLOW_INDICATOR");
  function Pv(t) {
    var e;
    return 48 <= t && t <= 57 ? t - 48 : (e = t | 32, 97 <= e && e <= 102 ? e - 97 + 10 : -1);
  }
  v(Pv, "fromHexCode");
  function Gv(t) {
    return t === 120 ? 2 : t === 117 ? 4 : t === 85 ? 8 : 0;
  }
  v(Gv, "escapedHexLen");
  function Wv(t) {
    return 48 <= t && t <= 57 ? t - 48 : -1;
  }
  v(Wv, "fromDecimalCode");
  function Ep(t) {
    return t === 48 ? "\0" : t === 97 ? "\x07" : t === 98 ? "\b" : t === 116 || t === 9 ? "	" : t === 110 ? `
` : t === 118 ? "\v" : t === 102 ? "\f" : t === 114 ? "\r" : t === 101 ? "\x1B" : t === 32 ? " " : t === 34 ? '"' : t === 47 ? "/" : t === 92 ? "\\" : t === 78 ? "\x85" : t === 95 ? "\xA0" : t === 76 ? "\u2028" : t === 80 ? "\u2029" : "";
  }
  v(Ep, "simpleEscapeSequence");
  function Xv(t) {
    return t <= 65535 ? String.fromCharCode(t) : String.fromCharCode((t - 65536 >> 10) + 55296, (t - 65536 & 1023) + 56320);
  }
  v(Xv, "charFromCodepoint");
  var Vv = new Array(256), Zv = new Array(256);
  for (ln = 0; ln < 256; ln++) Vv[ln] = Ep(ln) ? 1 : 0, Zv[ln] = Ep(ln);
  var ln;
  function Qv(t, e) {
    this.input = t, this.filename = e.filename || null, this.schema = e.schema || Hv, this.onWarning = e.onWarning || null, this.legacy = e.legacy || false, this.json = e.json || false, this.listener = e.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = t.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
  }
  v(Qv, "State$1");
  function Lg(t, e) {
    var a = {
      name: t.filename,
      buffer: t.input.slice(0, -1),
      position: t.position,
      line: t.line,
      column: t.position - t.lineStart
    };
    return a.snippet = AL(a), new pi(e, a);
  }
  v(Lg, "generateError");
  function Ct(t, e) {
    throw Lg(t, e);
  }
  v(Ct, "throwError");
  function go(t, e) {
    t.onWarning && t.onWarning.call(null, Lg(t, e));
  }
  v(go, "throwWarning");
  var F1 = {
    YAML: v(function(e, a, n) {
      var l, o, h;
      e.version !== null && Ct(e, "duplication of %YAML directive"), n.length !== 1 && Ct(e, "YAML directive accepts exactly one argument"), l = /^([0-9]+)\.([0-9]+)$/.exec(n[0]), l === null && Ct(e, "ill-formed argument of the YAML directive"), o = parseInt(l[1], 10), h = parseInt(l[2], 10), o !== 1 && Ct(e, "unacceptable YAML version of the document"), e.version = n[0], e.checkLineBreaks = h < 2, h !== 1 && h !== 2 && go(e, "unsupported YAML version of the document");
    }, "handleYamlDirective"),
    TAG: v(function(e, a, n) {
      var l, o;
      n.length !== 2 && Ct(e, "TAG directive accepts exactly two arguments"), l = n[0], o = n[1], Yv.test(l) || Ct(e, "ill-formed tag handle (first argument) of the TAG directive"), La.call(e.tagMap, l) && Ct(e, 'there is a previously declared suffix for "' + l + '" tag handle'), Iv.test(o) || Ct(e, "ill-formed tag prefix (second argument) of the TAG directive");
      try {
        o = decodeURIComponent(o);
      } catch {
        Ct(e, "tag prefix is malformed: " + o);
      }
      e.tagMap[l] = o;
    }, "handleTagDirective")
  };
  function Vr(t, e, a, n) {
    var l, o, h, u;
    if (e < a) {
      if (u = t.input.slice(e, a), n) for (l = 0, o = u.length; l < o; l += 1) h = u.charCodeAt(l), h === 9 || 32 <= h && h <= 1114111 || Ct(t, "expected valid JSON character");
      else JL.test(u) && Ct(t, "the stream contains non-printable characters");
      t.result += u;
    }
  }
  v(Vr, "captureSegment");
  function Mp(t, e, a, n) {
    var l, o, h, u;
    for (Ae.isObject(a) || Ct(t, "cannot merge mappings; the provided source object is unacceptable"), l = Object.keys(a), h = 0, u = l.length; h < u; h += 1) o = l[h], La.call(e, o) || (e[o] = a[o], n[o] = true);
  }
  v(Mp, "mergeMappings");
  function dn(t, e, a, n, l, o, h, u, d) {
    var f, p;
    if (Array.isArray(l)) for (l = Array.prototype.slice.call(l), f = 0, p = l.length; f < p; f += 1) Array.isArray(l[f]) && Ct(t, "nested arrays are not supported inside keys"), typeof l == "object" && Ap(l[f]) === "[object Object]" && (l[f] = "[object Object]");
    if (typeof l == "object" && Ap(l) === "[object Object]" && (l = "[object Object]"), l = String(l), e === null && (e = {}), n === "tag:yaml.org,2002:merge") if (Array.isArray(o)) for (f = 0, p = o.length; f < p; f += 1) Mp(t, e, o[f], a);
    else Mp(t, e, o, a);
    else !t.json && !La.call(a, l) && La.call(e, l) && (t.line = h || t.line, t.lineStart = u || t.lineStart, t.position = d || t.position, Ct(t, "duplicated mapping key")), l === "__proto__" ? Object.defineProperty(e, l, {
      configurable: true,
      enumerable: true,
      writable: true,
      value: o
    }) : e[l] = o, delete a[l];
    return e;
  }
  v(dn, "storeMappingPair");
  function uh(t) {
    var e;
    e = t.input.charCodeAt(t.position), e === 10 ? t.position++ : e === 13 ? (t.position++, t.input.charCodeAt(t.position) === 10 && t.position++) : Ct(t, "a line break is expected"), t.line += 1, t.lineStart = t.position, t.firstTabInLine = -1;
  }
  v(uh, "readLineBreak");
  function ge(t, e, a) {
    for (var n = 0, l = t.input.charCodeAt(t.position); l !== 0; ) {
      for (; Ma(l); ) l === 9 && t.firstTabInLine === -1 && (t.firstTabInLine = t.position), l = t.input.charCodeAt(++t.position);
      if (e && l === 35) do
        l = t.input.charCodeAt(++t.position);
      while (l !== 10 && l !== 13 && l !== 0);
      if (er(l)) for (uh(t), l = t.input.charCodeAt(t.position), n++, t.lineIndent = 0; l === 32; ) t.lineIndent++, l = t.input.charCodeAt(++t.position);
      else break;
    }
    return a !== -1 && n !== 0 && t.lineIndent < a && go(t, "deficient indentation"), n;
  }
  v(ge, "skipSeparationSpace");
  function Eo(t) {
    var e = t.position, a;
    return a = t.input.charCodeAt(e), !!((a === 45 || a === 46) && a === t.input.charCodeAt(e + 1) && a === t.input.charCodeAt(e + 2) && (e += 3, a = t.input.charCodeAt(e), a === 0 || ei(a)));
  }
  v(Eo, "testDocumentSeparator");
  function hh(t, e) {
    e === 1 ? t.result += " " : e > 1 && (t.result += Ae.repeat(`
`, e - 1));
  }
  v(hh, "writeFoldedLines");
  function Kv(t, e, a) {
    var n, l, o, h, u, d, f, p, m = t.kind, b = t.result, x;
    if (x = t.input.charCodeAt(t.position), ei(x) || fn(x) || x === 35 || x === 38 || x === 42 || x === 33 || x === 124 || x === 62 || x === 39 || x === 34 || x === 37 || x === 64 || x === 96 || (x === 63 || x === 45) && (l = t.input.charCodeAt(t.position + 1), ei(l) || a && fn(l))) return false;
    for (t.kind = "scalar", t.result = "", o = h = t.position, u = false; x !== 0; ) {
      if (x === 58) {
        if (l = t.input.charCodeAt(t.position + 1), ei(l) || a && fn(l)) break;
      } else if (x === 35) {
        if (n = t.input.charCodeAt(t.position - 1), ei(n)) break;
      } else {
        if (t.position === t.lineStart && Eo(t) || a && fn(x)) break;
        if (er(x)) if (d = t.line, f = t.lineStart, p = t.lineIndent, ge(t, false, -1), t.lineIndent >= e) {
          u = true, x = t.input.charCodeAt(t.position);
          continue;
        } else {
          t.position = h, t.line = d, t.lineStart = f, t.lineIndent = p;
          break;
        }
      }
      u && (Vr(t, o, h, false), hh(t, t.line - d), o = h = t.position, u = false), Ma(x) || (h = t.position + 1), x = t.input.charCodeAt(++t.position);
    }
    return Vr(t, o, h, false), t.result ? true : (t.kind = m, t.result = b, false);
  }
  v(Kv, "readPlainScalar");
  function Jv(t, e) {
    var a, n, l;
    if (a = t.input.charCodeAt(t.position), a !== 39) return false;
    for (t.kind = "scalar", t.result = "", t.position++, n = l = t.position; (a = t.input.charCodeAt(t.position)) !== 0; ) if (a === 39) if (Vr(t, n, t.position, true), a = t.input.charCodeAt(++t.position), a === 39) n = t.position, t.position++, l = t.position;
    else return true;
    else er(a) ? (Vr(t, n, l, true), hh(t, ge(t, false, e)), n = l = t.position) : t.position === t.lineStart && Eo(t) ? Ct(t, "unexpected end of the document within a single quoted scalar") : (t.position++, l = t.position);
    Ct(t, "unexpected end of the stream within a single quoted scalar");
  }
  v(Jv, "readSingleQuotedScalar");
  function t_(t, e) {
    var a, n, l, o, h, u;
    if (u = t.input.charCodeAt(t.position), u !== 34) return false;
    for (t.kind = "scalar", t.result = "", t.position++, a = n = t.position; (u = t.input.charCodeAt(t.position)) !== 0; ) {
      if (u === 34) return Vr(t, a, t.position, true), t.position++, true;
      if (u === 92) {
        if (Vr(t, a, t.position, true), u = t.input.charCodeAt(++t.position), er(u)) ge(t, false, e);
        else if (u < 256 && Vv[u]) t.result += Zv[u], t.position++;
        else if ((h = Gv(u)) > 0) {
          for (l = h, o = 0; l > 0; l--) u = t.input.charCodeAt(++t.position), (h = Pv(u)) >= 0 ? o = (o << 4) + h : Ct(t, "expected hexadecimal character");
          t.result += Xv(o), t.position++;
        } else Ct(t, "unknown escape sequence");
        a = n = t.position;
      } else er(u) ? (Vr(t, a, n, true), hh(t, ge(t, false, e)), a = n = t.position) : t.position === t.lineStart && Eo(t) ? Ct(t, "unexpected end of the document within a double quoted scalar") : (t.position++, n = t.position);
    }
    Ct(t, "unexpected end of the stream within a double quoted scalar");
  }
  v(t_, "readDoubleQuotedScalar");
  function e_(t, e) {
    var a = true, n, l, o, h = t.tag, u, d = t.anchor, f, p, m, b, x, _ = /* @__PURE__ */ Object.create(null), S, w, k, A;
    if (A = t.input.charCodeAt(t.position), A === 91) p = 93, x = false, u = [];
    else if (A === 123) p = 125, x = true, u = {};
    else return false;
    for (t.anchor !== null && (t.anchorMap[t.anchor] = u), A = t.input.charCodeAt(++t.position); A !== 0; ) {
      if (ge(t, true, e), A = t.input.charCodeAt(t.position), A === p) return t.position++, t.tag = h, t.anchor = d, t.kind = x ? "mapping" : "sequence", t.result = u, true;
      a ? A === 44 && Ct(t, "expected the node content, but found ','") : Ct(t, "missed comma between flow collection entries"), w = S = k = null, m = b = false, A === 63 && (f = t.input.charCodeAt(t.position + 1), ei(f) && (m = b = true, t.position++, ge(t, true, e))), n = t.line, l = t.lineStart, o = t.position, xn(t, e, $u, false, true), w = t.tag, S = t.result, ge(t, true, e), A = t.input.charCodeAt(t.position), (b || t.line === n) && A === 58 && (m = true, A = t.input.charCodeAt(++t.position), ge(t, true, e), xn(t, e, $u, false, true), k = t.result), x ? dn(t, u, _, w, S, k, n, l, o) : m ? u.push(dn(t, null, _, w, S, k, n, l, o)) : u.push(S), ge(t, true, e), A = t.input.charCodeAt(t.position), A === 44 ? (a = true, A = t.input.charCodeAt(++t.position)) : a = false;
    }
    Ct(t, "unexpected end of the stream within a flow collection");
  }
  v(e_, "readFlowCollection");
  function i_(t, e) {
    var a, n, l = Qd, o = false, h = false, u = e, d = 0, f = false, p, m;
    if (m = t.input.charCodeAt(t.position), m === 124) n = false;
    else if (m === 62) n = true;
    else return false;
    for (t.kind = "scalar", t.result = ""; m !== 0; ) if (m = t.input.charCodeAt(++t.position), m === 43 || m === 45) Qd === l ? l = m === 43 ? z1 : KL : Ct(t, "repeat of a chomping mode identifier");
    else if ((p = Wv(m)) >= 0) p === 0 ? Ct(t, "bad explicit indentation width of a block scalar; it cannot be less than one") : h ? Ct(t, "repeat of an indentation width identifier") : (u = e + p - 1, h = true);
    else break;
    if (Ma(m)) {
      do
        m = t.input.charCodeAt(++t.position);
      while (Ma(m));
      if (m === 35) do
        m = t.input.charCodeAt(++t.position);
      while (!er(m) && m !== 0);
    }
    for (; m !== 0; ) {
      for (uh(t), t.lineIndent = 0, m = t.input.charCodeAt(t.position); (!h || t.lineIndent < u) && m === 32; ) t.lineIndent++, m = t.input.charCodeAt(++t.position);
      if (!h && t.lineIndent > u && (u = t.lineIndent), er(m)) {
        d++;
        continue;
      }
      if (t.lineIndent < u) {
        l === z1 ? t.result += Ae.repeat(`
`, o ? 1 + d : d) : l === Qd && o && (t.result += `
`);
        break;
      }
      for (n ? Ma(m) ? (f = true, t.result += Ae.repeat(`
`, o ? 1 + d : d)) : f ? (f = false, t.result += Ae.repeat(`
`, d + 1)) : d === 0 ? o && (t.result += " ") : t.result += Ae.repeat(`
`, d) : t.result += Ae.repeat(`
`, o ? 1 + d : d), o = true, h = true, d = 0, a = t.position; !er(m) && m !== 0; ) m = t.input.charCodeAt(++t.position);
      Vr(t, a, t.position, false);
    }
    return true;
  }
  v(i_, "readBlockScalar");
  function Bp(t, e) {
    var a, n = t.tag, l = t.anchor, o = [], h, u = false, d;
    if (t.firstTabInLine !== -1) return false;
    for (t.anchor !== null && (t.anchorMap[t.anchor] = o), d = t.input.charCodeAt(t.position); d !== 0 && (t.firstTabInLine !== -1 && (t.position = t.firstTabInLine, Ct(t, "tab characters must not be used in indentation")), !(d !== 45 || (h = t.input.charCodeAt(t.position + 1), !ei(h)))); ) {
      if (u = true, t.position++, ge(t, true, -1) && t.lineIndent <= e) {
        o.push(null), d = t.input.charCodeAt(t.position);
        continue;
      }
      if (a = t.line, xn(t, e, jv, false, true), o.push(t.result), ge(t, true, -1), d = t.input.charCodeAt(t.position), (t.line === a || t.lineIndent > e) && d !== 0) Ct(t, "bad indentation of a sequence entry");
      else if (t.lineIndent < e) break;
    }
    return u ? (t.tag = n, t.anchor = l, t.kind = "sequence", t.result = o, true) : false;
  }
  v(Bp, "readBlockSequence");
  function r_(t, e, a) {
    var n, l, o, h, u, d, f = t.tag, p = t.anchor, m = {}, b = /* @__PURE__ */ Object.create(null), x = null, _ = null, S = null, w = false, k = false, A;
    if (t.firstTabInLine !== -1) return false;
    for (t.anchor !== null && (t.anchorMap[t.anchor] = m), A = t.input.charCodeAt(t.position); A !== 0; ) {
      if (!w && t.firstTabInLine !== -1 && (t.position = t.firstTabInLine, Ct(t, "tab characters must not be used in indentation")), n = t.input.charCodeAt(t.position + 1), o = t.line, (A === 63 || A === 58) && ei(n)) A === 63 ? (w && (dn(t, m, b, x, _, null, h, u, d), x = _ = S = null), k = true, w = true, l = true) : w ? (w = false, l = true) : Ct(t, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), t.position += 1, A = n;
      else {
        if (h = t.line, u = t.lineStart, d = t.position, !xn(t, a, Uv, false, true)) break;
        if (t.line === o) {
          for (A = t.input.charCodeAt(t.position); Ma(A); ) A = t.input.charCodeAt(++t.position);
          if (A === 58) A = t.input.charCodeAt(++t.position), ei(A) || Ct(t, "a whitespace character is expected after the key-value separator within a block mapping"), w && (dn(t, m, b, x, _, null, h, u, d), x = _ = S = null), k = true, w = false, l = false, x = t.tag, _ = t.result;
          else if (k) Ct(t, "can not read an implicit mapping pair; a colon is missed");
          else return t.tag = f, t.anchor = p, true;
        } else if (k) Ct(t, "can not read a block mapping entry; a multiline key may not be an implicit key");
        else return t.tag = f, t.anchor = p, true;
      }
      if ((t.line === o || t.lineIndent > e) && (w && (h = t.line, u = t.lineStart, d = t.position), xn(t, e, Nu, true, l) && (w ? _ = t.result : S = t.result), w || (dn(t, m, b, x, _, S, h, u, d), x = _ = S = null), ge(t, true, -1), A = t.input.charCodeAt(t.position)), (t.line === o || t.lineIndent > e) && A !== 0) Ct(t, "bad indentation of a mapping entry");
      else if (t.lineIndent < e) break;
    }
    return w && dn(t, m, b, x, _, null, h, u, d), k && (t.tag = f, t.anchor = p, t.kind = "mapping", t.result = m), k;
  }
  v(r_, "readBlockMapping");
  function a_(t) {
    var e, a = false, n = false, l, o, h;
    if (h = t.input.charCodeAt(t.position), h !== 33) return false;
    if (t.tag !== null && Ct(t, "duplication of a tag property"), h = t.input.charCodeAt(++t.position), h === 60 ? (a = true, h = t.input.charCodeAt(++t.position)) : h === 33 ? (n = true, l = "!!", h = t.input.charCodeAt(++t.position)) : l = "!", e = t.position, a) {
      do
        h = t.input.charCodeAt(++t.position);
      while (h !== 0 && h !== 62);
      t.position < t.length ? (o = t.input.slice(e, t.position), h = t.input.charCodeAt(++t.position)) : Ct(t, "unexpected end of the stream within a verbatim tag");
    } else {
      for (; h !== 0 && !ei(h); ) h === 33 && (n ? Ct(t, "tag suffix cannot contain exclamation marks") : (l = t.input.slice(e - 1, t.position + 1), Yv.test(l) || Ct(t, "named tag handle cannot contain such characters"), n = true, e = t.position + 1)), h = t.input.charCodeAt(++t.position);
      o = t.input.slice(e, t.position), e5.test(o) && Ct(t, "tag suffix cannot contain flow indicator characters");
    }
    o && !Iv.test(o) && Ct(t, "tag name cannot contain such characters: " + o);
    try {
      o = decodeURIComponent(o);
    } catch {
      Ct(t, "tag name is malformed: " + o);
    }
    return a ? t.tag = o : La.call(t.tagMap, l) ? t.tag = t.tagMap[l] + o : l === "!" ? t.tag = "!" + o : l === "!!" ? t.tag = "tag:yaml.org,2002:" + o : Ct(t, 'undeclared tag handle "' + l + '"'), true;
  }
  v(a_, "readTagProperty");
  function n_(t) {
    var e, a;
    if (a = t.input.charCodeAt(t.position), a !== 38) return false;
    for (t.anchor !== null && Ct(t, "duplication of an anchor property"), a = t.input.charCodeAt(++t.position), e = t.position; a !== 0 && !ei(a) && !fn(a); ) a = t.input.charCodeAt(++t.position);
    return t.position === e && Ct(t, "name of an anchor node must contain at least one character"), t.anchor = t.input.slice(e, t.position), true;
  }
  v(n_, "readAnchorProperty");
  function l_(t) {
    var e, a, n;
    if (n = t.input.charCodeAt(t.position), n !== 42) return false;
    for (n = t.input.charCodeAt(++t.position), e = t.position; n !== 0 && !ei(n) && !fn(n); ) n = t.input.charCodeAt(++t.position);
    return t.position === e && Ct(t, "name of an alias node must contain at least one character"), a = t.input.slice(e, t.position), La.call(t.anchorMap, a) || Ct(t, 'unidentified alias "' + a + '"'), t.result = t.anchorMap[a], ge(t, true, -1), true;
  }
  v(l_, "readAlias");
  function xn(t, e, a, n, l) {
    var o, h, u, d = 1, f = false, p = false, m, b, x, _, S, w;
    if (t.listener !== null && t.listener("open", t), t.tag = null, t.anchor = null, t.kind = null, t.result = null, o = h = u = Nu === a || jv === a, n && ge(t, true, -1) && (f = true, t.lineIndent > e ? d = 1 : t.lineIndent === e ? d = 0 : t.lineIndent < e && (d = -1)), d === 1) for (; a_(t) || n_(t); ) ge(t, true, -1) ? (f = true, u = o, t.lineIndent > e ? d = 1 : t.lineIndent === e ? d = 0 : t.lineIndent < e && (d = -1)) : u = false;
    if (u && (u = f || l), (d === 1 || Nu === a) && ($u === a || Uv === a ? S = e : S = e + 1, w = t.position - t.lineStart, d === 1 ? u && (Bp(t, w) || r_(t, w, S)) || e_(t, S) ? p = true : (h && i_(t, S) || Jv(t, S) || t_(t, S) ? p = true : l_(t) ? (p = true, (t.tag !== null || t.anchor !== null) && Ct(t, "alias node should not have any properties")) : Kv(t, S, $u === a) && (p = true, t.tag === null && (t.tag = "?")), t.anchor !== null && (t.anchorMap[t.anchor] = t.result)) : d === 0 && (p = u && Bp(t, w))), t.tag === null) t.anchor !== null && (t.anchorMap[t.anchor] = t.result);
    else if (t.tag === "?") {
      for (t.result !== null && t.kind !== "scalar" && Ct(t, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + t.kind + '"'), m = 0, b = t.implicitTypes.length; m < b; m += 1) if (_ = t.implicitTypes[m], _.resolve(t.result)) {
        t.result = _.construct(t.result), t.tag = _.tag, t.anchor !== null && (t.anchorMap[t.anchor] = t.result);
        break;
      }
    } else if (t.tag !== "!") {
      if (La.call(t.typeMap[t.kind || "fallback"], t.tag)) _ = t.typeMap[t.kind || "fallback"][t.tag];
      else for (_ = null, x = t.typeMap.multi[t.kind || "fallback"], m = 0, b = x.length; m < b; m += 1) if (t.tag.slice(0, x[m].tag.length) === x[m].tag) {
        _ = x[m];
        break;
      }
      _ || Ct(t, "unknown tag !<" + t.tag + ">"), t.result !== null && _.kind !== t.kind && Ct(t, "unacceptable node kind for !<" + t.tag + '> tag; it should be "' + _.kind + '", not "' + t.kind + '"'), _.resolve(t.result, t.tag) ? (t.result = _.construct(t.result, t.tag), t.anchor !== null && (t.anchorMap[t.anchor] = t.result)) : Ct(t, "cannot resolve a node with !<" + t.tag + "> explicit tag");
    }
    return t.listener !== null && t.listener("close", t), t.tag !== null || t.anchor !== null || p;
  }
  v(xn, "composeNode");
  function s_(t) {
    var e = t.position, a, n, l, o = false, h;
    for (t.version = null, t.checkLineBreaks = t.legacy, t.tagMap = /* @__PURE__ */ Object.create(null), t.anchorMap = /* @__PURE__ */ Object.create(null); (h = t.input.charCodeAt(t.position)) !== 0 && (ge(t, true, -1), h = t.input.charCodeAt(t.position), !(t.lineIndent > 0 || h !== 37)); ) {
      for (o = true, h = t.input.charCodeAt(++t.position), a = t.position; h !== 0 && !ei(h); ) h = t.input.charCodeAt(++t.position);
      for (n = t.input.slice(a, t.position), l = [], n.length < 1 && Ct(t, "directive name must not be less than one character in length"); h !== 0; ) {
        for (; Ma(h); ) h = t.input.charCodeAt(++t.position);
        if (h === 35) {
          do
            h = t.input.charCodeAt(++t.position);
          while (h !== 0 && !er(h));
          break;
        }
        if (er(h)) break;
        for (a = t.position; h !== 0 && !ei(h); ) h = t.input.charCodeAt(++t.position);
        l.push(t.input.slice(a, t.position));
      }
      h !== 0 && uh(t), La.call(F1, n) ? F1[n](t, n, l) : go(t, 'unknown document directive "' + n + '"');
    }
    if (ge(t, true, -1), t.lineIndent === 0 && t.input.charCodeAt(t.position) === 45 && t.input.charCodeAt(t.position + 1) === 45 && t.input.charCodeAt(t.position + 2) === 45 ? (t.position += 3, ge(t, true, -1)) : o && Ct(t, "directives end mark is expected"), xn(t, t.lineIndent - 1, Nu, false, true), ge(t, true, -1), t.checkLineBreaks && t5.test(t.input.slice(e, t.position)) && go(t, "non-ASCII line breaks are interpreted as content"), t.documents.push(t.result), t.position === t.lineStart && Eo(t)) {
      t.input.charCodeAt(t.position) === 46 && (t.position += 3, ge(t, true, -1));
      return;
    }
    if (t.position < t.length - 1) Ct(t, "end of the stream or a document separator is expected");
    else return;
  }
  v(s_, "readDocument");
  function Og(t, e) {
    t = String(t), e = e || {}, t.length !== 0 && (t.charCodeAt(t.length - 1) !== 10 && t.charCodeAt(t.length - 1) !== 13 && (t += `
`), t.charCodeAt(0) === 65279 && (t = t.slice(1)));
    var a = new Qv(t, e), n = t.indexOf("\0");
    for (n !== -1 && (a.position = n, Ct(a, "null byte is not allowed in input")), a.input += "\0"; a.input.charCodeAt(a.position) === 32; ) a.lineIndent += 1, a.position += 1;
    for (; a.position < a.length - 1; ) s_(a);
    return a.documents;
  }
  v(Og, "loadDocuments");
  function i5(t, e, a) {
    e !== null && typeof e == "object" && typeof a > "u" && (a = e, e = null);
    var n = Og(t, a);
    if (typeof e != "function") return n;
    for (var l = 0, o = n.length; l < o; l += 1) e(n[l]);
  }
  v(i5, "loadAll$1");
  function o_(t, e) {
    var a = Og(t, e);
    if (a.length !== 0) {
      if (a.length === 1) return a[0];
      throw new pi("expected a single document in the stream, but found more");
    }
  }
  v(o_, "load$1");
  var r5 = o_, a5 = {
    load: r5
  }, c_ = Object.prototype.toString, u_ = Object.prototype.hasOwnProperty, Dg = 65279, n5 = 9, mo = 10, l5 = 13, s5 = 32, o5 = 33, c5 = 34, Lp = 35, u5 = 37, h5 = 38, f5 = 39, d5 = 42, h_ = 44, p5 = 45, zu = 58, g5 = 61, m5 = 62, y5 = 63, b5 = 64, f_ = 91, d_ = 93, x5 = 96, p_ = 123, v5 = 124, g_ = 125, Qe = {};
  Qe[0] = "\\0";
  Qe[7] = "\\a";
  Qe[8] = "\\b";
  Qe[9] = "\\t";
  Qe[10] = "\\n";
  Qe[11] = "\\v";
  Qe[12] = "\\f";
  Qe[13] = "\\r";
  Qe[27] = "\\e";
  Qe[34] = '\\"';
  Qe[92] = "\\\\";
  Qe[133] = "\\N";
  Qe[160] = "\\_";
  Qe[8232] = "\\L";
  Qe[8233] = "\\P";
  var _5 = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ], S5 = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
  function m_(t, e) {
    var a, n, l, o, h, u, d;
    if (e === null) return {};
    for (a = {}, n = Object.keys(e), l = 0, o = n.length; l < o; l += 1) h = n[l], u = String(e[h]), h.slice(0, 2) === "!!" && (h = "tag:yaml.org,2002:" + h.slice(2)), d = t.compiledTypeMap.fallback[h], d && u_.call(d.styleAliases, u) && (u = d.styleAliases[u]), a[h] = u;
    return a;
  }
  v(m_, "compileStyleMap");
  function y_(t) {
    var e, a, n;
    if (e = t.toString(16).toUpperCase(), t <= 255) a = "x", n = 2;
    else if (t <= 65535) a = "u", n = 4;
    else if (t <= 4294967295) a = "U", n = 8;
    else throw new pi("code point within a string may not be greater than 0xFFFFFFFF");
    return "\\" + a + Ae.repeat("0", n - e.length) + e;
  }
  v(y_, "encodeHex");
  var C5 = 1, yo = 2;
  function b_(t) {
    this.schema = t.schema || Hv, this.indent = Math.max(1, t.indent || 2), this.noArrayIndent = t.noArrayIndent || false, this.skipInvalid = t.skipInvalid || false, this.flowLevel = Ae.isNothing(t.flowLevel) ? -1 : t.flowLevel, this.styleMap = m_(this.schema, t.styles || null), this.sortKeys = t.sortKeys || false, this.lineWidth = t.lineWidth || 80, this.noRefs = t.noRefs || false, this.noCompatMode = t.noCompatMode || false, this.condenseFlow = t.condenseFlow || false, this.quotingType = t.quotingType === '"' ? yo : C5, this.forceQuotes = t.forceQuotes || false, this.replacer = typeof t.replacer == "function" ? t.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
  }
  v(b_, "State");
  function Op(t, e) {
    for (var a = Ae.repeat(" ", e), n = 0, l = -1, o = "", h, u = t.length; n < u; ) l = t.indexOf(`
`, n), l === -1 ? (h = t.slice(n), n = u) : (h = t.slice(n, l + 1), n = l + 1), h.length && h !== `
` && (o += a), o += h;
    return o;
  }
  v(Op, "indentString");
  function Fu(t, e) {
    return `
` + Ae.repeat(" ", t.indent * e);
  }
  v(Fu, "generateNextLine");
  function x_(t, e) {
    var a, n, l;
    for (a = 0, n = t.implicitTypes.length; a < n; a += 1) if (l = t.implicitTypes[a], l.resolve(e)) return true;
    return false;
  }
  v(x_, "testImplicitResolving");
  function bo(t) {
    return t === s5 || t === n5;
  }
  v(bo, "isWhitespace");
  function Tl(t) {
    return 32 <= t && t <= 126 || 161 <= t && t <= 55295 && t !== 8232 && t !== 8233 || 57344 <= t && t <= 65533 && t !== Dg || 65536 <= t && t <= 1114111;
  }
  v(Tl, "isPrintable");
  function Dp(t) {
    return Tl(t) && t !== Dg && t !== l5 && t !== mo;
  }
  v(Dp, "isNsCharOrWhitespace");
  function Rp(t, e, a) {
    var n = Dp(t), l = n && !bo(t);
    return (a ? n : n && t !== h_ && t !== f_ && t !== d_ && t !== p_ && t !== g_) && t !== Lp && !(e === zu && !l) || Dp(e) && !bo(e) && t === Lp || e === zu && l;
  }
  v(Rp, "isPlainSafe");
  function v_(t) {
    return Tl(t) && t !== Dg && !bo(t) && t !== p5 && t !== y5 && t !== zu && t !== h_ && t !== f_ && t !== d_ && t !== p_ && t !== g_ && t !== Lp && t !== h5 && t !== d5 && t !== o5 && t !== v5 && t !== g5 && t !== m5 && t !== f5 && t !== c5 && t !== u5 && t !== b5 && t !== x5;
  }
  v(v_, "isPlainSafeFirst");
  function __(t) {
    return !bo(t) && t !== zu;
  }
  v(__, "isPlainSafeLast");
  function gl(t, e) {
    var a = t.charCodeAt(e), n;
    return a >= 55296 && a <= 56319 && e + 1 < t.length && (n = t.charCodeAt(e + 1), n >= 56320 && n <= 57343) ? (a - 55296) * 1024 + n - 56320 + 65536 : a;
  }
  v(gl, "codePointAt");
  function Rg(t) {
    var e = /^\n* /;
    return e.test(t);
  }
  v(Rg, "needIndentIndicator");
  var S_ = 1, $p = 2, C_ = 3, w_ = 4, dl = 5;
  function T_(t, e, a, n, l, o, h, u) {
    var d, f = 0, p = null, m = false, b = false, x = n !== -1, _ = -1, S = v_(gl(t, 0)) && __(gl(t, t.length - 1));
    if (e || h) for (d = 0; d < t.length; f >= 65536 ? d += 2 : d++) {
      if (f = gl(t, d), !Tl(f)) return dl;
      S = S && Rp(f, p, u), p = f;
    }
    else {
      for (d = 0; d < t.length; f >= 65536 ? d += 2 : d++) {
        if (f = gl(t, d), f === mo) m = true, x && (b = b || d - _ - 1 > n && t[_ + 1] !== " ", _ = d);
        else if (!Tl(f)) return dl;
        S = S && Rp(f, p, u), p = f;
      }
      b = b || x && d - _ - 1 > n && t[_ + 1] !== " ";
    }
    return !m && !b ? S && !h && !l(t) ? S_ : o === yo ? dl : $p : a > 9 && Rg(t) ? dl : h ? o === yo ? dl : $p : b ? w_ : C_;
  }
  v(T_, "chooseScalarStyle");
  function k_(t, e, a, n, l) {
    t.dump = (function() {
      if (e.length === 0) return t.quotingType === yo ? '""' : "''";
      if (!t.noCompatMode && (_5.indexOf(e) !== -1 || S5.test(e))) return t.quotingType === yo ? '"' + e + '"' : "'" + e + "'";
      var o = t.indent * Math.max(1, a), h = t.lineWidth === -1 ? -1 : Math.max(Math.min(t.lineWidth, 40), t.lineWidth - o), u = n || t.flowLevel > -1 && a >= t.flowLevel;
      function d(f) {
        return x_(t, f);
      }
      switch (v(d, "testAmbiguity"), T_(e, u, t.indent, h, d, t.quotingType, t.forceQuotes && !n, l)) {
        case S_:
          return e;
        case $p:
          return "'" + e.replace(/'/g, "''") + "'";
        case C_:
          return "|" + Np(e, t.indent) + zp(Op(e, o));
        case w_:
          return ">" + Np(e, t.indent) + zp(Op(A_(e, h), o));
        case dl:
          return '"' + E_(e) + '"';
        default:
          throw new pi("impossible error: invalid scalar style");
      }
    })();
  }
  v(k_, "writeScalar");
  function Np(t, e) {
    var a = Rg(t) ? String(e) : "", n = t[t.length - 1] === `
`, l = n && (t[t.length - 2] === `
` || t === `
`), o = l ? "+" : n ? "" : "-";
    return a + o + `
`;
  }
  v(Np, "blockHeader");
  function zp(t) {
    return t[t.length - 1] === `
` ? t.slice(0, -1) : t;
  }
  v(zp, "dropEndingNewline");
  function A_(t, e) {
    for (var a = /(\n+)([^\n]*)/g, n = (function() {
      var f = t.indexOf(`
`);
      return f = f !== -1 ? f : t.length, a.lastIndex = f, Fp(t.slice(0, f), e);
    })(), l = t[0] === `
` || t[0] === " ", o, h; h = a.exec(t); ) {
      var u = h[1], d = h[2];
      o = d[0] === " ", n += u + (!l && !o && d !== "" ? `
` : "") + Fp(d, e), l = o;
    }
    return n;
  }
  v(A_, "foldString");
  function Fp(t, e) {
    if (t === "" || t[0] === " ") return t;
    for (var a = / [^ ]/g, n, l = 0, o, h = 0, u = 0, d = ""; n = a.exec(t); ) u = n.index, u - l > e && (o = h > l ? h : u, d += `
` + t.slice(l, o), l = o + 1), h = u;
    return d += `
`, t.length - l > e && h > l ? d += t.slice(l, h) + `
` + t.slice(h + 1) : d += t.slice(l), d.slice(1);
  }
  v(Fp, "foldLine");
  function E_(t) {
    for (var e = "", a = 0, n, l = 0; l < t.length; a >= 65536 ? l += 2 : l++) a = gl(t, l), n = Qe[a], !n && Tl(a) ? (e += t[l], a >= 65536 && (e += t[l + 1])) : e += n || y_(a);
    return e;
  }
  v(E_, "escapeString");
  function M_(t, e, a) {
    var n = "", l = t.tag, o, h, u;
    for (o = 0, h = a.length; o < h; o += 1) u = a[o], t.replacer && (u = t.replacer.call(a, String(o), u)), (br(t, e, u, false, false) || typeof u > "u" && br(t, e, null, false, false)) && (n !== "" && (n += "," + (t.condenseFlow ? "" : " ")), n += t.dump);
    t.tag = l, t.dump = "[" + n + "]";
  }
  v(M_, "writeFlowSequence");
  function qp(t, e, a, n) {
    var l = "", o = t.tag, h, u, d;
    for (h = 0, u = a.length; h < u; h += 1) d = a[h], t.replacer && (d = t.replacer.call(a, String(h), d)), (br(t, e + 1, d, true, true, false, true) || typeof d > "u" && br(t, e + 1, null, true, true, false, true)) && ((!n || l !== "") && (l += Fu(t, e)), t.dump && mo === t.dump.charCodeAt(0) ? l += "-" : l += "- ", l += t.dump);
    t.tag = o, t.dump = l || "[]";
  }
  v(qp, "writeBlockSequence");
  function B_(t, e, a) {
    var n = "", l = t.tag, o = Object.keys(a), h, u, d, f, p;
    for (h = 0, u = o.length; h < u; h += 1) p = "", n !== "" && (p += ", "), t.condenseFlow && (p += '"'), d = o[h], f = a[d], t.replacer && (f = t.replacer.call(a, d, f)), br(t, e, d, false, false) && (t.dump.length > 1024 && (p += "? "), p += t.dump + (t.condenseFlow ? '"' : "") + ":" + (t.condenseFlow ? "" : " "), br(t, e, f, false, false) && (p += t.dump, n += p));
    t.tag = l, t.dump = "{" + n + "}";
  }
  v(B_, "writeFlowMapping");
  function L_(t, e, a, n) {
    var l = "", o = t.tag, h = Object.keys(a), u, d, f, p, m, b;
    if (t.sortKeys === true) h.sort();
    else if (typeof t.sortKeys == "function") h.sort(t.sortKeys);
    else if (t.sortKeys) throw new pi("sortKeys must be a boolean or a function");
    for (u = 0, d = h.length; u < d; u += 1) b = "", (!n || l !== "") && (b += Fu(t, e)), f = h[u], p = a[f], t.replacer && (p = t.replacer.call(a, f, p)), br(t, e + 1, f, true, true, true) && (m = t.tag !== null && t.tag !== "?" || t.dump && t.dump.length > 1024, m && (t.dump && mo === t.dump.charCodeAt(0) ? b += "?" : b += "? "), b += t.dump, m && (b += Fu(t, e)), br(t, e + 1, p, true, m) && (t.dump && mo === t.dump.charCodeAt(0) ? b += ":" : b += ": ", b += t.dump, l += b));
    t.tag = o, t.dump = l || "{}";
  }
  v(L_, "writeBlockMapping");
  function Hp(t, e, a) {
    var n, l, o, h, u, d;
    for (l = a ? t.explicitTypes : t.implicitTypes, o = 0, h = l.length; o < h; o += 1) if (u = l[o], (u.instanceOf || u.predicate) && (!u.instanceOf || typeof e == "object" && e instanceof u.instanceOf) && (!u.predicate || u.predicate(e))) {
      if (a ? u.multi && u.representName ? t.tag = u.representName(e) : t.tag = u.tag : t.tag = "?", u.represent) {
        if (d = t.styleMap[u.tag] || u.defaultStyle, c_.call(u.represent) === "[object Function]") n = u.represent(e, d);
        else if (u_.call(u.represent, d)) n = u.represent[d](e, d);
        else throw new pi("!<" + u.tag + '> tag resolver accepts not "' + d + '" style');
        t.dump = n;
      }
      return true;
    }
    return false;
  }
  v(Hp, "detectType");
  function br(t, e, a, n, l, o, h) {
    t.tag = null, t.dump = a, Hp(t, a, false) || Hp(t, a, true);
    var u = c_.call(t.dump), d = n, f;
    n && (n = t.flowLevel < 0 || t.flowLevel > e);
    var p = u === "[object Object]" || u === "[object Array]", m, b;
    if (p && (m = t.duplicates.indexOf(a), b = m !== -1), (t.tag !== null && t.tag !== "?" || b || t.indent !== 2 && e > 0) && (l = false), b && t.usedDuplicates[m]) t.dump = "*ref_" + m;
    else {
      if (p && b && !t.usedDuplicates[m] && (t.usedDuplicates[m] = true), u === "[object Object]") n && Object.keys(t.dump).length !== 0 ? (L_(t, e, t.dump, l), b && (t.dump = "&ref_" + m + t.dump)) : (B_(t, e, t.dump), b && (t.dump = "&ref_" + m + " " + t.dump));
      else if (u === "[object Array]") n && t.dump.length !== 0 ? (t.noArrayIndent && !h && e > 0 ? qp(t, e - 1, t.dump, l) : qp(t, e, t.dump, l), b && (t.dump = "&ref_" + m + t.dump)) : (M_(t, e, t.dump), b && (t.dump = "&ref_" + m + " " + t.dump));
      else if (u === "[object String]") t.tag !== "?" && k_(t, t.dump, e, o, d);
      else {
        if (u === "[object Undefined]") return false;
        if (t.skipInvalid) return false;
        throw new pi("unacceptable kind of an object to dump " + u);
      }
      t.tag !== null && t.tag !== "?" && (f = encodeURI(t.tag[0] === "!" ? t.tag.slice(1) : t.tag).replace(/!/g, "%21"), t.tag[0] === "!" ? f = "!" + f : f.slice(0, 18) === "tag:yaml.org,2002:" ? f = "!!" + f.slice(18) : f = "!<" + f + ">", t.dump = f + " " + t.dump);
    }
    return true;
  }
  v(br, "writeNode");
  function O_(t, e) {
    var a = [], n = [], l, o;
    for (qu(t, a, n), l = 0, o = n.length; l < o; l += 1) e.duplicates.push(a[n[l]]);
    e.usedDuplicates = new Array(o);
  }
  v(O_, "getDuplicateReferences");
  function qu(t, e, a) {
    var n, l, o;
    if (t !== null && typeof t == "object") if (l = e.indexOf(t), l !== -1) a.indexOf(l) === -1 && a.push(l);
    else if (e.push(t), Array.isArray(t)) for (l = 0, o = t.length; l < o; l += 1) qu(t[l], e, a);
    else for (n = Object.keys(t), l = 0, o = n.length; l < o; l += 1) qu(t[n[l]], e, a);
  }
  v(qu, "inspectNode");
  function w5(t, e) {
    e = e || {};
    var a = new b_(e);
    a.noRefs || O_(t, a);
    var n = t;
    return a.replacer && (n = a.replacer.call({
      "": n
    }, "", n)), br(a, 0, n, true, true) ? a.dump + `
` : "";
  }
  v(w5, "dump$1");
  function T5(t, e) {
    return function() {
      throw new Error("Function yaml." + t + " is removed in js-yaml 4. Use yaml." + e + " instead, which is now safe by default.");
    };
  }
  v(T5, "renamed");
  k5 = Cv;
  A5 = a5.load;
  var Hi = {
    aggregation: 18,
    extension: 18,
    composition: 18,
    dependency: 6,
    lollipop: 13.5,
    arrow_point: 4
  };
  function to(t, e) {
    if (t === void 0 || e === void 0) return {
      angle: 0,
      deltaX: 0,
      deltaY: 0
    };
    t = le(t), e = le(e);
    const [a, n] = [
      t.x,
      t.y
    ], [l, o] = [
      e.x,
      e.y
    ], h = l - a, u = o - n;
    return {
      angle: Math.atan(u / h),
      deltaX: h,
      deltaY: u
    };
  }
  v(to, "calculateDeltaAndAngle");
  let le, M5, Ml, B5, bt, L5, Ys, Te, q1;
  le = v((t) => Array.isArray(t) ? {
    x: t[0],
    y: t[1]
  } : t, "pointTransformer");
  E5 = v((t) => ({
    x: v(function(e, a, n) {
      let l = 0;
      const o = le(n[0]).x < le(n[n.length - 1]).x ? "left" : "right";
      if (a === 0 && Object.hasOwn(Hi, t.arrowTypeStart)) {
        const { angle: x, deltaX: _ } = to(n[0], n[1]);
        l = Hi[t.arrowTypeStart] * Math.cos(x) * (_ >= 0 ? 1 : -1);
      } else if (a === n.length - 1 && Object.hasOwn(Hi, t.arrowTypeEnd)) {
        const { angle: x, deltaX: _ } = to(n[n.length - 1], n[n.length - 2]);
        l = Hi[t.arrowTypeEnd] * Math.cos(x) * (_ >= 0 ? 1 : -1);
      }
      const h = Math.abs(le(e).x - le(n[n.length - 1]).x), u = Math.abs(le(e).y - le(n[n.length - 1]).y), d = Math.abs(le(e).x - le(n[0]).x), f = Math.abs(le(e).y - le(n[0]).y), p = Hi[t.arrowTypeStart], m = Hi[t.arrowTypeEnd], b = 1;
      if (h < m && h > 0 && u < m) {
        let x = m + b - h;
        x *= o === "right" ? -1 : 1, l -= x;
      }
      if (d < p && d > 0 && f < p) {
        let x = p + b - d;
        x *= o === "right" ? -1 : 1, l += x;
      }
      return le(e).x + l;
    }, "x"),
    y: v(function(e, a, n) {
      let l = 0;
      const o = le(n[0]).y < le(n[n.length - 1]).y ? "down" : "up";
      if (a === 0 && Object.hasOwn(Hi, t.arrowTypeStart)) {
        const { angle: x, deltaY: _ } = to(n[0], n[1]);
        l = Hi[t.arrowTypeStart] * Math.abs(Math.sin(x)) * (_ >= 0 ? 1 : -1);
      } else if (a === n.length - 1 && Object.hasOwn(Hi, t.arrowTypeEnd)) {
        const { angle: x, deltaY: _ } = to(n[n.length - 1], n[n.length - 2]);
        l = Hi[t.arrowTypeEnd] * Math.abs(Math.sin(x)) * (_ >= 0 ? 1 : -1);
      }
      const h = Math.abs(le(e).y - le(n[n.length - 1]).y), u = Math.abs(le(e).x - le(n[n.length - 1]).x), d = Math.abs(le(e).y - le(n[0]).y), f = Math.abs(le(e).x - le(n[0]).x), p = Hi[t.arrowTypeStart], m = Hi[t.arrowTypeEnd], b = 1;
      if (h < m && h > 0 && u < m) {
        let x = m + b - h;
        x *= o === "up" ? -1 : 1, l -= x;
      }
      if (d < p && d > 0 && f < p) {
        let x = p + b - d;
        x *= o === "up" ? -1 : 1, l += x;
      }
      return le(e).y + l;
    }, "y")
  }), "getLineFunctionsWithOffset");
  $g = v(({ flowchart: t }) => {
    var _a2, _b2;
    const e = ((_a2 = t == null ? void 0 : t.subGraphTitleMargin) == null ? void 0 : _a2.top) ?? 0, a = ((_b2 = t == null ? void 0 : t.subGraphTitleMargin) == null ? void 0 : _b2.bottom) ?? 0, n = e + a;
    return {
      subGraphTitleTopMargin: e,
      subGraphTitleBottomMargin: a,
      subGraphTitleTotalMargin: n
    };
  }, "getSubGraphTitleMargins");
  M5 = v((t) => {
    const { handDrawnSeed: e } = Pt();
    return {
      fill: t,
      hachureAngle: 120,
      hachureGap: 4,
      fillWeight: 2,
      roughness: 0.7,
      stroke: t,
      seed: e
    };
  }, "solidStateFill");
  Ml = v((t) => {
    const e = B5([
      ...t.cssCompiledStyles || [],
      ...t.cssStyles || []
    ]);
    return {
      stylesMap: e,
      stylesArray: [
        ...e
      ]
    };
  }, "compileStyles");
  B5 = v((t) => {
    const e = /* @__PURE__ */ new Map();
    return t.forEach((a) => {
      const [n, l] = a.split(":");
      e.set(n.trim(), l == null ? void 0 : l.trim());
    }), e;
  }, "styles2Map");
  D_ = v((t) => t === "color" || t === "font-size" || t === "font-family" || t === "font-weight" || t === "font-style" || t === "text-decoration" || t === "text-align" || t === "text-transform" || t === "line-height" || t === "letter-spacing" || t === "word-spacing" || t === "text-shadow" || t === "text-overflow" || t === "white-space" || t === "word-wrap" || t === "word-break" || t === "overflow-wrap" || t === "hyphens", "isLabelStyle");
  vt = v((t) => {
    const { stylesArray: e } = Ml(t), a = [], n = [], l = [], o = [];
    return e.forEach((h) => {
      const u = h[0];
      D_(u) ? a.push(h.join(":") + " !important") : (n.push(h.join(":") + " !important"), u.includes("stroke") && l.push(h.join(":") + " !important"), u === "fill" && o.push(h.join(":") + " !important"));
    }), {
      labelStyles: a.join(";"),
      nodeStyles: n.join(";"),
      stylesArray: e,
      borderStyles: l,
      backgroundStyles: o
    };
  }, "styles2String");
  bt = v((t, e) => {
    var _a2;
    const { themeVariables: a, handDrawnSeed: n } = Pt(), { nodeBorder: l, mainBkg: o } = a, { stylesMap: h } = Ml(t);
    return Object.assign({
      roughness: 0.7,
      fill: h.get("fill") || o,
      fillStyle: "hachure",
      fillWeight: 4,
      hachureGap: 5.2,
      stroke: h.get("stroke") || l,
      seed: n,
      strokeWidth: ((_a2 = h.get("stroke-width")) == null ? void 0 : _a2.replace("px", "")) || 1.3,
      fillLineDash: [
        0,
        0
      ],
      strokeLineDash: L5(h.get("stroke-dasharray"))
    }, e);
  }, "userNodeOverrides");
  L5 = v((t) => {
    if (!t) return [
      0,
      0
    ];
    const e = t.trim().split(/\s+/).map(Number);
    if (e.length === 1) {
      const l = isNaN(e[0]) ? 0 : e[0];
      return [
        l,
        l
      ];
    }
    const a = isNaN(e[0]) ? 0 : e[0], n = isNaN(e[1]) ? 0 : e[1];
    return [
      a,
      n
    ];
  }, "getStrokeDashArray");
  Ys = {};
  Te = {};
  function O5() {
    return q1 || (q1 = 1, Object.defineProperty(Te, "__esModule", {
      value: true
    }), Te.BLANK_URL = Te.relativeFirstCharacters = Te.whitespaceEscapeCharsRegex = Te.urlSchemeRegex = Te.ctrlCharactersRegex = Te.htmlCtrlEntityRegex = Te.htmlEntitiesRegex = Te.invalidProtocolRegex = void 0, Te.invalidProtocolRegex = /^([^\w]*)(javascript|data|vbscript)/im, Te.htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g, Te.htmlCtrlEntityRegex = /&(newline|tab);/gi, Te.ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim, Te.urlSchemeRegex = /^.+(:|&colon;)/gim, Te.whitespaceEscapeCharsRegex = /(\\|%5[cC])((%(6[eE]|72|74))|[nrt])/g, Te.relativeFirstCharacters = [
      ".",
      "/"
    ], Te.BLANK_URL = "about:blank"), Te;
  }
  var H1;
  function D5() {
    if (H1) return Ys;
    H1 = 1, Object.defineProperty(Ys, "__esModule", {
      value: true
    }), Ys.sanitizeUrl = void 0;
    var t = O5();
    function e(h) {
      return t.relativeFirstCharacters.indexOf(h[0]) > -1;
    }
    function a(h) {
      var u = h.replace(t.ctrlCharactersRegex, "");
      return u.replace(t.htmlEntitiesRegex, function(d, f) {
        return String.fromCharCode(f);
      });
    }
    function n(h) {
      return URL.canParse(h);
    }
    function l(h) {
      try {
        return decodeURIComponent(h);
      } catch {
        return h;
      }
    }
    function o(h) {
      if (!h) return t.BLANK_URL;
      var u, d = l(h.trim());
      do
        d = a(d).replace(t.htmlCtrlEntityRegex, "").replace(t.ctrlCharactersRegex, "").replace(t.whitespaceEscapeCharsRegex, "").trim(), d = l(d), u = d.match(t.ctrlCharactersRegex) || d.match(t.htmlEntitiesRegex) || d.match(t.htmlCtrlEntityRegex) || d.match(t.whitespaceEscapeCharsRegex);
      while (u && u.length > 0);
      var f = d;
      if (!f) return t.BLANK_URL;
      if (e(f)) return f;
      var p = f.trimStart(), m = p.match(t.urlSchemeRegex);
      if (!m) return f;
      var b = m[0].toLowerCase().trim();
      if (t.invalidProtocolRegex.test(b)) return t.BLANK_URL;
      var x = p.replace(/\\/g, "/");
      if (b === "mailto:" || b.includes("://")) return x;
      if (b === "http:" || b === "https:") {
        if (!n(x)) return t.BLANK_URL;
        var _ = new URL(x);
        return _.protocol = _.protocol.toLowerCase(), _.hostname = _.hostname.toLowerCase(), _.toString();
      }
      return x;
    }
    return Ys.sanitizeUrl = o, Ys;
  }
  let R_, $5, vr, $_, N5, z5, Is;
  R5 = D5();
  R_ = typeof global == "object" && global && global.Object === Object && global;
  $5 = typeof self == "object" && self && self.Object === Object && self;
  vr = R_ || $5 || Function("return this")();
  Hu = vr.Symbol;
  $_ = Object.prototype;
  N5 = $_.hasOwnProperty;
  z5 = $_.toString;
  Is = Hu ? Hu.toStringTag : void 0;
  function F5(t) {
    var e = N5.call(t, Is), a = t[Is];
    try {
      t[Is] = void 0;
      var n = true;
    } catch {
    }
    var l = z5.call(t);
    return n && (e ? t[Is] = a : delete t[Is]), l;
  }
  var q5 = Object.prototype, H5 = q5.toString;
  function U5(t) {
    return H5.call(t);
  }
  var j5 = "[object Null]", Y5 = "[object Undefined]", U1 = Hu ? Hu.toStringTag : void 0;
  Bl = function(t) {
    return t == null ? t === void 0 ? Y5 : j5 : U1 && U1 in Object(t) ? F5(t) : U5(t);
  };
  Cn = function(t) {
    var e = typeof t;
    return t != null && (e == "object" || e == "function");
  };
  var I5 = "[object AsyncFunction]", P5 = "[object Function]", G5 = "[object GeneratorFunction]", W5 = "[object Proxy]";
  Ng = function(t) {
    if (!Cn(t)) return false;
    var e = Bl(t);
    return e == P5 || e == G5 || e == I5 || e == W5;
  };
  var Kd = vr["__core-js_shared__"], j1 = (function() {
    var t = /[^.]+$/.exec(Kd && Kd.keys && Kd.keys.IE_PROTO || "");
    return t ? "Symbol(src)_1." + t : "";
  })();
  function X5(t) {
    return !!j1 && j1 in t;
  }
  var V5 = Function.prototype, Z5 = V5.toString;
  function wn(t) {
    if (t != null) {
      try {
        return Z5.call(t);
      } catch {
      }
      try {
        return t + "";
      } catch {
      }
    }
    return "";
  }
  var Q5 = /[\\^$.*+?()[\]{}|]/g, K5 = /^\[object .+?Constructor\]$/, J5 = Function.prototype, tO = Object.prototype, eO = J5.toString, iO = tO.hasOwnProperty, rO = RegExp("^" + eO.call(iO).replace(Q5, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  function aO(t) {
    if (!Cn(t) || X5(t)) return false;
    var e = Ng(t) ? rO : K5;
    return e.test(wn(t));
  }
  function nO(t, e) {
    return t == null ? void 0 : t[e];
  }
  function Tn(t, e) {
    var a = nO(t, e);
    return aO(a) ? a : void 0;
  }
  var xo = Tn(Object, "create");
  function lO() {
    this.__data__ = xo ? xo(null) : {}, this.size = 0;
  }
  function sO(t) {
    var e = this.has(t) && delete this.__data__[t];
    return this.size -= e ? 1 : 0, e;
  }
  var oO = "__lodash_hash_undefined__", cO = Object.prototype, uO = cO.hasOwnProperty;
  function hO(t) {
    var e = this.__data__;
    if (xo) {
      var a = e[t];
      return a === oO ? void 0 : a;
    }
    return uO.call(e, t) ? e[t] : void 0;
  }
  var fO = Object.prototype, dO = fO.hasOwnProperty;
  function pO(t) {
    var e = this.__data__;
    return xo ? e[t] !== void 0 : dO.call(e, t);
  }
  var gO = "__lodash_hash_undefined__";
  function mO(t, e) {
    var a = this.__data__;
    return this.size += this.has(t) ? 0 : 1, a[t] = xo && e === void 0 ? gO : e, this;
  }
  function vn(t) {
    var e = -1, a = t == null ? 0 : t.length;
    for (this.clear(); ++e < a; ) {
      var n = t[e];
      this.set(n[0], n[1]);
    }
  }
  vn.prototype.clear = lO;
  vn.prototype.delete = sO;
  vn.prototype.get = hO;
  vn.prototype.has = pO;
  vn.prototype.set = mO;
  function yO() {
    this.__data__ = [], this.size = 0;
  }
  fh = function(t, e) {
    return t === e || t !== t && e !== e;
  };
  function dh(t, e) {
    for (var a = t.length; a--; ) if (fh(t[a][0], e)) return a;
    return -1;
  }
  var bO = Array.prototype, xO = bO.splice;
  function vO(t) {
    var e = this.__data__, a = dh(e, t);
    if (a < 0) return false;
    var n = e.length - 1;
    return a == n ? e.pop() : xO.call(e, a, 1), --this.size, true;
  }
  function _O(t) {
    var e = this.__data__, a = dh(e, t);
    return a < 0 ? void 0 : e[a][1];
  }
  function SO(t) {
    return dh(this.__data__, t) > -1;
  }
  function CO(t, e) {
    var a = this.__data__, n = dh(a, t);
    return n < 0 ? (++this.size, a.push([
      t,
      e
    ])) : a[n][1] = e, this;
  }
  function Jr(t) {
    var e = -1, a = t == null ? 0 : t.length;
    for (this.clear(); ++e < a; ) {
      var n = t[e];
      this.set(n[0], n[1]);
    }
  }
  Jr.prototype.clear = yO;
  Jr.prototype.delete = vO;
  Jr.prototype.get = _O;
  Jr.prototype.has = SO;
  Jr.prototype.set = CO;
  var vo = Tn(vr, "Map");
  function wO() {
    this.size = 0, this.__data__ = {
      hash: new vn(),
      map: new (vo || Jr)(),
      string: new vn()
    };
  }
  function TO(t) {
    var e = typeof t;
    return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
  }
  function ph(t, e) {
    var a = t.__data__;
    return TO(e) ? a[typeof e == "string" ? "string" : "hash"] : a.map;
  }
  function kO(t) {
    var e = ph(this, t).delete(t);
    return this.size -= e ? 1 : 0, e;
  }
  function AO(t) {
    return ph(this, t).get(t);
  }
  function EO(t) {
    return ph(this, t).has(t);
  }
  function MO(t, e) {
    var a = ph(this, t), n = a.size;
    return a.set(t, e), this.size += a.size == n ? 0 : 1, this;
  }
  Ra = function(t) {
    var e = -1, a = t == null ? 0 : t.length;
    for (this.clear(); ++e < a; ) {
      var n = t[e];
      this.set(n[0], n[1]);
    }
  };
  Ra.prototype.clear = wO;
  Ra.prototype.delete = kO;
  Ra.prototype.get = AO;
  Ra.prototype.has = EO;
  Ra.prototype.set = MO;
  var BO = "Expected a function";
  Mo = function(t, e) {
    if (typeof t != "function" || e != null && typeof e != "function") throw new TypeError(BO);
    var a = function() {
      var n = arguments, l = e ? e.apply(this, n) : n[0], o = a.cache;
      if (o.has(l)) return o.get(l);
      var h = t.apply(this, n);
      return a.cache = o.set(l, h) || o, h;
    };
    return a.cache = new (Mo.Cache || Ra)(), a;
  };
  Mo.Cache = Ra;
  function LO() {
    this.__data__ = new Jr(), this.size = 0;
  }
  function OO(t) {
    var e = this.__data__, a = e.delete(t);
    return this.size = e.size, a;
  }
  function DO(t) {
    return this.__data__.get(t);
  }
  function RO(t) {
    return this.__data__.has(t);
  }
  var $O = 200;
  function NO(t, e) {
    var a = this.__data__;
    if (a instanceof Jr) {
      var n = a.__data__;
      if (!vo || n.length < $O - 1) return n.push([
        t,
        e
      ]), this.size = ++a.size, this;
      a = this.__data__ = new Ra(n);
    }
    return a.set(t, e), this.size = a.size, this;
  }
  Ll = function(t) {
    var e = this.__data__ = new Jr(t);
    this.size = e.size;
  };
  Ll.prototype.clear = LO;
  Ll.prototype.delete = OO;
  Ll.prototype.get = DO;
  Ll.prototype.has = RO;
  Ll.prototype.set = NO;
  var Uu = (function() {
    try {
      var t = Tn(Object, "defineProperty");
      return t({}, "", {}), t;
    } catch {
    }
  })();
  zg = function(t, e, a) {
    e == "__proto__" && Uu ? Uu(t, e, {
      configurable: true,
      enumerable: true,
      value: a,
      writable: true
    }) : t[e] = a;
  };
  function Up(t, e, a) {
    (a !== void 0 && !fh(t[e], a) || a === void 0 && !(e in t)) && zg(t, e, a);
  }
  function zO(t) {
    return function(e, a, n) {
      for (var l = -1, o = Object(e), h = n(e), u = h.length; u--; ) {
        var d = h[++l];
        if (a(o[d], d, o) === false) break;
      }
      return e;
    };
  }
  let N_, Y1, qO, I1, P1;
  FO = zO();
  N_ = typeof exports == "object" && exports && !exports.nodeType && exports;
  Y1 = N_ && typeof module == "object" && module && !module.nodeType && module;
  qO = Y1 && Y1.exports === N_;
  I1 = qO ? vr.Buffer : void 0;
  P1 = I1 ? I1.allocUnsafe : void 0;
  HO = function(t, e) {
    if (e) return t.slice();
    var a = t.length, n = P1 ? P1(a) : new t.constructor(a);
    return t.copy(n), n;
  };
  G1 = vr.Uint8Array;
  UO = function(t) {
    var e = new t.constructor(t.byteLength);
    return new G1(e).set(new G1(t)), e;
  };
  jO = function(t, e) {
    var a = e ? UO(t.buffer) : t.buffer;
    return new t.constructor(a, t.byteOffset, t.length);
  };
  YO = function(t, e) {
    var a = -1, n = t.length;
    for (e || (e = Array(n)); ++a < n; ) e[a] = t[a];
    return e;
  };
  var W1 = Object.create, IO = /* @__PURE__ */ (function() {
    function t() {
    }
    return function(e) {
      if (!Cn(e)) return {};
      if (W1) return W1(e);
      t.prototype = e;
      var a = new t();
      return t.prototype = void 0, a;
    };
  })();
  function z_(t, e) {
    return function(a) {
      return t(e(a));
    };
  }
  let PO;
  F_ = z_(Object.getPrototypeOf, Object);
  PO = Object.prototype;
  gh = function(t) {
    var e = t && t.constructor, a = typeof e == "function" && e.prototype || PO;
    return t === a;
  };
  GO = function(t) {
    return typeof t.constructor == "function" && !gh(t) ? IO(F_(t)) : {};
  };
  Bo = function(t) {
    return t != null && typeof t == "object";
  };
  var WO = "[object Arguments]";
  function X1(t) {
    return Bo(t) && Bl(t) == WO;
  }
  let q_, XO, VO, ZO;
  q_ = Object.prototype;
  XO = q_.hasOwnProperty;
  VO = q_.propertyIsEnumerable;
  ju = X1(/* @__PURE__ */ (function() {
    return arguments;
  })()) ? X1 : function(t) {
    return Bo(t) && XO.call(t, "callee") && !VO.call(t, "callee");
  };
  Yu = Array.isArray;
  ZO = 9007199254740991;
  H_ = function(t) {
    return typeof t == "number" && t > -1 && t % 1 == 0 && t <= ZO;
  };
  mh = function(t) {
    return t != null && H_(t.length) && !Ng(t);
  };
  QO = function(t) {
    return Bo(t) && mh(t);
  };
  function KO() {
    return false;
  }
  let U_, V1, JO, Z1, tD, eD, iD, rD, j_, aD, nD;
  U_ = typeof exports == "object" && exports && !exports.nodeType && exports;
  V1 = U_ && typeof module == "object" && module && !module.nodeType && module;
  JO = V1 && V1.exports === U_;
  Z1 = JO ? vr.Buffer : void 0;
  tD = Z1 ? Z1.isBuffer : void 0;
  Fg = tD || KO;
  eD = "[object Object]";
  iD = Function.prototype;
  rD = Object.prototype;
  j_ = iD.toString;
  aD = rD.hasOwnProperty;
  nD = j_.call(Object);
  function lD(t) {
    if (!Bo(t) || Bl(t) != eD) return false;
    var e = F_(t);
    if (e === null) return true;
    var a = aD.call(e, "constructor") && e.constructor;
    return typeof a == "function" && a instanceof a && j_.call(a) == nD;
  }
  var sD = "[object Arguments]", oD = "[object Array]", cD = "[object Boolean]", uD = "[object Date]", hD = "[object Error]", fD = "[object Function]", dD = "[object Map]", pD = "[object Number]", gD = "[object Object]", mD = "[object RegExp]", yD = "[object Set]", bD = "[object String]", xD = "[object WeakMap]", vD = "[object ArrayBuffer]", _D = "[object DataView]", SD = "[object Float32Array]", CD = "[object Float64Array]", wD = "[object Int8Array]", TD = "[object Int16Array]", kD = "[object Int32Array]", AD = "[object Uint8Array]", ED = "[object Uint8ClampedArray]", MD = "[object Uint16Array]", BD = "[object Uint32Array]", ae = {};
  ae[SD] = ae[CD] = ae[wD] = ae[TD] = ae[kD] = ae[AD] = ae[ED] = ae[MD] = ae[BD] = true;
  ae[sD] = ae[oD] = ae[vD] = ae[cD] = ae[_D] = ae[uD] = ae[hD] = ae[fD] = ae[dD] = ae[pD] = ae[gD] = ae[mD] = ae[yD] = ae[bD] = ae[xD] = false;
  function LD(t) {
    return Bo(t) && H_(t.length) && !!ae[Bl(t)];
  }
  OD = function(t) {
    return function(e) {
      return t(e);
    };
  };
  let Y_, oo, DD, Jd, K1;
  Y_ = typeof exports == "object" && exports && !exports.nodeType && exports;
  oo = Y_ && typeof module == "object" && module && !module.nodeType && module;
  DD = oo && oo.exports === Y_;
  Jd = DD && R_.process;
  Q1 = (function() {
    try {
      var t = oo && oo.require && oo.require("util").types;
      return t || Jd && Jd.binding && Jd.binding("util");
    } catch {
    }
  })();
  K1 = Q1 && Q1.isTypedArray;
  qg = K1 ? OD(K1) : LD;
  function jp(t, e) {
    if (!(e === "constructor" && typeof t[e] == "function") && e != "__proto__") return t[e];
  }
  var RD = Object.prototype, $D = RD.hasOwnProperty;
  ND = function(t, e, a) {
    var n = t[e];
    (!($D.call(t, e) && fh(n, a)) || a === void 0 && !(e in t)) && zg(t, e, a);
  };
  zD = function(t, e, a, n) {
    var l = !a;
    a || (a = {});
    for (var o = -1, h = e.length; ++o < h; ) {
      var u = e[o], d = void 0;
      d === void 0 && (d = t[u]), l ? zg(a, u, d) : ND(a, u, d);
    }
    return a;
  };
  function FD(t, e) {
    for (var a = -1, n = Array(t); ++a < t; ) n[a] = e(a);
    return n;
  }
  var qD = 9007199254740991, HD = /^(?:0|[1-9]\d*)$/;
  I_ = function(t, e) {
    var a = typeof t;
    return e = e ?? qD, !!e && (a == "number" || a != "symbol" && HD.test(t)) && t > -1 && t % 1 == 0 && t < e;
  };
  var UD = Object.prototype, jD = UD.hasOwnProperty;
  YD = function(t, e) {
    var a = Yu(t), n = !a && ju(t), l = !a && !n && Fg(t), o = !a && !n && !l && qg(t), h = a || n || l || o, u = h ? FD(t.length, String) : [], d = u.length;
    for (var f in t) (e || jD.call(t, f)) && !(h && (f == "length" || l && (f == "offset" || f == "parent") || o && (f == "buffer" || f == "byteLength" || f == "byteOffset") || I_(f, d))) && u.push(f);
    return u;
  };
  function ID(t) {
    var e = [];
    if (t != null) for (var a in Object(t)) e.push(a);
    return e;
  }
  var PD = Object.prototype, GD = PD.hasOwnProperty;
  function WD(t) {
    if (!Cn(t)) return ID(t);
    var e = gh(t), a = [];
    for (var n in t) n == "constructor" && (e || !GD.call(t, n)) || a.push(n);
    return a;
  }
  P_ = function(t) {
    return mh(t) ? YD(t, true) : WD(t);
  };
  function XD(t) {
    return zD(t, P_(t));
  }
  function VD(t, e, a, n, l, o, h) {
    var u = jp(t, a), d = jp(e, a), f = h.get(d);
    if (f) {
      Up(t, a, f);
      return;
    }
    var p = o ? o(u, d, a + "", t, e, h) : void 0, m = p === void 0;
    if (m) {
      var b = Yu(d), x = !b && Fg(d), _ = !b && !x && qg(d);
      p = d, b || x || _ ? Yu(u) ? p = u : QO(u) ? p = YO(u) : x ? (m = false, p = HO(d, true)) : _ ? (m = false, p = jO(d, true)) : p = [] : lD(d) || ju(d) ? (p = u, ju(u) ? p = XD(u) : (!Cn(u) || Ng(u)) && (p = GO(d))) : m = false;
    }
    m && (h.set(d, p), l(p, d, n, o, h), h.delete(d)), Up(t, a, p);
  }
  function G_(t, e, a, n, l) {
    t !== e && FO(e, function(o, h) {
      if (l || (l = new Ll()), Cn(o)) VD(t, e, h, a, G_, n, l);
      else {
        var u = n ? n(jp(t, h), o, h + "", t, e, l) : void 0;
        u === void 0 && (u = o), Up(t, h, u);
      }
    }, P_);
  }
  W_ = function(t) {
    return t;
  };
  function ZD(t, e, a) {
    switch (a.length) {
      case 0:
        return t.call(e);
      case 1:
        return t.call(e, a[0]);
      case 2:
        return t.call(e, a[0], a[1]);
      case 3:
        return t.call(e, a[0], a[1], a[2]);
    }
    return t.apply(e, a);
  }
  var J1 = Math.max;
  QD = function(t, e, a) {
    return e = J1(e === void 0 ? t.length - 1 : e, 0), function() {
      for (var n = arguments, l = -1, o = J1(n.length - e, 0), h = Array(o); ++l < o; ) h[l] = n[e + l];
      l = -1;
      for (var u = Array(e + 1); ++l < e; ) u[l] = n[l];
      return u[e] = a(h), ZD(t, this, u);
    };
  };
  KD = function(t) {
    return function() {
      return t;
    };
  };
  var JD = Uu ? function(t, e) {
    return Uu(t, "toString", {
      configurable: true,
      enumerable: false,
      value: KD(e),
      writable: true
    });
  } : W_, t4 = 800, e4 = 16, i4 = Date.now;
  function r4(t) {
    var e = 0, a = 0;
    return function() {
      var n = i4(), l = e4 - (n - a);
      if (a = n, l > 0) {
        if (++e >= t4) return arguments[0];
      } else e = 0;
      return t.apply(void 0, arguments);
    };
  }
  a4 = r4(JD);
  n4 = function(t, e) {
    return a4(QD(t, e, W_), t + "");
  };
  l4 = function(t, e, a) {
    if (!Cn(a)) return false;
    var n = typeof e;
    return (n == "number" ? mh(a) && I_(e, a.length) : n == "string" && e in a) ? fh(a[e], t) : false;
  };
  s4 = function(t) {
    return n4(function(e, a) {
      var n = -1, l = a.length, o = l > 1 ? a[l - 1] : void 0, h = l > 2 ? a[2] : void 0;
      for (o = t.length > 3 && typeof o == "function" ? (l--, o) : void 0, h && l4(a[0], a[1], h) && (o = l < 3 ? void 0 : o, l = 1), e = Object(e); ++n < l; ) {
        var u = a[n];
        u && t(e, u, n, o);
      }
      return e;
    });
  };
  let u4, h4, f4, X_, d4, p4;
  o4 = s4(function(t, e, a) {
    G_(t, e, a);
  });
  c4 = "\u200B";
  u4 = {
    curveBasis: uu,
    curveBasisClosed: fL,
    curveBasisOpen: dL,
    curveBumpX: O2,
    curveBumpY: D2,
    curveBundle: pL,
    curveCardinalClosed: gL,
    curveCardinalOpen: mL,
    curveCardinal: z2,
    curveCatmullRomClosed: yL,
    curveCatmullRomOpen: bL,
    curveCatmullRom: q2,
    curveLinear: Bu,
    curveLinearClosed: xL,
    curveMonotoneX: P2,
    curveMonotoneY: G2,
    curveNatural: X2,
    curveStep: V2,
    curveStepAfter: Q2,
    curveStepBefore: Z2
  };
  h4 = /\s*(?:(\w+)(?=:):|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi;
  f4 = v(function(t, e) {
    const a = X_(t, /(?:init\b)|(?:initialize\b)/);
    let n = {};
    if (Array.isArray(a)) {
      const h = a.map((u) => u.args);
      xu(h), n = ke(n, [
        ...h
      ]);
    } else n = a.args;
    if (!n) return;
    let l = cg(t, e);
    const o = "config";
    return n[o] !== void 0 && (l === "flowchart-v2" && (l = "flowchart"), n[l] = n[o], delete n[o]), n;
  }, "detectInit");
  X_ = v(function(t, e = null) {
    var _a2, _b2;
    try {
      const a = new RegExp(`[%]{2}(?![{]${h4.source})(?=[}][%]{2}).*
`, "ig");
      t = t.trim().replace(a, "").replace(/'/gm, '"'), it.debug(`Detecting diagram directive${e !== null ? " type:" + e : ""} based on the text:${t}`);
      let n;
      const l = [];
      for (; (n = lo.exec(t)) !== null; ) if (n.index === lo.lastIndex && lo.lastIndex++, n && !e || e && ((_a2 = n[1]) == null ? void 0 : _a2.match(e)) || e && ((_b2 = n[2]) == null ? void 0 : _b2.match(e))) {
        const o = n[1] ? n[1] : n[2], h = n[3] ? n[3].trim() : n[4] ? JSON.parse(n[4].trim()) : null;
        l.push({
          type: o,
          args: h
        });
      }
      return l.length === 0 ? {
        type: t,
        args: null
      } : l.length === 1 ? l[0] : l;
    } catch (a) {
      return it.error(`ERROR: ${a.message} - Unable to parse directive type: '${e}' based on the text: '${t}'`), {
        type: void 0,
        args: null
      };
    }
  }, "detectDirective");
  d4 = v(function(t) {
    return t.replace(lo, "");
  }, "removeDirectives");
  p4 = v(function(t, e) {
    for (const [a, n] of e.entries()) if (n.match(t)) return a;
    return -1;
  }, "isSubstringInArray");
  function Hg(t, e) {
    if (!t) return e;
    const a = `curve${t.charAt(0).toUpperCase() + t.slice(1)}`;
    return u4[a] ?? e;
  }
  v(Hg, "interpolateToCurve");
  function V_(t, e) {
    const a = t.trim();
    if (a) return e.securityLevel !== "loose" ? R5.sanitizeUrl(a) : a;
  }
  v(V_, "formatUrl");
  var g4 = v((t, ...e) => {
    const a = t.split("."), n = a.length - 1, l = a[n];
    let o = window;
    for (let h = 0; h < n; h++) if (o = o[a[h]], !o) {
      it.error(`Function name: ${t} not found in window`);
      return;
    }
    o[l](...e);
  }, "runFunc");
  function Ug(t, e) {
    return !t || !e ? 0 : Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));
  }
  v(Ug, "distance");
  function Z_(t) {
    let e, a = 0;
    t.forEach((l) => {
      a += Ug(l, e), e = l;
    });
    const n = a / 2;
    return jg(t, n);
  }
  v(Z_, "traverseEdge");
  function Q_(t) {
    return t.length === 1 ? t[0] : Z_(t);
  }
  v(Q_, "calcLabelPosition");
  var tx = v((t, e = 2) => {
    const a = Math.pow(10, e);
    return Math.round(t * a) / a;
  }, "roundNumber"), jg = v((t, e) => {
    let a, n = e;
    for (const l of t) {
      if (a) {
        const o = Ug(l, a);
        if (o === 0) return a;
        if (o < n) n -= o;
        else {
          const h = n / o;
          if (h <= 0) return a;
          if (h >= 1) return {
            x: l.x,
            y: l.y
          };
          if (h > 0 && h < 1) return {
            x: tx((1 - h) * a.x + h * l.x, 5),
            y: tx((1 - h) * a.y + h * l.y, 5)
          };
        }
      }
      a = l;
    }
    throw new Error("Could not find a suitable point for the given distance");
  }, "calculatePoint"), m4 = v((t, e, a) => {
    it.info(`our points ${JSON.stringify(e)}`), e[0] !== a && (e = e.reverse());
    const l = jg(e, 25), o = t ? 10 : 5, h = Math.atan2(e[0].y - l.y, e[0].x - l.x), u = {
      x: 0,
      y: 0
    };
    return u.x = Math.sin(h) * o + (e[0].x + l.x) / 2, u.y = -Math.cos(h) * o + (e[0].y + l.y) / 2, u;
  }, "calcCardinalityPosition");
  function K_(t, e, a) {
    const n = structuredClone(a);
    it.info("our points", n), e !== "start_left" && e !== "start_right" && n.reverse();
    const l = 25 + t, o = jg(n, l), h = 10 + t * 0.5, u = Math.atan2(n[0].y - o.y, n[0].x - o.x), d = {
      x: 0,
      y: 0
    };
    return e === "start_left" ? (d.x = Math.sin(u + Math.PI) * h + (n[0].x + o.x) / 2, d.y = -Math.cos(u + Math.PI) * h + (n[0].y + o.y) / 2) : e === "end_right" ? (d.x = Math.sin(u - Math.PI) * h + (n[0].x + o.x) / 2 - 5, d.y = -Math.cos(u - Math.PI) * h + (n[0].y + o.y) / 2 - 5) : e === "end_left" ? (d.x = Math.sin(u) * h + (n[0].x + o.x) / 2 - 5, d.y = -Math.cos(u) * h + (n[0].y + o.y) / 2 - 5) : (d.x = Math.sin(u) * h + (n[0].x + o.x) / 2, d.y = -Math.cos(u) * h + (n[0].y + o.y) / 2), d;
  }
  v(K_, "calcTerminalLabelPosition");
  J_ = function(t) {
    let e = "", a = "";
    for (const n of t) n !== void 0 && (n.startsWith("color:") || n.startsWith("text-align:") ? a = a + n + ";" : e = e + n + ";");
    return {
      style: e,
      labelStyle: a
    };
  };
  v(J_, "getStylesFromArray");
  let ex;
  ex = 0;
  y4 = v(() => (ex++, "id-" + Math.random().toString(36).substr(2, 12) + "-" + ex), "generateId");
  function tS(t) {
    let e = "";
    const a = "0123456789abcdef", n = a.length;
    for (let l = 0; l < t; l++) e += a.charAt(Math.floor(Math.random() * n));
    return e;
  }
  v(tS, "makeRandomHex");
  let x4, v4, S4;
  b4 = v((t) => tS(t.length), "random");
  x4 = v(function() {
    return {
      x: 0,
      y: 0,
      fill: void 0,
      anchor: "start",
      style: "#666",
      width: 100,
      height: 100,
      textMargin: 0,
      rx: 0,
      ry: 0,
      valign: void 0,
      text: ""
    };
  }, "getTextObj");
  v4 = v(function(t, e) {
    const a = e.text.replace(El.lineBreakRegex, " "), [, n] = yh(e.fontSize), l = t.append("text");
    l.attr("x", e.x), l.attr("y", e.y), l.style("text-anchor", e.anchor), l.style("font-family", e.fontFamily), l.style("font-size", n), l.style("font-weight", e.fontWeight), l.attr("fill", e.fill), e.class !== void 0 && l.attr("class", e.class);
    const o = l.append("tspan");
    return o.attr("x", e.x + e.textMargin * 2), o.attr("fill", e.fill), o.text(a), l;
  }, "drawSimpleText");
  _4 = Mo((t, e, a) => {
    if (!t || (a = Object.assign({
      fontSize: 12,
      fontWeight: 400,
      fontFamily: "Arial",
      joinWith: "<br/>"
    }, a), El.lineBreakRegex.test(t))) return t;
    const n = t.split(" ").filter(Boolean), l = [];
    let o = "";
    return n.forEach((h, u) => {
      const d = Qr(`${h} `, a), f = Qr(o, a);
      if (d > e) {
        const { hyphenatedStrings: b, remainingWord: x } = S4(h, e, "-", a);
        l.push(o, ...b), o = x;
      } else f + d >= e ? (l.push(o), o = h) : o = [
        o,
        h
      ].filter(Boolean).join(" ");
      u + 1 === n.length && l.push(o);
    }), l.filter((h) => h !== "").join(a.joinWith);
  }, (t, e, a) => `${t}${e}${a.fontSize}${a.fontWeight}${a.fontFamily}${a.joinWith}`);
  S4 = Mo((t, e, a = "-", n) => {
    n = Object.assign({
      fontSize: 12,
      fontWeight: 400,
      fontFamily: "Arial",
      margin: 0
    }, n);
    const l = [
      ...t
    ], o = [];
    let h = "";
    return l.forEach((u, d) => {
      const f = `${h}${u}`;
      if (Qr(f, n) >= e) {
        const m = d + 1, b = l.length === m, x = `${f}${a}`;
        o.push(b ? f : x), h = "";
      } else h = f;
    }), {
      hyphenatedStrings: o,
      remainingWord: h
    };
  }, (t, e, a = "-", n) => `${t}${e}${a}${n.fontSize}${n.fontWeight}${n.fontFamily}`);
  eS = function(t, e) {
    return Yg(t, e).height;
  };
  v(eS, "calculateTextHeight");
  Qr = function(t, e) {
    return Yg(t, e).width;
  };
  v(Qr, "calculateTextWidth");
  var Yg = Mo((t, e) => {
    const { fontSize: a = 12, fontFamily: n = "Arial", fontWeight: l = 400 } = e;
    if (!t) return {
      width: 0,
      height: 0
    };
    const [, o] = yh(a), h = [
      "sans-serif",
      n
    ], u = t.split(El.lineBreakRegex), d = [], f = jt("body");
    if (!f.remove) return {
      width: 0,
      height: 0,
      lineHeight: 0
    };
    const p = f.append("svg");
    for (const b of h) {
      let x = 0;
      const _ = {
        width: 0,
        height: 0,
        lineHeight: 0
      };
      for (const S of u) {
        const w = x4();
        w.text = S || c4;
        const k = v4(p, w).style("font-size", o).style("font-weight", l).style("font-family", b), A = (k._groups || k)[0][0].getBBox();
        if (A.width === 0 && A.height === 0) throw new Error("svg element not in render tree");
        _.width = Math.round(Math.max(_.width, A.width)), x = Math.round(A.height), _.height += x, _.lineHeight = Math.round(Math.max(_.lineHeight, x));
      }
      d.push(_);
    }
    p.remove();
    const m = isNaN(d[1].height) || isNaN(d[1].width) || isNaN(d[1].lineHeight) || d[0].height > d[1].height && d[0].width > d[1].width && d[0].lineHeight > d[1].lineHeight ? 0 : 1;
    return d[m];
  }, (t, e) => `${t}${e.fontSize}${e.fontWeight}${e.fontFamily}`), C4 = (_h2 = class {
    constructor(t = false, e) {
      this.count = 0, this.count = e ? e.length : 0, this.next = t ? () => this.count++ : () => Date.now();
    }
  }, v(_h2, "InitIDGenerator"), _h2), Qc, w4 = v(function(t) {
    return Qc = Qc || document.createElement("div"), t = escape(t).replace(/%26/g, "&").replace(/%23/g, "#").replace(/%3B/g, ";"), Qc.innerHTML = t, unescape(Qc.textContent);
  }, "entityDecode");
  function Ig(t) {
    return "str" in t;
  }
  v(Ig, "isDetailedError");
  let T4;
  T4 = v((t, e, a, n) => {
    var _a2;
    if (!n) return;
    const l = (_a2 = t.node()) == null ? void 0 : _a2.getBBox();
    l && t.append("text").text(n).attr("text-anchor", "middle").attr("x", l.x + l.width / 2).attr("y", -a).attr("class", e);
  }, "insertTitle");
  yh = v((t) => {
    if (typeof t == "number") return [
      t,
      t + "px"
    ];
    const e = parseInt(t ?? "", 10);
    return Number.isNaN(e) ? [
      void 0,
      void 0
    ] : t === String(e) ? [
      e,
      t + "px"
    ] : [
      e,
      t
    ];
  }, "parseFontSize");
  Pg = function(t, e) {
    return o4({}, t, e);
  };
  v(Pg, "cleanAndMerge");
  let k4;
  tr = {
    assignWithDepth: ke,
    wrapLabel: _4,
    calculateTextHeight: eS,
    calculateTextWidth: Qr,
    calculateTextDimensions: Yg,
    cleanAndMerge: Pg,
    detectInit: f4,
    detectDirective: X_,
    isSubstringInArray: p4,
    interpolateToCurve: Hg,
    calcLabelPosition: Q_,
    calcCardinalityPosition: m4,
    calcTerminalLabelPosition: K_,
    formatUrl: V_,
    getStylesFromArray: J_,
    generateId: y4,
    random: b4,
    runFunc: g4,
    entityDecode: w4,
    insertTitle: T4,
    isLabelCoordinateInPath: iS,
    parseFontSize: yh,
    InitIDGenerator: C4
  };
  k4 = v(function(t) {
    let e = t;
    return e = e.replace(/style.*:\S*#.*;/g, function(a) {
      return a.substring(0, a.length - 1);
    }), e = e.replace(/classDef.*:\S*#.*;/g, function(a) {
      return a.substring(0, a.length - 1);
    }), e = e.replace(/#\w+;/g, function(a) {
      const n = a.substring(1, a.length - 1);
      return /^\+?\d+$/.test(n) ? "\uFB02\xB0\xB0" + n + "\xB6\xDF" : "\uFB02\xB0" + n + "\xB6\xDF";
    }), e;
  }, "encodeEntities");
  kn = v(function(t) {
    return t.replace(//g, "&#").replace(//g, "&").replace(//g, ";");
  }, "decodeEntities");
  kz = v((t, e, { counter: a = 0, prefix: n, suffix: l }, o) => o || `${n ? `${n}_` : ""}${t}_${e}_${a}${l ? `_${l}` : ""}`, "getEdgeId");
  function Ze(t) {
    return t ?? null;
  }
  v(Ze, "handleUndefinedAttr");
  function iS(t, e) {
    const a = Math.round(t.x), n = Math.round(t.y), l = e.replace(/(\d+\.\d+)/g, (o) => Math.round(parseFloat(o)).toString());
    return l.includes(a.toString()) || l.includes(n.toString());
  }
  v(iS, "isLabelCoordinateInPath");
  const A4 = Object.freeze({
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }), Iu = Object.freeze({
    rotate: 0,
    vFlip: false,
    hFlip: false
  }), rS = Object.freeze({
    ...A4,
    ...Iu
  }), E4 = Object.freeze({
    ...rS,
    body: "",
    hidden: false
  }), M4 = Object.freeze({
    width: null,
    height: null
  }), B4 = Object.freeze({
    ...M4,
    ...Iu
  }), L4 = (t, e, a, n = "") => {
    const l = t.split(":");
    if (t.slice(0, 1) === "@") {
      if (l.length < 2 || l.length > 3) return null;
      n = l.shift().slice(1);
    }
    if (l.length > 3 || !l.length) return null;
    if (l.length > 1) {
      const u = l.pop(), d = l.pop(), f = {
        provider: l.length > 0 ? l[0] : n,
        prefix: d,
        name: u
      };
      return tp(f) ? f : null;
    }
    const o = l[0], h = o.split("-");
    if (h.length > 1) {
      const u = {
        provider: n,
        prefix: h.shift(),
        name: h.join("-")
      };
      return tp(u) ? u : null;
    }
    if (a && n === "") {
      const u = {
        provider: n,
        prefix: "",
        name: o
      };
      return tp(u, a) ? u : null;
    }
    return null;
  }, tp = (t, e) => t ? !!((e && t.prefix === "" || t.prefix) && t.name) : false;
  function O4(t, e) {
    const a = {};
    !t.hFlip != !e.hFlip && (a.hFlip = true), !t.vFlip != !e.vFlip && (a.vFlip = true);
    const n = ((t.rotate || 0) + (e.rotate || 0)) % 4;
    return n && (a.rotate = n), a;
  }
  function ix(t, e) {
    const a = O4(t, e);
    for (const n in E4) n in Iu ? n in t && !(n in a) && (a[n] = Iu[n]) : n in e ? a[n] = e[n] : n in t && (a[n] = t[n]);
    return a;
  }
  function D4(t, e) {
    const a = t.icons, n = t.aliases || /* @__PURE__ */ Object.create(null), l = /* @__PURE__ */ Object.create(null);
    function o(h) {
      if (a[h]) return l[h] = [];
      if (!(h in l)) {
        l[h] = null;
        const u = n[h] && n[h].parent, d = u && o(u);
        d && (l[h] = [
          u
        ].concat(d));
      }
      return l[h];
    }
    return (e || Object.keys(a).concat(Object.keys(n))).forEach(o), l;
  }
  function rx(t, e, a) {
    const n = t.icons, l = t.aliases || /* @__PURE__ */ Object.create(null);
    let o = {};
    function h(u) {
      o = ix(n[u] || l[u], o);
    }
    return h(e), a.forEach(h), ix(t, o);
  }
  function R4(t, e) {
    if (t.icons[e]) return rx(t, e, []);
    const a = D4(t, [
      e
    ])[e];
    return a ? rx(t, e, a) : null;
  }
  const $4 = /(-?[0-9.]*[0-9]+[0-9.]*)/g, N4 = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
  function ax(t, e, a) {
    if (e === 1) return t;
    if (a = a || 100, typeof t == "number") return Math.ceil(t * e * a) / a;
    if (typeof t != "string") return t;
    const n = t.split($4);
    if (n === null || !n.length) return t;
    const l = [];
    let o = n.shift(), h = N4.test(o);
    for (; ; ) {
      if (h) {
        const u = parseFloat(o);
        isNaN(u) ? l.push(o) : l.push(Math.ceil(u * e * a) / a);
      } else l.push(o);
      if (o = n.shift(), o === void 0) return l.join("");
      h = !h;
    }
  }
  function z4(t, e = "defs") {
    let a = "";
    const n = t.indexOf("<" + e);
    for (; n >= 0; ) {
      const l = t.indexOf(">", n), o = t.indexOf("</" + e);
      if (l === -1 || o === -1) break;
      const h = t.indexOf(">", o);
      if (h === -1) break;
      a += t.slice(l + 1, o).trim(), t = t.slice(0, n).trim() + t.slice(h + 1);
    }
    return {
      defs: a,
      content: t
    };
  }
  function F4(t, e) {
    return t ? "<defs>" + t + "</defs>" + e : e;
  }
  function q4(t, e, a) {
    const n = z4(t);
    return F4(n.defs, e + n.content + a);
  }
  const H4 = (t) => t === "unset" || t === "undefined" || t === "none";
  function U4(t, e) {
    const a = {
      ...rS,
      ...t
    }, n = {
      ...B4,
      ...e
    }, l = {
      left: a.left,
      top: a.top,
      width: a.width,
      height: a.height
    };
    let o = a.body;
    [
      a,
      n
    ].forEach((S) => {
      const w = [], k = S.hFlip, A = S.vFlip;
      let L = S.rotate;
      k ? A ? L += 2 : (w.push("translate(" + (l.width + l.left).toString() + " " + (0 - l.top).toString() + ")"), w.push("scale(-1 1)"), l.top = l.left = 0) : A && (w.push("translate(" + (0 - l.left).toString() + " " + (l.height + l.top).toString() + ")"), w.push("scale(1 -1)"), l.top = l.left = 0);
      let $;
      switch (L < 0 && (L -= Math.floor(L / 4) * 4), L = L % 4, L) {
        case 1:
          $ = l.height / 2 + l.top, w.unshift("rotate(90 " + $.toString() + " " + $.toString() + ")");
          break;
        case 2:
          w.unshift("rotate(180 " + (l.width / 2 + l.left).toString() + " " + (l.height / 2 + l.top).toString() + ")");
          break;
        case 3:
          $ = l.width / 2 + l.left, w.unshift("rotate(-90 " + $.toString() + " " + $.toString() + ")");
          break;
      }
      L % 2 === 1 && (l.left !== l.top && ($ = l.left, l.left = l.top, l.top = $), l.width !== l.height && ($ = l.width, l.width = l.height, l.height = $)), w.length && (o = q4(o, '<g transform="' + w.join(" ") + '">', "</g>"));
    });
    const h = n.width, u = n.height, d = l.width, f = l.height;
    let p, m;
    h === null ? (m = u === null ? "1em" : u === "auto" ? f : u, p = ax(m, d / f)) : (p = h === "auto" ? d : h, m = u === null ? ax(p, f / d) : u === "auto" ? f : u);
    const b = {}, x = (S, w) => {
      H4(w) || (b[S] = w.toString());
    };
    x("width", p), x("height", m);
    const _ = [
      l.left,
      l.top,
      d,
      f
    ];
    return b.viewBox = _.join(" "), {
      attributes: b,
      viewBox: _,
      body: o
    };
  }
  const j4 = /\sid="(\S+)"/g, Y4 = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
  let I4 = 0;
  function P4(t, e = Y4) {
    const a = [];
    let n;
    for (; n = j4.exec(t); ) a.push(n[1]);
    if (!a.length) return t;
    const l = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
    return a.forEach((o) => {
      const h = typeof e == "function" ? e(o) : e + (I4++).toString(), u = o.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      t = t.replace(new RegExp('([#;"])(' + u + ')([")]|\\.[a-z])', "g"), "$1" + h + l + "$3");
    }), t = t.replace(new RegExp(l, "g"), ""), t;
  }
  function G4(t, e) {
    let a = t.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
    for (const n in e) a += " " + n + '="' + e[n] + '"';
    return '<svg xmlns="http://www.w3.org/2000/svg"' + a + ">" + t + "</svg>";
  }
  function Gg() {
    return {
      async: false,
      breaks: false,
      extensions: null,
      gfm: true,
      hooks: null,
      pedantic: false,
      renderer: null,
      silent: false,
      tokenizer: null,
      walkTokens: null
    };
  }
  var An = Gg();
  function aS(t) {
    An = t;
  }
  var co = {
    exec: () => null
  };
  function Xt(t, e = "") {
    let a = typeof t == "string" ? t : t.source;
    const n = {
      replace: (l, o) => {
        let h = typeof o == "string" ? o : o.source;
        return h = h.replace(ii.caret, "$1"), a = a.replace(l, h), n;
      },
      getRegex: () => new RegExp(a, e)
    };
    return n;
  }
  var ii = {
    codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm,
    outputLinkReplace: /\\([\[\]])/g,
    indentCodeCompensation: /^(\s+)(?:```)/,
    beginningSpace: /^\s+/,
    endingHash: /#$/,
    startingSpaceChar: /^ /,
    endingSpaceChar: / $/,
    nonSpaceChar: /[^ ]/,
    newLineCharGlobal: /\n/g,
    tabCharGlobal: /\t/g,
    multipleSpaceGlobal: /\s+/g,
    blankLine: /^[ \t]*$/,
    doubleBlankLine: /\n[ \t]*\n[ \t]*$/,
    blockquoteStart: /^ {0,3}>/,
    blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
    blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm,
    listReplaceTabs: /^\t+/,
    listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,
    listIsTask: /^\[[ xX]\] /,
    listReplaceTask: /^\[[ xX]\] +/,
    anyLine: /\n.*\n/,
    hrefBrackets: /^<(.*)>$/,
    tableDelimiter: /[:|]/,
    tableAlignChars: /^\||\| *$/g,
    tableRowBlankLine: /\n[ \t]*$/,
    tableAlignRight: /^ *-+: *$/,
    tableAlignCenter: /^ *:-+: *$/,
    tableAlignLeft: /^ *:-+ *$/,
    startATag: /^<a /i,
    endATag: /^<\/a>/i,
    startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i,
    endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i,
    startAngleBracket: /^</,
    endAngleBracket: />$/,
    pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/,
    unicodeAlphaNumeric: /[\p{L}\p{N}]/u,
    escapeTest: /[&<>"']/,
    escapeReplace: /[&<>"']/g,
    escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
    escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,
    unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,
    caret: /(^|[^\[])\^/g,
    percentDecode: /%25/g,
    findPipe: /\|/g,
    splitPipe: / \|/,
    slashPipe: /\\\|/g,
    carriageReturn: /\r\n|\r/g,
    spaceLine: /^ +$/gm,
    notSpaceStart: /^\S*/,
    endingNewline: /\n$/,
    listItemRegex: (t) => new RegExp(`^( {0,3}${t})((?:[	 ][^\\n]*)?(?:\\n|$))`),
    nextBulletRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),
    hrRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),
    fencesBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}(?:\`\`\`|~~~)`),
    headingBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}#`),
    htmlBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}<(?:[a-z].*>|!--)`, "i")
  }, W4 = /^(?:[ \t]*(?:\n|$))+/, X4 = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/, V4 = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, Lo = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, Z4 = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, Wg = /(?:[*+-]|\d{1,9}[.)])/, nS = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/, lS = Xt(nS).replace(/bull/g, Wg).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex(), Q4 = Xt(nS).replace(/bull/g, Wg).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(), Xg = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, K4 = /^[^\n]+/, Vg = /(?!\s*\])(?:\\.|[^\[\]\\])+/, J4 = Xt(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", Vg).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), tR = Xt(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, Wg).getRegex(), bh = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", Zg = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, eR = Xt("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", Zg).replace("tag", bh).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), sS = Xt(Xg).replace("hr", Lo).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", bh).getRegex(), iR = Xt(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", sS).getRegex(), Qg = {
    blockquote: iR,
    code: X4,
    def: J4,
    fences: V4,
    heading: Z4,
    hr: Lo,
    html: eR,
    lheading: lS,
    list: tR,
    newline: W4,
    paragraph: sS,
    table: co,
    text: K4
  }, nx = Xt("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", Lo).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", bh).getRegex(), rR = {
    ...Qg,
    lheading: Q4,
    table: nx,
    paragraph: Xt(Xg).replace("hr", Lo).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", nx).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", bh).getRegex()
  }, aR = {
    ...Qg,
    html: Xt(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", Zg).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: co,
    lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
    paragraph: Xt(Xg).replace("hr", Lo).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", lS).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
  }, nR = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, lR = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, oS = /^( {2,}|\\)\n(?!\s*$)/, sR = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, xh = /[\p{P}\p{S}]/u, Kg = /[\s\p{P}\p{S}]/u, cS = /[^\s\p{P}\p{S}]/u, oR = Xt(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, Kg).getRegex(), uS = /(?!~)[\p{P}\p{S}]/u, cR = /(?!~)[\s\p{P}\p{S}]/u, uR = /(?:[^\s\p{P}\p{S}]|~)/u, hR = /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g, hS = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/, fR = Xt(hS, "u").replace(/punct/g, xh).getRegex(), dR = Xt(hS, "u").replace(/punct/g, uS).getRegex(), fS = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)", pR = Xt(fS, "gu").replace(/notPunctSpace/g, cS).replace(/punctSpace/g, Kg).replace(/punct/g, xh).getRegex(), gR = Xt(fS, "gu").replace(/notPunctSpace/g, uR).replace(/punctSpace/g, cR).replace(/punct/g, uS).getRegex(), mR = Xt("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, cS).replace(/punctSpace/g, Kg).replace(/punct/g, xh).getRegex(), yR = Xt(/\\(punct)/, "gu").replace(/punct/g, xh).getRegex(), bR = Xt(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), xR = Xt(Zg).replace("(?:-->|$)", "-->").getRegex(), vR = Xt("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", xR).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), Pu = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, _R = Xt(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", Pu).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), dS = Xt(/^!?\[(label)\]\[(ref)\]/).replace("label", Pu).replace("ref", Vg).getRegex(), pS = Xt(/^!?\[(ref)\](?:\[\])?/).replace("ref", Vg).getRegex(), SR = Xt("reflink|nolink(?!\\()", "g").replace("reflink", dS).replace("nolink", pS).getRegex(), Jg = {
    _backpedal: co,
    anyPunctuation: yR,
    autolink: bR,
    blockSkip: hR,
    br: oS,
    code: lR,
    del: co,
    emStrongLDelim: fR,
    emStrongRDelimAst: pR,
    emStrongRDelimUnd: mR,
    escape: nR,
    link: _R,
    nolink: pS,
    punctuation: oR,
    reflink: dS,
    reflinkSearch: SR,
    tag: vR,
    text: sR,
    url: co
  }, CR = {
    ...Jg,
    link: Xt(/^!?\[(label)\]\((.*?)\)/).replace("label", Pu).getRegex(),
    reflink: Xt(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", Pu).getRegex()
  }, Yp = {
    ...Jg,
    emStrongRDelimAst: gR,
    emStrongLDelim: dR,
    url: Xt(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
    _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/,
    text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
  }, wR = {
    ...Yp,
    br: Xt(oS).replace("{2,}", "*").getRegex(),
    text: Xt(Yp.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
  }, Kc = {
    normal: Qg,
    gfm: rR,
    pedantic: aR
  }, Ps = {
    normal: Jg,
    gfm: Yp,
    breaks: wR,
    pedantic: CR
  }, TR = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  }, lx = (t) => TR[t];
  function dr(t, e) {
    if (e) {
      if (ii.escapeTest.test(t)) return t.replace(ii.escapeReplace, lx);
    } else if (ii.escapeTestNoEncode.test(t)) return t.replace(ii.escapeReplaceNoEncode, lx);
    return t;
  }
  function sx(t) {
    try {
      t = encodeURI(t).replace(ii.percentDecode, "%");
    } catch {
      return null;
    }
    return t;
  }
  function ox(t, e) {
    var _a2;
    const a = t.replace(ii.findPipe, (o, h, u) => {
      let d = false, f = h;
      for (; --f >= 0 && u[f] === "\\"; ) d = !d;
      return d ? "|" : " |";
    }), n = a.split(ii.splitPipe);
    let l = 0;
    if (n[0].trim() || n.shift(), n.length > 0 && !((_a2 = n.at(-1)) == null ? void 0 : _a2.trim()) && n.pop(), e) if (n.length > e) n.splice(e);
    else for (; n.length < e; ) n.push("");
    for (; l < n.length; l++) n[l] = n[l].trim().replace(ii.slashPipe, "|");
    return n;
  }
  function Gs(t, e, a) {
    const n = t.length;
    if (n === 0) return "";
    let l = 0;
    for (; l < n && t.charAt(n - l - 1) === e; ) l++;
    return t.slice(0, n - l);
  }
  function kR(t, e) {
    if (t.indexOf(e[1]) === -1) return -1;
    let a = 0;
    for (let n = 0; n < t.length; n++) if (t[n] === "\\") n++;
    else if (t[n] === e[0]) a++;
    else if (t[n] === e[1] && (a--, a < 0)) return n;
    return a > 0 ? -2 : -1;
  }
  function cx(t, e, a, n, l) {
    const o = e.href, h = e.title || null, u = t[1].replace(l.other.outputLinkReplace, "$1");
    n.state.inLink = true;
    const d = {
      type: t[0].charAt(0) === "!" ? "image" : "link",
      raw: a,
      href: o,
      title: h,
      text: u,
      tokens: n.inlineTokens(u)
    };
    return n.state.inLink = false, d;
  }
  function AR(t, e, a) {
    const n = t.match(a.other.indentCodeCompensation);
    if (n === null) return e;
    const l = n[1];
    return e.split(`
`).map((o) => {
      const h = o.match(a.other.beginningSpace);
      if (h === null) return o;
      const [u] = h;
      return u.length >= l.length ? o.slice(l.length) : o;
    }).join(`
`);
  }
  var Gu = class {
    constructor(t) {
      __publicField(this, "options");
      __publicField(this, "rules");
      __publicField(this, "lexer");
      this.options = t || An;
    }
    space(t) {
      const e = this.rules.block.newline.exec(t);
      if (e && e[0].length > 0) return {
        type: "space",
        raw: e[0]
      };
    }
    code(t) {
      const e = this.rules.block.code.exec(t);
      if (e) {
        const a = e[0].replace(this.rules.other.codeRemoveIndent, "");
        return {
          type: "code",
          raw: e[0],
          codeBlockStyle: "indented",
          text: this.options.pedantic ? a : Gs(a, `
`)
        };
      }
    }
    fences(t) {
      const e = this.rules.block.fences.exec(t);
      if (e) {
        const a = e[0], n = AR(a, e[3] || "", this.rules);
        return {
          type: "code",
          raw: a,
          lang: e[2] ? e[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : e[2],
          text: n
        };
      }
    }
    heading(t) {
      const e = this.rules.block.heading.exec(t);
      if (e) {
        let a = e[2].trim();
        if (this.rules.other.endingHash.test(a)) {
          const n = Gs(a, "#");
          (this.options.pedantic || !n || this.rules.other.endingSpaceChar.test(n)) && (a = n.trim());
        }
        return {
          type: "heading",
          raw: e[0],
          depth: e[1].length,
          text: a,
          tokens: this.lexer.inline(a)
        };
      }
    }
    hr(t) {
      const e = this.rules.block.hr.exec(t);
      if (e) return {
        type: "hr",
        raw: Gs(e[0], `
`)
      };
    }
    blockquote(t) {
      const e = this.rules.block.blockquote.exec(t);
      if (e) {
        let a = Gs(e[0], `
`).split(`
`), n = "", l = "";
        const o = [];
        for (; a.length > 0; ) {
          let h = false;
          const u = [];
          let d;
          for (d = 0; d < a.length; d++) if (this.rules.other.blockquoteStart.test(a[d])) u.push(a[d]), h = true;
          else if (!h) u.push(a[d]);
          else break;
          a = a.slice(d);
          const f = u.join(`
`), p = f.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
          n = n ? `${n}
${f}` : f, l = l ? `${l}
${p}` : p;
          const m = this.lexer.state.top;
          if (this.lexer.state.top = true, this.lexer.blockTokens(p, o, true), this.lexer.state.top = m, a.length === 0) break;
          const b = o.at(-1);
          if ((b == null ? void 0 : b.type) === "code") break;
          if ((b == null ? void 0 : b.type) === "blockquote") {
            const x = b, _ = x.raw + `
` + a.join(`
`), S = this.blockquote(_);
            o[o.length - 1] = S, n = n.substring(0, n.length - x.raw.length) + S.raw, l = l.substring(0, l.length - x.text.length) + S.text;
            break;
          } else if ((b == null ? void 0 : b.type) === "list") {
            const x = b, _ = x.raw + `
` + a.join(`
`), S = this.list(_);
            o[o.length - 1] = S, n = n.substring(0, n.length - b.raw.length) + S.raw, l = l.substring(0, l.length - x.raw.length) + S.raw, a = _.substring(o.at(-1).raw.length).split(`
`);
            continue;
          }
        }
        return {
          type: "blockquote",
          raw: n,
          tokens: o,
          text: l
        };
      }
    }
    list(t) {
      let e = this.rules.block.list.exec(t);
      if (e) {
        let a = e[1].trim();
        const n = a.length > 1, l = {
          type: "list",
          raw: "",
          ordered: n,
          start: n ? +a.slice(0, -1) : "",
          loose: false,
          items: []
        };
        a = n ? `\\d{1,9}\\${a.slice(-1)}` : `\\${a}`, this.options.pedantic && (a = n ? a : "[*+-]");
        const o = this.rules.other.listItemRegex(a);
        let h = false;
        for (; t; ) {
          let d = false, f = "", p = "";
          if (!(e = o.exec(t)) || this.rules.block.hr.test(t)) break;
          f = e[0], t = t.substring(f.length);
          let m = e[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, (k) => " ".repeat(3 * k.length)), b = t.split(`
`, 1)[0], x = !m.trim(), _ = 0;
          if (this.options.pedantic ? (_ = 2, p = m.trimStart()) : x ? _ = e[1].length + 1 : (_ = e[2].search(this.rules.other.nonSpaceChar), _ = _ > 4 ? 1 : _, p = m.slice(_), _ += e[1].length), x && this.rules.other.blankLine.test(b) && (f += b + `
`, t = t.substring(b.length + 1), d = true), !d) {
            const k = this.rules.other.nextBulletRegex(_), A = this.rules.other.hrRegex(_), L = this.rules.other.fencesBeginRegex(_), $ = this.rules.other.headingBeginRegex(_), O = this.rules.other.htmlBeginRegex(_);
            for (; t; ) {
              const W = t.split(`
`, 1)[0];
              let j;
              if (b = W, this.options.pedantic ? (b = b.replace(this.rules.other.listReplaceNesting, "  "), j = b) : j = b.replace(this.rules.other.tabCharGlobal, "    "), L.test(b) || $.test(b) || O.test(b) || k.test(b) || A.test(b)) break;
              if (j.search(this.rules.other.nonSpaceChar) >= _ || !b.trim()) p += `
` + j.slice(_);
              else {
                if (x || m.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || L.test(m) || $.test(m) || A.test(m)) break;
                p += `
` + b;
              }
              !x && !b.trim() && (x = true), f += W + `
`, t = t.substring(W.length + 1), m = j.slice(_);
            }
          }
          l.loose || (h ? l.loose = true : this.rules.other.doubleBlankLine.test(f) && (h = true));
          let S = null, w;
          this.options.gfm && (S = this.rules.other.listIsTask.exec(p), S && (w = S[0] !== "[ ] ", p = p.replace(this.rules.other.listReplaceTask, ""))), l.items.push({
            type: "list_item",
            raw: f,
            task: !!S,
            checked: w,
            loose: false,
            text: p,
            tokens: []
          }), l.raw += f;
        }
        const u = l.items.at(-1);
        if (u) u.raw = u.raw.trimEnd(), u.text = u.text.trimEnd();
        else return;
        l.raw = l.raw.trimEnd();
        for (let d = 0; d < l.items.length; d++) if (this.lexer.state.top = false, l.items[d].tokens = this.lexer.blockTokens(l.items[d].text, []), !l.loose) {
          const f = l.items[d].tokens.filter((m) => m.type === "space"), p = f.length > 0 && f.some((m) => this.rules.other.anyLine.test(m.raw));
          l.loose = p;
        }
        if (l.loose) for (let d = 0; d < l.items.length; d++) l.items[d].loose = true;
        return l;
      }
    }
    html(t) {
      const e = this.rules.block.html.exec(t);
      if (e) return {
        type: "html",
        block: true,
        raw: e[0],
        pre: e[1] === "pre" || e[1] === "script" || e[1] === "style",
        text: e[0]
      };
    }
    def(t) {
      const e = this.rules.block.def.exec(t);
      if (e) {
        const a = e[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), n = e[2] ? e[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", l = e[3] ? e[3].substring(1, e[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : e[3];
        return {
          type: "def",
          tag: a,
          raw: e[0],
          href: n,
          title: l
        };
      }
    }
    table(t) {
      var _a2;
      const e = this.rules.block.table.exec(t);
      if (!e || !this.rules.other.tableDelimiter.test(e[2])) return;
      const a = ox(e[1]), n = e[2].replace(this.rules.other.tableAlignChars, "").split("|"), l = ((_a2 = e[3]) == null ? void 0 : _a2.trim()) ? e[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], o = {
        type: "table",
        raw: e[0],
        header: [],
        align: [],
        rows: []
      };
      if (a.length === n.length) {
        for (const h of n) this.rules.other.tableAlignRight.test(h) ? o.align.push("right") : this.rules.other.tableAlignCenter.test(h) ? o.align.push("center") : this.rules.other.tableAlignLeft.test(h) ? o.align.push("left") : o.align.push(null);
        for (let h = 0; h < a.length; h++) o.header.push({
          text: a[h],
          tokens: this.lexer.inline(a[h]),
          header: true,
          align: o.align[h]
        });
        for (const h of l) o.rows.push(ox(h, o.header.length).map((u, d) => ({
          text: u,
          tokens: this.lexer.inline(u),
          header: false,
          align: o.align[d]
        })));
        return o;
      }
    }
    lheading(t) {
      const e = this.rules.block.lheading.exec(t);
      if (e) return {
        type: "heading",
        raw: e[0],
        depth: e[2].charAt(0) === "=" ? 1 : 2,
        text: e[1],
        tokens: this.lexer.inline(e[1])
      };
    }
    paragraph(t) {
      const e = this.rules.block.paragraph.exec(t);
      if (e) {
        const a = e[1].charAt(e[1].length - 1) === `
` ? e[1].slice(0, -1) : e[1];
        return {
          type: "paragraph",
          raw: e[0],
          text: a,
          tokens: this.lexer.inline(a)
        };
      }
    }
    text(t) {
      const e = this.rules.block.text.exec(t);
      if (e) return {
        type: "text",
        raw: e[0],
        text: e[0],
        tokens: this.lexer.inline(e[0])
      };
    }
    escape(t) {
      const e = this.rules.inline.escape.exec(t);
      if (e) return {
        type: "escape",
        raw: e[0],
        text: e[1]
      };
    }
    tag(t) {
      const e = this.rules.inline.tag.exec(t);
      if (e) return !this.lexer.state.inLink && this.rules.other.startATag.test(e[0]) ? this.lexer.state.inLink = true : this.lexer.state.inLink && this.rules.other.endATag.test(e[0]) && (this.lexer.state.inLink = false), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(e[0]) ? this.lexer.state.inRawBlock = true : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(e[0]) && (this.lexer.state.inRawBlock = false), {
        type: "html",
        raw: e[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        block: false,
        text: e[0]
      };
    }
    link(t) {
      const e = this.rules.inline.link.exec(t);
      if (e) {
        const a = e[2].trim();
        if (!this.options.pedantic && this.rules.other.startAngleBracket.test(a)) {
          if (!this.rules.other.endAngleBracket.test(a)) return;
          const o = Gs(a.slice(0, -1), "\\");
          if ((a.length - o.length) % 2 === 0) return;
        } else {
          const o = kR(e[2], "()");
          if (o === -2) return;
          if (o > -1) {
            const u = (e[0].indexOf("!") === 0 ? 5 : 4) + e[1].length + o;
            e[2] = e[2].substring(0, o), e[0] = e[0].substring(0, u).trim(), e[3] = "";
          }
        }
        let n = e[2], l = "";
        if (this.options.pedantic) {
          const o = this.rules.other.pedanticHrefTitle.exec(n);
          o && (n = o[1], l = o[3]);
        } else l = e[3] ? e[3].slice(1, -1) : "";
        return n = n.trim(), this.rules.other.startAngleBracket.test(n) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(a) ? n = n.slice(1) : n = n.slice(1, -1)), cx(e, {
          href: n && n.replace(this.rules.inline.anyPunctuation, "$1"),
          title: l && l.replace(this.rules.inline.anyPunctuation, "$1")
        }, e[0], this.lexer, this.rules);
      }
    }
    reflink(t, e) {
      let a;
      if ((a = this.rules.inline.reflink.exec(t)) || (a = this.rules.inline.nolink.exec(t))) {
        const n = (a[2] || a[1]).replace(this.rules.other.multipleSpaceGlobal, " "), l = e[n.toLowerCase()];
        if (!l) {
          const o = a[0].charAt(0);
          return {
            type: "text",
            raw: o,
            text: o
          };
        }
        return cx(a, l, a[0], this.lexer, this.rules);
      }
    }
    emStrong(t, e, a = "") {
      let n = this.rules.inline.emStrongLDelim.exec(t);
      if (!n || n[3] && a.match(this.rules.other.unicodeAlphaNumeric)) return;
      if (!(n[1] || n[2] || "") || !a || this.rules.inline.punctuation.exec(a)) {
        const o = [
          ...n[0]
        ].length - 1;
        let h, u, d = o, f = 0;
        const p = n[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
        for (p.lastIndex = 0, e = e.slice(-1 * t.length + o); (n = p.exec(e)) != null; ) {
          if (h = n[1] || n[2] || n[3] || n[4] || n[5] || n[6], !h) continue;
          if (u = [
            ...h
          ].length, n[3] || n[4]) {
            d += u;
            continue;
          } else if ((n[5] || n[6]) && o % 3 && !((o + u) % 3)) {
            f += u;
            continue;
          }
          if (d -= u, d > 0) continue;
          u = Math.min(u, u + d + f);
          const m = [
            ...n[0]
          ][0].length, b = t.slice(0, o + n.index + m + u);
          if (Math.min(o, u) % 2) {
            const _ = b.slice(1, -1);
            return {
              type: "em",
              raw: b,
              text: _,
              tokens: this.lexer.inlineTokens(_)
            };
          }
          const x = b.slice(2, -2);
          return {
            type: "strong",
            raw: b,
            text: x,
            tokens: this.lexer.inlineTokens(x)
          };
        }
      }
    }
    codespan(t) {
      const e = this.rules.inline.code.exec(t);
      if (e) {
        let a = e[2].replace(this.rules.other.newLineCharGlobal, " ");
        const n = this.rules.other.nonSpaceChar.test(a), l = this.rules.other.startingSpaceChar.test(a) && this.rules.other.endingSpaceChar.test(a);
        return n && l && (a = a.substring(1, a.length - 1)), {
          type: "codespan",
          raw: e[0],
          text: a
        };
      }
    }
    br(t) {
      const e = this.rules.inline.br.exec(t);
      if (e) return {
        type: "br",
        raw: e[0]
      };
    }
    del(t) {
      const e = this.rules.inline.del.exec(t);
      if (e) return {
        type: "del",
        raw: e[0],
        text: e[2],
        tokens: this.lexer.inlineTokens(e[2])
      };
    }
    autolink(t) {
      const e = this.rules.inline.autolink.exec(t);
      if (e) {
        let a, n;
        return e[2] === "@" ? (a = e[1], n = "mailto:" + a) : (a = e[1], n = a), {
          type: "link",
          raw: e[0],
          text: a,
          href: n,
          tokens: [
            {
              type: "text",
              raw: a,
              text: a
            }
          ]
        };
      }
    }
    url(t) {
      var _a2;
      let e;
      if (e = this.rules.inline.url.exec(t)) {
        let a, n;
        if (e[2] === "@") a = e[0], n = "mailto:" + a;
        else {
          let l;
          do
            l = e[0], e[0] = ((_a2 = this.rules.inline._backpedal.exec(e[0])) == null ? void 0 : _a2[0]) ?? "";
          while (l !== e[0]);
          a = e[0], e[1] === "www." ? n = "http://" + e[0] : n = e[0];
        }
        return {
          type: "link",
          raw: e[0],
          text: a,
          href: n,
          tokens: [
            {
              type: "text",
              raw: a,
              text: a
            }
          ]
        };
      }
    }
    inlineText(t) {
      const e = this.rules.inline.text.exec(t);
      if (e) {
        const a = this.lexer.state.inRawBlock;
        return {
          type: "text",
          raw: e[0],
          text: e[0],
          escaped: a
        };
      }
    }
  }, Gr = class Ip {
    constructor(e) {
      __publicField(this, "tokens");
      __publicField(this, "options");
      __publicField(this, "state");
      __publicField(this, "tokenizer");
      __publicField(this, "inlineQueue");
      this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e || An, this.options.tokenizer = this.options.tokenizer || new Gu(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = {
        inLink: false,
        inRawBlock: false,
        top: true
      };
      const a = {
        other: ii,
        block: Kc.normal,
        inline: Ps.normal
      };
      this.options.pedantic ? (a.block = Kc.pedantic, a.inline = Ps.pedantic) : this.options.gfm && (a.block = Kc.gfm, this.options.breaks ? a.inline = Ps.breaks : a.inline = Ps.gfm), this.tokenizer.rules = a;
    }
    static get rules() {
      return {
        block: Kc,
        inline: Ps
      };
    }
    static lex(e, a) {
      return new Ip(a).lex(e);
    }
    static lexInline(e, a) {
      return new Ip(a).inlineTokens(e);
    }
    lex(e) {
      e = e.replace(ii.carriageReturn, `
`), this.blockTokens(e, this.tokens);
      for (let a = 0; a < this.inlineQueue.length; a++) {
        const n = this.inlineQueue[a];
        this.inlineTokens(n.src, n.tokens);
      }
      return this.inlineQueue = [], this.tokens;
    }
    blockTokens(e, a = [], n = false) {
      var _a2, _b2, _c2;
      for (this.options.pedantic && (e = e.replace(ii.tabCharGlobal, "    ").replace(ii.spaceLine, "")); e; ) {
        let l;
        if ((_b2 = (_a2 = this.options.extensions) == null ? void 0 : _a2.block) == null ? void 0 : _b2.some((h) => (l = h.call({
          lexer: this
        }, e, a)) ? (e = e.substring(l.raw.length), a.push(l), true) : false)) continue;
        if (l = this.tokenizer.space(e)) {
          e = e.substring(l.raw.length);
          const h = a.at(-1);
          l.raw.length === 1 && h !== void 0 ? h.raw += `
` : a.push(l);
          continue;
        }
        if (l = this.tokenizer.code(e)) {
          e = e.substring(l.raw.length);
          const h = a.at(-1);
          (h == null ? void 0 : h.type) === "paragraph" || (h == null ? void 0 : h.type) === "text" ? (h.raw += `
` + l.raw, h.text += `
` + l.text, this.inlineQueue.at(-1).src = h.text) : a.push(l);
          continue;
        }
        if (l = this.tokenizer.fences(e)) {
          e = e.substring(l.raw.length), a.push(l);
          continue;
        }
        if (l = this.tokenizer.heading(e)) {
          e = e.substring(l.raw.length), a.push(l);
          continue;
        }
        if (l = this.tokenizer.hr(e)) {
          e = e.substring(l.raw.length), a.push(l);
          continue;
        }
        if (l = this.tokenizer.blockquote(e)) {
          e = e.substring(l.raw.length), a.push(l);
          continue;
        }
        if (l = this.tokenizer.list(e)) {
          e = e.substring(l.raw.length), a.push(l);
          continue;
        }
        if (l = this.tokenizer.html(e)) {
          e = e.substring(l.raw.length), a.push(l);
          continue;
        }
        if (l = this.tokenizer.def(e)) {
          e = e.substring(l.raw.length);
          const h = a.at(-1);
          (h == null ? void 0 : h.type) === "paragraph" || (h == null ? void 0 : h.type) === "text" ? (h.raw += `
` + l.raw, h.text += `
` + l.raw, this.inlineQueue.at(-1).src = h.text) : this.tokens.links[l.tag] || (this.tokens.links[l.tag] = {
            href: l.href,
            title: l.title
          });
          continue;
        }
        if (l = this.tokenizer.table(e)) {
          e = e.substring(l.raw.length), a.push(l);
          continue;
        }
        if (l = this.tokenizer.lheading(e)) {
          e = e.substring(l.raw.length), a.push(l);
          continue;
        }
        let o = e;
        if ((_c2 = this.options.extensions) == null ? void 0 : _c2.startBlock) {
          let h = 1 / 0;
          const u = e.slice(1);
          let d;
          this.options.extensions.startBlock.forEach((f) => {
            d = f.call({
              lexer: this
            }, u), typeof d == "number" && d >= 0 && (h = Math.min(h, d));
          }), h < 1 / 0 && h >= 0 && (o = e.substring(0, h + 1));
        }
        if (this.state.top && (l = this.tokenizer.paragraph(o))) {
          const h = a.at(-1);
          n && (h == null ? void 0 : h.type) === "paragraph" ? (h.raw += `
` + l.raw, h.text += `
` + l.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = h.text) : a.push(l), n = o.length !== e.length, e = e.substring(l.raw.length);
          continue;
        }
        if (l = this.tokenizer.text(e)) {
          e = e.substring(l.raw.length);
          const h = a.at(-1);
          (h == null ? void 0 : h.type) === "text" ? (h.raw += `
` + l.raw, h.text += `
` + l.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = h.text) : a.push(l);
          continue;
        }
        if (e) {
          const h = "Infinite loop on byte: " + e.charCodeAt(0);
          if (this.options.silent) {
            console.error(h);
            break;
          } else throw new Error(h);
        }
      }
      return this.state.top = true, a;
    }
    inline(e, a = []) {
      return this.inlineQueue.push({
        src: e,
        tokens: a
      }), a;
    }
    inlineTokens(e, a = []) {
      var _a2, _b2, _c2;
      let n = e, l = null;
      if (this.tokens.links) {
        const u = Object.keys(this.tokens.links);
        if (u.length > 0) for (; (l = this.tokenizer.rules.inline.reflinkSearch.exec(n)) != null; ) u.includes(l[0].slice(l[0].lastIndexOf("[") + 1, -1)) && (n = n.slice(0, l.index) + "[" + "a".repeat(l[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
      }
      for (; (l = this.tokenizer.rules.inline.anyPunctuation.exec(n)) != null; ) n = n.slice(0, l.index) + "++" + n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
      for (; (l = this.tokenizer.rules.inline.blockSkip.exec(n)) != null; ) n = n.slice(0, l.index) + "[" + "a".repeat(l[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
      let o = false, h = "";
      for (; e; ) {
        o || (h = ""), o = false;
        let u;
        if ((_b2 = (_a2 = this.options.extensions) == null ? void 0 : _a2.inline) == null ? void 0 : _b2.some((f) => (u = f.call({
          lexer: this
        }, e, a)) ? (e = e.substring(u.raw.length), a.push(u), true) : false)) continue;
        if (u = this.tokenizer.escape(e)) {
          e = e.substring(u.raw.length), a.push(u);
          continue;
        }
        if (u = this.tokenizer.tag(e)) {
          e = e.substring(u.raw.length), a.push(u);
          continue;
        }
        if (u = this.tokenizer.link(e)) {
          e = e.substring(u.raw.length), a.push(u);
          continue;
        }
        if (u = this.tokenizer.reflink(e, this.tokens.links)) {
          e = e.substring(u.raw.length);
          const f = a.at(-1);
          u.type === "text" && (f == null ? void 0 : f.type) === "text" ? (f.raw += u.raw, f.text += u.text) : a.push(u);
          continue;
        }
        if (u = this.tokenizer.emStrong(e, n, h)) {
          e = e.substring(u.raw.length), a.push(u);
          continue;
        }
        if (u = this.tokenizer.codespan(e)) {
          e = e.substring(u.raw.length), a.push(u);
          continue;
        }
        if (u = this.tokenizer.br(e)) {
          e = e.substring(u.raw.length), a.push(u);
          continue;
        }
        if (u = this.tokenizer.del(e)) {
          e = e.substring(u.raw.length), a.push(u);
          continue;
        }
        if (u = this.tokenizer.autolink(e)) {
          e = e.substring(u.raw.length), a.push(u);
          continue;
        }
        if (!this.state.inLink && (u = this.tokenizer.url(e))) {
          e = e.substring(u.raw.length), a.push(u);
          continue;
        }
        let d = e;
        if ((_c2 = this.options.extensions) == null ? void 0 : _c2.startInline) {
          let f = 1 / 0;
          const p = e.slice(1);
          let m;
          this.options.extensions.startInline.forEach((b) => {
            m = b.call({
              lexer: this
            }, p), typeof m == "number" && m >= 0 && (f = Math.min(f, m));
          }), f < 1 / 0 && f >= 0 && (d = e.substring(0, f + 1));
        }
        if (u = this.tokenizer.inlineText(d)) {
          e = e.substring(u.raw.length), u.raw.slice(-1) !== "_" && (h = u.raw.slice(-1)), o = true;
          const f = a.at(-1);
          (f == null ? void 0 : f.type) === "text" ? (f.raw += u.raw, f.text += u.text) : a.push(u);
          continue;
        }
        if (e) {
          const f = "Infinite loop on byte: " + e.charCodeAt(0);
          if (this.options.silent) {
            console.error(f);
            break;
          } else throw new Error(f);
        }
      }
      return a;
    }
  }, Wu = class {
    constructor(t) {
      __publicField(this, "options");
      __publicField(this, "parser");
      this.options = t || An;
    }
    space(t) {
      return "";
    }
    code({ text: t, lang: e, escaped: a }) {
      var _a2;
      const n = (_a2 = (e || "").match(ii.notSpaceStart)) == null ? void 0 : _a2[0], l = t.replace(ii.endingNewline, "") + `
`;
      return n ? '<pre><code class="language-' + dr(n) + '">' + (a ? l : dr(l, true)) + `</code></pre>
` : "<pre><code>" + (a ? l : dr(l, true)) + `</code></pre>
`;
    }
    blockquote({ tokens: t }) {
      return `<blockquote>
${this.parser.parse(t)}</blockquote>
`;
    }
    html({ text: t }) {
      return t;
    }
    heading({ tokens: t, depth: e }) {
      return `<h${e}>${this.parser.parseInline(t)}</h${e}>
`;
    }
    hr(t) {
      return `<hr>
`;
    }
    list(t) {
      const e = t.ordered, a = t.start;
      let n = "";
      for (let h = 0; h < t.items.length; h++) {
        const u = t.items[h];
        n += this.listitem(u);
      }
      const l = e ? "ol" : "ul", o = e && a !== 1 ? ' start="' + a + '"' : "";
      return "<" + l + o + `>
` + n + "</" + l + `>
`;
    }
    listitem(t) {
      var _a2;
      let e = "";
      if (t.task) {
        const a = this.checkbox({
          checked: !!t.checked
        });
        t.loose ? ((_a2 = t.tokens[0]) == null ? void 0 : _a2.type) === "paragraph" ? (t.tokens[0].text = a + " " + t.tokens[0].text, t.tokens[0].tokens && t.tokens[0].tokens.length > 0 && t.tokens[0].tokens[0].type === "text" && (t.tokens[0].tokens[0].text = a + " " + dr(t.tokens[0].tokens[0].text), t.tokens[0].tokens[0].escaped = true)) : t.tokens.unshift({
          type: "text",
          raw: a + " ",
          text: a + " ",
          escaped: true
        }) : e += a + " ";
      }
      return e += this.parser.parse(t.tokens, !!t.loose), `<li>${e}</li>
`;
    }
    checkbox({ checked: t }) {
      return "<input " + (t ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
    }
    paragraph({ tokens: t }) {
      return `<p>${this.parser.parseInline(t)}</p>
`;
    }
    table(t) {
      let e = "", a = "";
      for (let l = 0; l < t.header.length; l++) a += this.tablecell(t.header[l]);
      e += this.tablerow({
        text: a
      });
      let n = "";
      for (let l = 0; l < t.rows.length; l++) {
        const o = t.rows[l];
        a = "";
        for (let h = 0; h < o.length; h++) a += this.tablecell(o[h]);
        n += this.tablerow({
          text: a
        });
      }
      return n && (n = `<tbody>${n}</tbody>`), `<table>
<thead>
` + e + `</thead>
` + n + `</table>
`;
    }
    tablerow({ text: t }) {
      return `<tr>
${t}</tr>
`;
    }
    tablecell(t) {
      const e = this.parser.parseInline(t.tokens), a = t.header ? "th" : "td";
      return (t.align ? `<${a} align="${t.align}">` : `<${a}>`) + e + `</${a}>
`;
    }
    strong({ tokens: t }) {
      return `<strong>${this.parser.parseInline(t)}</strong>`;
    }
    em({ tokens: t }) {
      return `<em>${this.parser.parseInline(t)}</em>`;
    }
    codespan({ text: t }) {
      return `<code>${dr(t, true)}</code>`;
    }
    br(t) {
      return "<br>";
    }
    del({ tokens: t }) {
      return `<del>${this.parser.parseInline(t)}</del>`;
    }
    link({ href: t, title: e, tokens: a }) {
      const n = this.parser.parseInline(a), l = sx(t);
      if (l === null) return n;
      t = l;
      let o = '<a href="' + t + '"';
      return e && (o += ' title="' + dr(e) + '"'), o += ">" + n + "</a>", o;
    }
    image({ href: t, title: e, text: a, tokens: n }) {
      n && (a = this.parser.parseInline(n, this.parser.textRenderer));
      const l = sx(t);
      if (l === null) return dr(a);
      t = l;
      let o = `<img src="${t}" alt="${a}"`;
      return e && (o += ` title="${dr(e)}"`), o += ">", o;
    }
    text(t) {
      return "tokens" in t && t.tokens ? this.parser.parseInline(t.tokens) : "escaped" in t && t.escaped ? t.text : dr(t.text);
    }
  }, t0 = class {
    strong({ text: t }) {
      return t;
    }
    em({ text: t }) {
      return t;
    }
    codespan({ text: t }) {
      return t;
    }
    del({ text: t }) {
      return t;
    }
    html({ text: t }) {
      return t;
    }
    text({ text: t }) {
      return t;
    }
    link({ text: t }) {
      return "" + t;
    }
    image({ text: t }) {
      return "" + t;
    }
    br() {
      return "";
    }
  }, Wr = class Pp {
    constructor(e) {
      __publicField(this, "options");
      __publicField(this, "renderer");
      __publicField(this, "textRenderer");
      this.options = e || An, this.options.renderer = this.options.renderer || new Wu(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new t0();
    }
    static parse(e, a) {
      return new Pp(a).parse(e);
    }
    static parseInline(e, a) {
      return new Pp(a).parseInline(e);
    }
    parse(e, a = true) {
      var _a2, _b2;
      let n = "";
      for (let l = 0; l < e.length; l++) {
        const o = e[l];
        if ((_b2 = (_a2 = this.options.extensions) == null ? void 0 : _a2.renderers) == null ? void 0 : _b2[o.type]) {
          const u = o, d = this.options.extensions.renderers[u.type].call({
            parser: this
          }, u);
          if (d !== false || ![
            "space",
            "hr",
            "heading",
            "code",
            "table",
            "blockquote",
            "list",
            "html",
            "paragraph",
            "text"
          ].includes(u.type)) {
            n += d || "";
            continue;
          }
        }
        const h = o;
        switch (h.type) {
          case "space": {
            n += this.renderer.space(h);
            continue;
          }
          case "hr": {
            n += this.renderer.hr(h);
            continue;
          }
          case "heading": {
            n += this.renderer.heading(h);
            continue;
          }
          case "code": {
            n += this.renderer.code(h);
            continue;
          }
          case "table": {
            n += this.renderer.table(h);
            continue;
          }
          case "blockquote": {
            n += this.renderer.blockquote(h);
            continue;
          }
          case "list": {
            n += this.renderer.list(h);
            continue;
          }
          case "html": {
            n += this.renderer.html(h);
            continue;
          }
          case "paragraph": {
            n += this.renderer.paragraph(h);
            continue;
          }
          case "text": {
            let u = h, d = this.renderer.text(u);
            for (; l + 1 < e.length && e[l + 1].type === "text"; ) u = e[++l], d += `
` + this.renderer.text(u);
            a ? n += this.renderer.paragraph({
              type: "paragraph",
              raw: d,
              text: d,
              tokens: [
                {
                  type: "text",
                  raw: d,
                  text: d,
                  escaped: true
                }
              ]
            }) : n += d;
            continue;
          }
          default: {
            const u = 'Token with "' + h.type + '" type was not found.';
            if (this.options.silent) return console.error(u), "";
            throw new Error(u);
          }
        }
      }
      return n;
    }
    parseInline(e, a = this.renderer) {
      var _a2, _b2;
      let n = "";
      for (let l = 0; l < e.length; l++) {
        const o = e[l];
        if ((_b2 = (_a2 = this.options.extensions) == null ? void 0 : _a2.renderers) == null ? void 0 : _b2[o.type]) {
          const u = this.options.extensions.renderers[o.type].call({
            parser: this
          }, o);
          if (u !== false || ![
            "escape",
            "html",
            "link",
            "image",
            "strong",
            "em",
            "codespan",
            "br",
            "del",
            "text"
          ].includes(o.type)) {
            n += u || "";
            continue;
          }
        }
        const h = o;
        switch (h.type) {
          case "escape": {
            n += a.text(h);
            break;
          }
          case "html": {
            n += a.html(h);
            break;
          }
          case "link": {
            n += a.link(h);
            break;
          }
          case "image": {
            n += a.image(h);
            break;
          }
          case "strong": {
            n += a.strong(h);
            break;
          }
          case "em": {
            n += a.em(h);
            break;
          }
          case "codespan": {
            n += a.codespan(h);
            break;
          }
          case "br": {
            n += a.br(h);
            break;
          }
          case "del": {
            n += a.del(h);
            break;
          }
          case "text": {
            n += a.text(h);
            break;
          }
          default: {
            const u = 'Token with "' + h.type + '" type was not found.';
            if (this.options.silent) return console.error(u), "";
            throw new Error(u);
          }
        }
      }
      return n;
    }
  }, du = (_i = class {
    constructor(t) {
      __publicField(this, "options");
      __publicField(this, "block");
      this.options = t || An;
    }
    preprocess(t) {
      return t;
    }
    postprocess(t) {
      return t;
    }
    processAllTokens(t) {
      return t;
    }
    provideLexer() {
      return this.block ? Gr.lex : Gr.lexInline;
    }
    provideParser() {
      return this.block ? Wr.parse : Wr.parseInline;
    }
  }, __publicField(_i, "passThroughHooks", /* @__PURE__ */ new Set([
    "preprocess",
    "postprocess",
    "processAllTokens"
  ])), _i), ER = class {
    constructor(...t) {
      __publicField(this, "defaults", Gg());
      __publicField(this, "options", this.setOptions);
      __publicField(this, "parse", this.parseMarkdown(true));
      __publicField(this, "parseInline", this.parseMarkdown(false));
      __publicField(this, "Parser", Wr);
      __publicField(this, "Renderer", Wu);
      __publicField(this, "TextRenderer", t0);
      __publicField(this, "Lexer", Gr);
      __publicField(this, "Tokenizer", Gu);
      __publicField(this, "Hooks", du);
      this.use(...t);
    }
    walkTokens(t, e) {
      var _a2, _b2;
      let a = [];
      for (const n of t) switch (a = a.concat(e.call(this, n)), n.type) {
        case "table": {
          const l = n;
          for (const o of l.header) a = a.concat(this.walkTokens(o.tokens, e));
          for (const o of l.rows) for (const h of o) a = a.concat(this.walkTokens(h.tokens, e));
          break;
        }
        case "list": {
          const l = n;
          a = a.concat(this.walkTokens(l.items, e));
          break;
        }
        default: {
          const l = n;
          ((_b2 = (_a2 = this.defaults.extensions) == null ? void 0 : _a2.childTokens) == null ? void 0 : _b2[l.type]) ? this.defaults.extensions.childTokens[l.type].forEach((o) => {
            const h = l[o].flat(1 / 0);
            a = a.concat(this.walkTokens(h, e));
          }) : l.tokens && (a = a.concat(this.walkTokens(l.tokens, e)));
        }
      }
      return a;
    }
    use(...t) {
      const e = this.defaults.extensions || {
        renderers: {},
        childTokens: {}
      };
      return t.forEach((a) => {
        const n = {
          ...a
        };
        if (n.async = this.defaults.async || n.async || false, a.extensions && (a.extensions.forEach((l) => {
          if (!l.name) throw new Error("extension name required");
          if ("renderer" in l) {
            const o = e.renderers[l.name];
            o ? e.renderers[l.name] = function(...h) {
              let u = l.renderer.apply(this, h);
              return u === false && (u = o.apply(this, h)), u;
            } : e.renderers[l.name] = l.renderer;
          }
          if ("tokenizer" in l) {
            if (!l.level || l.level !== "block" && l.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
            const o = e[l.level];
            o ? o.unshift(l.tokenizer) : e[l.level] = [
              l.tokenizer
            ], l.start && (l.level === "block" ? e.startBlock ? e.startBlock.push(l.start) : e.startBlock = [
              l.start
            ] : l.level === "inline" && (e.startInline ? e.startInline.push(l.start) : e.startInline = [
              l.start
            ]));
          }
          "childTokens" in l && l.childTokens && (e.childTokens[l.name] = l.childTokens);
        }), n.extensions = e), a.renderer) {
          const l = this.defaults.renderer || new Wu(this.defaults);
          for (const o in a.renderer) {
            if (!(o in l)) throw new Error(`renderer '${o}' does not exist`);
            if ([
              "options",
              "parser"
            ].includes(o)) continue;
            const h = o, u = a.renderer[h], d = l[h];
            l[h] = (...f) => {
              let p = u.apply(l, f);
              return p === false && (p = d.apply(l, f)), p || "";
            };
          }
          n.renderer = l;
        }
        if (a.tokenizer) {
          const l = this.defaults.tokenizer || new Gu(this.defaults);
          for (const o in a.tokenizer) {
            if (!(o in l)) throw new Error(`tokenizer '${o}' does not exist`);
            if ([
              "options",
              "rules",
              "lexer"
            ].includes(o)) continue;
            const h = o, u = a.tokenizer[h], d = l[h];
            l[h] = (...f) => {
              let p = u.apply(l, f);
              return p === false && (p = d.apply(l, f)), p;
            };
          }
          n.tokenizer = l;
        }
        if (a.hooks) {
          const l = this.defaults.hooks || new du();
          for (const o in a.hooks) {
            if (!(o in l)) throw new Error(`hook '${o}' does not exist`);
            if ([
              "options",
              "block"
            ].includes(o)) continue;
            const h = o, u = a.hooks[h], d = l[h];
            du.passThroughHooks.has(o) ? l[h] = (f) => {
              if (this.defaults.async) return Promise.resolve(u.call(l, f)).then((m) => d.call(l, m));
              const p = u.call(l, f);
              return d.call(l, p);
            } : l[h] = (...f) => {
              let p = u.apply(l, f);
              return p === false && (p = d.apply(l, f)), p;
            };
          }
          n.hooks = l;
        }
        if (a.walkTokens) {
          const l = this.defaults.walkTokens, o = a.walkTokens;
          n.walkTokens = function(h) {
            let u = [];
            return u.push(o.call(this, h)), l && (u = u.concat(l.call(this, h))), u;
          };
        }
        this.defaults = {
          ...this.defaults,
          ...n
        };
      }), this;
    }
    setOptions(t) {
      return this.defaults = {
        ...this.defaults,
        ...t
      }, this;
    }
    lexer(t, e) {
      return Gr.lex(t, e ?? this.defaults);
    }
    parser(t, e) {
      return Wr.parse(t, e ?? this.defaults);
    }
    parseMarkdown(t) {
      return (a, n) => {
        const l = {
          ...n
        }, o = {
          ...this.defaults,
          ...l
        }, h = this.onError(!!o.silent, !!o.async);
        if (this.defaults.async === true && l.async === false) return h(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
        if (typeof a > "u" || a === null) return h(new Error("marked(): input parameter is undefined or null"));
        if (typeof a != "string") return h(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(a) + ", string expected"));
        o.hooks && (o.hooks.options = o, o.hooks.block = t);
        const u = o.hooks ? o.hooks.provideLexer() : t ? Gr.lex : Gr.lexInline, d = o.hooks ? o.hooks.provideParser() : t ? Wr.parse : Wr.parseInline;
        if (o.async) return Promise.resolve(o.hooks ? o.hooks.preprocess(a) : a).then((f) => u(f, o)).then((f) => o.hooks ? o.hooks.processAllTokens(f) : f).then((f) => o.walkTokens ? Promise.all(this.walkTokens(f, o.walkTokens)).then(() => f) : f).then((f) => d(f, o)).then((f) => o.hooks ? o.hooks.postprocess(f) : f).catch(h);
        try {
          o.hooks && (a = o.hooks.preprocess(a));
          let f = u(a, o);
          o.hooks && (f = o.hooks.processAllTokens(f)), o.walkTokens && this.walkTokens(f, o.walkTokens);
          let p = d(f, o);
          return o.hooks && (p = o.hooks.postprocess(p)), p;
        } catch (f) {
          return h(f);
        }
      };
    }
    onError(t, e) {
      return (a) => {
        if (a.message += `
Please report this to https://github.com/markedjs/marked.`, t) {
          const n = "<p>An error occurred:</p><pre>" + dr(a.message + "", true) + "</pre>";
          return e ? Promise.resolve(n) : n;
        }
        if (e) return Promise.reject(a);
        throw a;
      };
    }
  }, _n = new ER();
  function Gt(t, e) {
    return _n.parse(t, e);
  }
  Gt.options = Gt.setOptions = function(t) {
    return _n.setOptions(t), Gt.defaults = _n.defaults, aS(Gt.defaults), Gt;
  };
  Gt.getDefaults = Gg;
  Gt.defaults = An;
  Gt.use = function(...t) {
    return _n.use(...t), Gt.defaults = _n.defaults, aS(Gt.defaults), Gt;
  };
  Gt.walkTokens = function(t, e) {
    return _n.walkTokens(t, e);
  };
  Gt.parseInline = _n.parseInline;
  Gt.Parser = Wr;
  Gt.parser = Wr.parse;
  Gt.Renderer = Wu;
  Gt.TextRenderer = t0;
  Gt.Lexer = Gr;
  Gt.lexer = Gr.lex;
  Gt.Tokenizer = Gu;
  Gt.Hooks = du;
  Gt.parse = Gt;
  Gt.options;
  Gt.setOptions;
  Gt.use;
  Gt.walkTokens;
  Gt.parseInline;
  Wr.parse;
  Gr.lex;
  function gS(t) {
    for (var e = [], a = 1; a < arguments.length; a++) e[a - 1] = arguments[a];
    var n = Array.from(typeof t == "string" ? [
      t
    ] : t);
    n[n.length - 1] = n[n.length - 1].replace(/\r?\n([\t ]*)$/, "");
    var l = n.reduce(function(u, d) {
      var f = d.match(/\n([\t ]+|(?!\s).)/g);
      return f ? u.concat(f.map(function(p) {
        var m, b;
        return (b = (m = p.match(/[\t ]/g)) === null || m === void 0 ? void 0 : m.length) !== null && b !== void 0 ? b : 0;
      })) : u;
    }, []);
    if (l.length) {
      var o = new RegExp(`
[	 ]{` + Math.min.apply(Math, l) + "}", "g");
      n = n.map(function(u) {
        return u.replace(o, `
`);
      });
    }
    n[0] = n[0].replace(/^\r?\n/, "");
    var h = n[0];
    return e.forEach(function(u, d) {
      var f = h.match(/(?:^|\n)( *)$/), p = f ? f[1] : "", m = u;
      typeof u == "string" && u.includes(`
`) && (m = String(u).split(`
`).map(function(b, x) {
        return x === 0 ? b : "" + p + b;
      }).join(`
`)), h += m + n[d + 1];
    }), h;
  }
  let Gp, mS, yS, LR;
  MR = {
    body: '<g><rect width="80" height="80" style="fill: #087ebf; stroke-width: 0px;"/><text transform="translate(21.16 64.67)" style="fill: #fff; font-family: ArialMT, Arial; font-size: 67.75px;"><tspan x="0" y="0">?</tspan></text></g>',
    height: 80,
    width: 80
  };
  Gp = /* @__PURE__ */ new Map();
  mS = /* @__PURE__ */ new Map();
  BR = v((t) => {
    for (const e of t) {
      if (!e.name) throw new Error('Invalid icon loader. Must have a "name" property with non-empty string value.');
      if (it.debug("Registering icon pack:", e.name), "loader" in e) mS.set(e.name, e.loader);
      else if ("icons" in e) Gp.set(e.name, e.icons);
      else throw it.error("Invalid icon loader:", e), new Error('Invalid icon loader. Must have either "icons" or "loader" property.');
    }
  }, "registerIconPacks");
  yS = v(async (t, e) => {
    const a = L4(t, true, e !== void 0);
    if (!a) throw new Error(`Invalid icon name: ${t}`);
    const n = a.prefix || e;
    if (!n) throw new Error(`Icon name must contain a prefix: ${t}`);
    let l = Gp.get(n);
    if (!l) {
      const h = mS.get(n);
      if (!h) throw new Error(`Icon set not found: ${a.prefix}`);
      try {
        l = {
          ...await h(),
          prefix: n
        }, Gp.set(n, l);
      } catch (u) {
        throw it.error(u), new Error(`Failed to load icon set: ${a.prefix}`);
      }
    }
    const o = R4(l, a.name);
    if (!o) throw new Error(`Icon not found: ${t}`);
    return o;
  }, "getRegisteredIconData");
  LR = v(async (t) => {
    try {
      return await yS(t), true;
    } catch {
      return false;
    }
  }, "isIconAvailable");
  Oo = v(async (t, e, a) => {
    let n;
    try {
      n = await yS(t, e == null ? void 0 : e.fallbackPrefix);
    } catch (h) {
      it.error(h), n = MR;
    }
    const l = U4(n, e), o = G4(P4(l.body), {
      ...l.attributes,
      ...a
    });
    return ji(o, Xe());
  }, "getIconSVG");
  function bS(t, { markdownAutoWrap: e }) {
    const n = t.replace(/<br\/>/g, `
`).replace(/\n{2,}/g, `
`), l = gS(n);
    return e === false ? l.replace(/ /g, "&nbsp;") : l;
  }
  v(bS, "preprocessMarkdown");
  function xS(t, e = {}) {
    const a = bS(t, e), n = Gt.lexer(a), l = [
      []
    ];
    let o = 0;
    function h(u, d = "normal") {
      u.type === "text" ? u.text.split(`
`).forEach((p, m) => {
        m !== 0 && (o++, l.push([])), p.split(" ").forEach((b) => {
          b = b.replace(/&#39;/g, "'"), b && l[o].push({
            content: b,
            type: d
          });
        });
      }) : u.type === "strong" || u.type === "em" ? u.tokens.forEach((f) => {
        h(f, u.type);
      }) : u.type === "html" && l[o].push({
        content: u.text,
        type: "normal"
      });
    }
    return v(h, "processNode"), n.forEach((u) => {
      var _a2;
      u.type === "paragraph" ? (_a2 = u.tokens) == null ? void 0 : _a2.forEach((d) => {
        h(d);
      }) : u.type === "html" ? l[o].push({
        content: u.text,
        type: "normal"
      }) : l[o].push({
        content: u.raw,
        type: "normal"
      });
    }), l;
  }
  v(xS, "markdownToLines");
  function vS(t, { markdownAutoWrap: e } = {}) {
    const a = Gt.lexer(t);
    function n(l) {
      var _a2, _b2, _c2;
      return l.type === "text" ? e === false ? l.text.replace(/\n */g, "<br/>").replace(/ /g, "&nbsp;") : l.text.replace(/\n */g, "<br/>") : l.type === "strong" ? `<strong>${(_a2 = l.tokens) == null ? void 0 : _a2.map(n).join("")}</strong>` : l.type === "em" ? `<em>${(_b2 = l.tokens) == null ? void 0 : _b2.map(n).join("")}</em>` : l.type === "paragraph" ? `<p>${(_c2 = l.tokens) == null ? void 0 : _c2.map(n).join("")}</p>` : l.type === "space" ? "" : l.type === "html" ? `${l.text}` : l.type === "escape" ? l.text : (it.warn(`Unsupported markdown: ${l.type}`), l.raw);
    }
    return v(n, "output"), a.map(n).join("");
  }
  v(vS, "markdownToHTML");
  function _S(t) {
    return Intl.Segmenter ? [
      ...new Intl.Segmenter().segment(t)
    ].map((e) => e.segment) : [
      ...t
    ];
  }
  v(_S, "splitTextToChars");
  function SS(t, e) {
    const a = _S(e.content);
    return e0(t, [], a, e.type);
  }
  v(SS, "splitWordToFitWidth");
  function e0(t, e, a, n) {
    if (a.length === 0) return [
      {
        content: e.join(""),
        type: n
      },
      {
        content: "",
        type: n
      }
    ];
    const [l, ...o] = a, h = [
      ...e,
      l
    ];
    return t([
      {
        content: h.join(""),
        type: n
      }
    ]) ? e0(t, h, o, n) : (e.length === 0 && l && (e.push(l), a.shift()), [
      {
        content: e.join(""),
        type: n
      },
      {
        content: a.join(""),
        type: n
      }
    ]);
  }
  v(e0, "splitWordToFitWidthRecursion");
  function CS(t, e) {
    if (t.some(({ content: a }) => a.includes(`
`))) throw new Error("splitLineToFitWidth does not support newlines in the line");
    return Xu(t, e);
  }
  v(CS, "splitLineToFitWidth");
  function Xu(t, e, a = [], n = []) {
    if (t.length === 0) return n.length > 0 && a.push(n), a.length > 0 ? a : [];
    let l = "";
    t[0].content === " " && (l = " ", t.shift());
    const o = t.shift() ?? {
      content: " ",
      type: "normal"
    }, h = [
      ...n
    ];
    if (l !== "" && h.push({
      content: l,
      type: "normal"
    }), h.push(o), e(h)) return Xu(t, e, a, h);
    if (n.length > 0) a.push(n), t.unshift(o);
    else if (o.content) {
      const [u, d] = SS(e, o);
      a.push([
        u
      ]), d.content && t.unshift(d);
    }
    return Xu(t, e, a);
  }
  v(Xu, "splitLineToFitWidthRecursion");
  function Wp(t, e) {
    e && t.attr("style", e);
  }
  v(Wp, "applyStyle");
  async function wS(t, e, a, n, l = false, o = Xe()) {
    const h = t.append("foreignObject");
    h.attr("width", `${10 * a}px`), h.attr("height", `${10 * a}px`);
    const u = h.append("xhtml:div"), d = _l(e.label) ? await ug(e.label.replace(El.lineBreakRegex, `
`), o) : ji(e.label, o), f = e.isNode ? "nodeLabel" : "edgeLabel", p = u.append("span");
    p.html(d), Wp(p, e.labelStyle), p.attr("class", `${f} ${n}`), Wp(u, e.labelStyle), u.style("display", "table-cell"), u.style("white-space", "nowrap"), u.style("line-height", "1.5"), u.style("max-width", a + "px"), u.style("text-align", "center"), u.attr("xmlns", "http://www.w3.org/1999/xhtml"), l && u.attr("class", "labelBkg");
    let m = u.node().getBoundingClientRect();
    return m.width === a && (u.style("display", "table"), u.style("white-space", "break-spaces"), u.style("width", a + "px"), m = u.node().getBoundingClientRect()), h.node();
  }
  v(wS, "addHtmlSpan");
  function vh(t, e, a) {
    return t.append("tspan").attr("class", "text-outer-tspan").attr("x", 0).attr("y", e * a - 0.1 + "em").attr("dy", a + "em");
  }
  v(vh, "createTspan");
  function TS(t, e, a) {
    const n = t.append("text"), l = vh(n, 1, e);
    _h(l, a);
    const o = l.node().getComputedTextLength();
    return n.remove(), o;
  }
  v(TS, "computeWidthOfText");
  OR = function(t, e, a) {
    var _a2;
    const n = t.append("text"), l = vh(n, 1, e);
    _h(l, [
      {
        content: a,
        type: "normal"
      }
    ]);
    const o = (_a2 = l.node()) == null ? void 0 : _a2.getBoundingClientRect();
    return o && n.remove(), o;
  };
  v(OR, "computeDimensionOfText");
  function kS(t, e, a, n = false) {
    const o = e.append("g"), h = o.insert("rect").attr("class", "background").attr("style", "stroke: none"), u = o.append("text").attr("y", "-10.1");
    let d = 0;
    for (const f of a) {
      const p = v((b) => TS(o, 1.1, b) <= t, "checkWidth"), m = p(f) ? [
        f
      ] : CS(f, p);
      for (const b of m) {
        const x = vh(u, d, 1.1);
        _h(x, b), d++;
      }
    }
    if (n) {
      const f = u.node().getBBox(), p = 2;
      return h.attr("x", f.x - p).attr("y", f.y - p).attr("width", f.width + 2 * p).attr("height", f.height + 2 * p), o.node();
    } else return u.node();
  }
  v(kS, "createFormattedText");
  function _h(t, e) {
    t.text(""), e.forEach((a, n) => {
      const l = t.append("tspan").attr("font-style", a.type === "em" ? "italic" : "normal").attr("class", "text-inner-tspan").attr("font-weight", a.type === "strong" ? "bold" : "normal");
      n === 0 ? l.text(a.content) : l.text(" " + a.content);
    });
  }
  v(_h, "updateTextContentAndStyles");
  AS = async function(t, e = {}) {
    const a = [];
    t.replace(/(fa[bklrs]?):fa-([\w-]+)/g, (l, o, h) => (a.push((async () => {
      const u = `${o}:${h}`;
      return await LR(u) ? await Oo(u, void 0, {
        class: "label-icon"
      }) : `<i class='${ji(l, e).replace(":", " ")}'></i>`;
    })()), l));
    const n = await Promise.all(a);
    return t.replace(/(fa[bklrs]?):fa-([\w-]+)/g, () => n.shift() ?? "");
  };
  v(AS, "replaceIconSubstring");
  $a = v(async (t, e = "", { style: a = "", isTitle: n = false, classes: l = "", useHtmlLabels: o = true, isNode: h = true, width: u = 200, addSvgBackground: d = false } = {}, f) => {
    if (it.debug("XYZ createText", e, a, n, l, o, h, "addSvgBackground: ", d), o) {
      const p = vS(e, f), m = await AS(kn(p), f), b = e.replace(/\\\\/g, "\\"), x = {
        isNode: h,
        label: _l(e) ? b : m,
        labelStyle: a.replace("fill:", "color:")
      };
      return await wS(t, x, u, l, d, f);
    } else {
      const p = e.replace(/<br\s*\/?>/g, "<br/>"), m = xS(p.replace("<br>", "<br/>"), f), b = kS(u, t, m, e ? d : false);
      if (h) {
        /stroke:/.exec(a) && (a = a.replace("stroke:", "lineColor:"));
        const x = a.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/color:/g, "fill:");
        jt(b).attr("style", x);
      } else {
        const x = a.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/background:/g, "fill:");
        jt(b).select("rect").attr("style", x.replace(/background:/g, "fill:"));
        const _ = a.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/color:/g, "fill:");
        jt(b).select("text").attr("style", _);
      }
      return b;
    }
  }, "createText");
  function ep(t, e, a) {
    if (t && t.length) {
      const [n, l] = e, o = Math.PI / 180 * a, h = Math.cos(o), u = Math.sin(o);
      for (const d of t) {
        const [f, p] = d;
        d[0] = (f - n) * h - (p - l) * u + n, d[1] = (f - n) * u + (p - l) * h + l;
      }
    }
  }
  function DR(t, e) {
    return t[0] === e[0] && t[1] === e[1];
  }
  function RR(t, e, a, n = 1) {
    const l = a, o = Math.max(e, 0.1), h = t[0] && t[0][0] && typeof t[0][0] == "number" ? [
      t
    ] : t, u = [
      0,
      0
    ];
    if (l) for (const f of h) ep(f, u, l);
    const d = (function(f, p, m) {
      const b = [];
      for (const A of f) {
        const L = [
          ...A
        ];
        DR(L[0], L[L.length - 1]) || L.push([
          L[0][0],
          L[0][1]
        ]), L.length > 2 && b.push(L);
      }
      const x = [];
      p = Math.max(p, 0.1);
      const _ = [];
      for (const A of b) for (let L = 0; L < A.length - 1; L++) {
        const $ = A[L], O = A[L + 1];
        if ($[1] !== O[1]) {
          const W = Math.min($[1], O[1]);
          _.push({
            ymin: W,
            ymax: Math.max($[1], O[1]),
            x: W === $[1] ? $[0] : O[0],
            islope: (O[0] - $[0]) / (O[1] - $[1])
          });
        }
      }
      if (_.sort(((A, L) => A.ymin < L.ymin ? -1 : A.ymin > L.ymin ? 1 : A.x < L.x ? -1 : A.x > L.x ? 1 : A.ymax === L.ymax ? 0 : (A.ymax - L.ymax) / Math.abs(A.ymax - L.ymax))), !_.length) return x;
      let S = [], w = _[0].ymin, k = 0;
      for (; S.length || _.length; ) {
        if (_.length) {
          let A = -1;
          for (let L = 0; L < _.length && !(_[L].ymin > w); L++) A = L;
          _.splice(0, A + 1).forEach(((L) => {
            S.push({
              s: w,
              edge: L
            });
          }));
        }
        if (S = S.filter(((A) => !(A.edge.ymax <= w))), S.sort(((A, L) => A.edge.x === L.edge.x ? 0 : (A.edge.x - L.edge.x) / Math.abs(A.edge.x - L.edge.x))), (m !== 1 || k % p == 0) && S.length > 1) for (let A = 0; A < S.length; A += 2) {
          const L = A + 1;
          if (L >= S.length) break;
          const $ = S[A].edge, O = S[L].edge;
          x.push([
            [
              Math.round($.x),
              w
            ],
            [
              Math.round(O.x),
              w
            ]
          ]);
        }
        w += m, S.forEach(((A) => {
          A.edge.x = A.edge.x + m * A.edge.islope;
        })), k++;
      }
      return x;
    })(h, o, n);
    if (l) {
      for (const f of h) ep(f, u, -l);
      (function(f, p, m) {
        const b = [];
        f.forEach(((x) => b.push(...x))), ep(b, p, m);
      })(d, u, -l);
    }
    return d;
  }
  function Do(t, e) {
    var a;
    const n = e.hachureAngle + 90;
    let l = e.hachureGap;
    l < 0 && (l = 4 * e.strokeWidth), l = Math.round(Math.max(l, 0.1));
    let o = 1;
    return e.roughness >= 1 && (((a = e.randomizer) === null || a === void 0 ? void 0 : a.next()) || Math.random()) > 0.7 && (o = l), RR(t, l, n, o || 1);
  }
  class i0 {
    constructor(e) {
      this.helper = e;
    }
    fillPolygons(e, a) {
      return this._fillPolygons(e, a);
    }
    _fillPolygons(e, a) {
      const n = Do(e, a);
      return {
        type: "fillSketch",
        ops: this.renderLines(n, a)
      };
    }
    renderLines(e, a) {
      const n = [];
      for (const l of e) n.push(...this.helper.doubleLineOps(l[0][0], l[0][1], l[1][0], l[1][1], a));
      return n;
    }
  }
  function Sh(t) {
    const e = t[0], a = t[1];
    return Math.sqrt(Math.pow(e[0] - a[0], 2) + Math.pow(e[1] - a[1], 2));
  }
  class $R extends i0 {
    fillPolygons(e, a) {
      let n = a.hachureGap;
      n < 0 && (n = 4 * a.strokeWidth), n = Math.max(n, 0.1);
      const l = Do(e, Object.assign({}, a, {
        hachureGap: n
      })), o = Math.PI / 180 * a.hachureAngle, h = [], u = 0.5 * n * Math.cos(o), d = 0.5 * n * Math.sin(o);
      for (const [f, p] of l) Sh([
        f,
        p
      ]) && h.push([
        [
          f[0] - u,
          f[1] + d
        ],
        [
          ...p
        ]
      ], [
        [
          f[0] + u,
          f[1] - d
        ],
        [
          ...p
        ]
      ]);
      return {
        type: "fillSketch",
        ops: this.renderLines(h, a)
      };
    }
  }
  class NR extends i0 {
    fillPolygons(e, a) {
      const n = this._fillPolygons(e, a), l = Object.assign({}, a, {
        hachureAngle: a.hachureAngle + 90
      }), o = this._fillPolygons(e, l);
      return n.ops = n.ops.concat(o.ops), n;
    }
  }
  class zR {
    constructor(e) {
      this.helper = e;
    }
    fillPolygons(e, a) {
      const n = Do(e, a = Object.assign({}, a, {
        hachureAngle: 0
      }));
      return this.dotsOnLines(n, a);
    }
    dotsOnLines(e, a) {
      const n = [];
      let l = a.hachureGap;
      l < 0 && (l = 4 * a.strokeWidth), l = Math.max(l, 0.1);
      let o = a.fillWeight;
      o < 0 && (o = a.strokeWidth / 2);
      const h = l / 4;
      for (const u of e) {
        const d = Sh(u), f = d / l, p = Math.ceil(f) - 1, m = d - p * l, b = (u[0][0] + u[1][0]) / 2 - l / 4, x = Math.min(u[0][1], u[1][1]);
        for (let _ = 0; _ < p; _++) {
          const S = x + m + _ * l, w = b - h + 2 * Math.random() * h, k = S - h + 2 * Math.random() * h, A = this.helper.ellipse(w, k, o, o, a);
          n.push(...A.ops);
        }
      }
      return {
        type: "fillSketch",
        ops: n
      };
    }
  }
  class FR {
    constructor(e) {
      this.helper = e;
    }
    fillPolygons(e, a) {
      const n = Do(e, a);
      return {
        type: "fillSketch",
        ops: this.dashedLine(n, a)
      };
    }
    dashedLine(e, a) {
      const n = a.dashOffset < 0 ? a.hachureGap < 0 ? 4 * a.strokeWidth : a.hachureGap : a.dashOffset, l = a.dashGap < 0 ? a.hachureGap < 0 ? 4 * a.strokeWidth : a.hachureGap : a.dashGap, o = [];
      return e.forEach(((h) => {
        const u = Sh(h), d = Math.floor(u / (n + l)), f = (u + l - d * (n + l)) / 2;
        let p = h[0], m = h[1];
        p[0] > m[0] && (p = h[1], m = h[0]);
        const b = Math.atan((m[1] - p[1]) / (m[0] - p[0]));
        for (let x = 0; x < d; x++) {
          const _ = x * (n + l), S = _ + n, w = [
            p[0] + _ * Math.cos(b) + f * Math.cos(b),
            p[1] + _ * Math.sin(b) + f * Math.sin(b)
          ], k = [
            p[0] + S * Math.cos(b) + f * Math.cos(b),
            p[1] + S * Math.sin(b) + f * Math.sin(b)
          ];
          o.push(...this.helper.doubleLineOps(w[0], w[1], k[0], k[1], a));
        }
      })), o;
    }
  }
  class qR {
    constructor(e) {
      this.helper = e;
    }
    fillPolygons(e, a) {
      const n = a.hachureGap < 0 ? 4 * a.strokeWidth : a.hachureGap, l = a.zigzagOffset < 0 ? n : a.zigzagOffset, o = Do(e, a = Object.assign({}, a, {
        hachureGap: n + l
      }));
      return {
        type: "fillSketch",
        ops: this.zigzagLines(o, l, a)
      };
    }
    zigzagLines(e, a, n) {
      const l = [];
      return e.forEach(((o) => {
        const h = Sh(o), u = Math.round(h / (2 * a));
        let d = o[0], f = o[1];
        d[0] > f[0] && (d = o[1], f = o[0]);
        const p = Math.atan((f[1] - d[1]) / (f[0] - d[0]));
        for (let m = 0; m < u; m++) {
          const b = 2 * m * a, x = 2 * (m + 1) * a, _ = Math.sqrt(2 * Math.pow(a, 2)), S = [
            d[0] + b * Math.cos(p),
            d[1] + b * Math.sin(p)
          ], w = [
            d[0] + x * Math.cos(p),
            d[1] + x * Math.sin(p)
          ], k = [
            S[0] + _ * Math.cos(p + Math.PI / 4),
            S[1] + _ * Math.sin(p + Math.PI / 4)
          ];
          l.push(...this.helper.doubleLineOps(S[0], S[1], k[0], k[1], n), ...this.helper.doubleLineOps(k[0], k[1], w[0], w[1], n));
        }
      })), l;
    }
  }
  const fi = {};
  class HR {
    constructor(e) {
      this.seed = e;
    }
    next() {
      return this.seed ? (2 ** 31 - 1 & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31 : Math.random();
    }
  }
  const UR = 0, ip = 1, ux = 2, Jc = {
    A: 7,
    a: 7,
    C: 6,
    c: 6,
    H: 1,
    h: 1,
    L: 2,
    l: 2,
    M: 2,
    m: 2,
    Q: 4,
    q: 4,
    S: 4,
    s: 4,
    T: 2,
    t: 2,
    V: 1,
    v: 1,
    Z: 0,
    z: 0
  };
  function rp(t, e) {
    return t.type === e;
  }
  function r0(t) {
    const e = [], a = (function(h) {
      const u = new Array();
      for (; h !== ""; ) if (h.match(/^([ \t\r\n,]+)/)) h = h.substr(RegExp.$1.length);
      else if (h.match(/^([aAcChHlLmMqQsStTvVzZ])/)) u[u.length] = {
        type: UR,
        text: RegExp.$1
      }, h = h.substr(RegExp.$1.length);
      else {
        if (!h.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/)) return [];
        u[u.length] = {
          type: ip,
          text: `${parseFloat(RegExp.$1)}`
        }, h = h.substr(RegExp.$1.length);
      }
      return u[u.length] = {
        type: ux,
        text: ""
      }, u;
    })(t);
    let n = "BOD", l = 0, o = a[l];
    for (; !rp(o, ux); ) {
      let h = 0;
      const u = [];
      if (n === "BOD") {
        if (o.text !== "M" && o.text !== "m") return r0("M0,0" + t);
        l++, h = Jc[o.text], n = o.text;
      } else rp(o, ip) ? h = Jc[n] : (l++, h = Jc[o.text], n = o.text);
      if (!(l + h < a.length)) throw new Error("Path data ended short");
      for (let d = l; d < l + h; d++) {
        const f = a[d];
        if (!rp(f, ip)) throw new Error("Param not a number: " + n + "," + f.text);
        u[u.length] = +f.text;
      }
      if (typeof Jc[n] != "number") throw new Error("Bad segment: " + n);
      {
        const d = {
          key: n,
          data: u
        };
        e.push(d), l += h, o = a[l], n === "M" && (n = "L"), n === "m" && (n = "l");
      }
    }
    return e;
  }
  function ES(t) {
    let e = 0, a = 0, n = 0, l = 0;
    const o = [];
    for (const { key: h, data: u } of t) switch (h) {
      case "M":
        o.push({
          key: "M",
          data: [
            ...u
          ]
        }), [e, a] = u, [n, l] = u;
        break;
      case "m":
        e += u[0], a += u[1], o.push({
          key: "M",
          data: [
            e,
            a
          ]
        }), n = e, l = a;
        break;
      case "L":
        o.push({
          key: "L",
          data: [
            ...u
          ]
        }), [e, a] = u;
        break;
      case "l":
        e += u[0], a += u[1], o.push({
          key: "L",
          data: [
            e,
            a
          ]
        });
        break;
      case "C":
        o.push({
          key: "C",
          data: [
            ...u
          ]
        }), e = u[4], a = u[5];
        break;
      case "c": {
        const d = u.map(((f, p) => p % 2 ? f + a : f + e));
        o.push({
          key: "C",
          data: d
        }), e = d[4], a = d[5];
        break;
      }
      case "Q":
        o.push({
          key: "Q",
          data: [
            ...u
          ]
        }), e = u[2], a = u[3];
        break;
      case "q": {
        const d = u.map(((f, p) => p % 2 ? f + a : f + e));
        o.push({
          key: "Q",
          data: d
        }), e = d[2], a = d[3];
        break;
      }
      case "A":
        o.push({
          key: "A",
          data: [
            ...u
          ]
        }), e = u[5], a = u[6];
        break;
      case "a":
        e += u[5], a += u[6], o.push({
          key: "A",
          data: [
            u[0],
            u[1],
            u[2],
            u[3],
            u[4],
            e,
            a
          ]
        });
        break;
      case "H":
        o.push({
          key: "H",
          data: [
            ...u
          ]
        }), e = u[0];
        break;
      case "h":
        e += u[0], o.push({
          key: "H",
          data: [
            e
          ]
        });
        break;
      case "V":
        o.push({
          key: "V",
          data: [
            ...u
          ]
        }), a = u[0];
        break;
      case "v":
        a += u[0], o.push({
          key: "V",
          data: [
            a
          ]
        });
        break;
      case "S":
        o.push({
          key: "S",
          data: [
            ...u
          ]
        }), e = u[2], a = u[3];
        break;
      case "s": {
        const d = u.map(((f, p) => p % 2 ? f + a : f + e));
        o.push({
          key: "S",
          data: d
        }), e = d[2], a = d[3];
        break;
      }
      case "T":
        o.push({
          key: "T",
          data: [
            ...u
          ]
        }), e = u[0], a = u[1];
        break;
      case "t":
        e += u[0], a += u[1], o.push({
          key: "T",
          data: [
            e,
            a
          ]
        });
        break;
      case "Z":
      case "z":
        o.push({
          key: "Z",
          data: []
        }), e = n, a = l;
    }
    return o;
  }
  function MS(t) {
    const e = [];
    let a = "", n = 0, l = 0, o = 0, h = 0, u = 0, d = 0;
    for (const { key: f, data: p } of t) {
      switch (f) {
        case "M":
          e.push({
            key: "M",
            data: [
              ...p
            ]
          }), [n, l] = p, [o, h] = p;
          break;
        case "C":
          e.push({
            key: "C",
            data: [
              ...p
            ]
          }), n = p[4], l = p[5], u = p[2], d = p[3];
          break;
        case "L":
          e.push({
            key: "L",
            data: [
              ...p
            ]
          }), [n, l] = p;
          break;
        case "H":
          n = p[0], e.push({
            key: "L",
            data: [
              n,
              l
            ]
          });
          break;
        case "V":
          l = p[0], e.push({
            key: "L",
            data: [
              n,
              l
            ]
          });
          break;
        case "S": {
          let m = 0, b = 0;
          a === "C" || a === "S" ? (m = n + (n - u), b = l + (l - d)) : (m = n, b = l), e.push({
            key: "C",
            data: [
              m,
              b,
              ...p
            ]
          }), u = p[0], d = p[1], n = p[2], l = p[3];
          break;
        }
        case "T": {
          const [m, b] = p;
          let x = 0, _ = 0;
          a === "Q" || a === "T" ? (x = n + (n - u), _ = l + (l - d)) : (x = n, _ = l);
          const S = n + 2 * (x - n) / 3, w = l + 2 * (_ - l) / 3, k = m + 2 * (x - m) / 3, A = b + 2 * (_ - b) / 3;
          e.push({
            key: "C",
            data: [
              S,
              w,
              k,
              A,
              m,
              b
            ]
          }), u = x, d = _, n = m, l = b;
          break;
        }
        case "Q": {
          const [m, b, x, _] = p, S = n + 2 * (m - n) / 3, w = l + 2 * (b - l) / 3, k = x + 2 * (m - x) / 3, A = _ + 2 * (b - _) / 3;
          e.push({
            key: "C",
            data: [
              S,
              w,
              k,
              A,
              x,
              _
            ]
          }), u = m, d = b, n = x, l = _;
          break;
        }
        case "A": {
          const m = Math.abs(p[0]), b = Math.abs(p[1]), x = p[2], _ = p[3], S = p[4], w = p[5], k = p[6];
          m === 0 || b === 0 ? (e.push({
            key: "C",
            data: [
              n,
              l,
              w,
              k,
              w,
              k
            ]
          }), n = w, l = k) : (n !== w || l !== k) && (BS(n, l, w, k, m, b, x, _, S).forEach((function(A) {
            e.push({
              key: "C",
              data: A
            });
          })), n = w, l = k);
          break;
        }
        case "Z":
          e.push({
            key: "Z",
            data: []
          }), n = o, l = h;
      }
      a = f;
    }
    return e;
  }
  function Ws(t, e, a) {
    return [
      t * Math.cos(a) - e * Math.sin(a),
      t * Math.sin(a) + e * Math.cos(a)
    ];
  }
  function BS(t, e, a, n, l, o, h, u, d, f) {
    const p = (m = h, Math.PI * m / 180);
    var m;
    let b = [], x = 0, _ = 0, S = 0, w = 0;
    if (f) [x, _, S, w] = f;
    else {
      [t, e] = Ws(t, e, -p), [a, n] = Ws(a, n, -p);
      const rt = (t - a) / 2, V = (e - n) / 2;
      let G = rt * rt / (l * l) + V * V / (o * o);
      G > 1 && (G = Math.sqrt(G), l *= G, o *= G);
      const E = l * l, N = o * o, F = E * N - E * V * V - N * rt * rt, ot = E * V * V + N * rt * rt, M = (u === d ? -1 : 1) * Math.sqrt(Math.abs(F / ot));
      S = M * l * V / o + (t + a) / 2, w = M * -o * rt / l + (e + n) / 2, x = Math.asin(parseFloat(((e - w) / o).toFixed(9))), _ = Math.asin(parseFloat(((n - w) / o).toFixed(9))), t < S && (x = Math.PI - x), a < S && (_ = Math.PI - _), x < 0 && (x = 2 * Math.PI + x), _ < 0 && (_ = 2 * Math.PI + _), d && x > _ && (x -= 2 * Math.PI), !d && _ > x && (_ -= 2 * Math.PI);
    }
    let k = _ - x;
    if (Math.abs(k) > 120 * Math.PI / 180) {
      const rt = _, V = a, G = n;
      _ = d && _ > x ? x + 120 * Math.PI / 180 * 1 : x + 120 * Math.PI / 180 * -1, b = BS(a = S + l * Math.cos(_), n = w + o * Math.sin(_), V, G, l, o, h, 0, d, [
        _,
        rt,
        S,
        w
      ]);
    }
    k = _ - x;
    const A = Math.cos(x), L = Math.sin(x), $ = Math.cos(_), O = Math.sin(_), W = Math.tan(k / 4), j = 4 / 3 * l * W, et = 4 / 3 * o * W, nt = [
      t,
      e
    ], lt = [
      t + j * L,
      e - et * A
    ], X = [
      a + j * O,
      n - et * $
    ], at = [
      a,
      n
    ];
    if (lt[0] = 2 * nt[0] - lt[0], lt[1] = 2 * nt[1] - lt[1], f) return [
      lt,
      X,
      at
    ].concat(b);
    {
      b = [
        lt,
        X,
        at
      ].concat(b);
      const rt = [];
      for (let V = 0; V < b.length; V += 3) {
        const G = Ws(b[V][0], b[V][1], p), E = Ws(b[V + 1][0], b[V + 1][1], p), N = Ws(b[V + 2][0], b[V + 2][1], p);
        rt.push([
          G[0],
          G[1],
          E[0],
          E[1],
          N[0],
          N[1]
        ]);
      }
      return rt;
    }
  }
  const jR = {
    randOffset: function(t, e) {
      return Mt(t, e);
    },
    randOffsetWithRange: function(t, e, a) {
      return Vu(t, e, a);
    },
    ellipse: function(t, e, a, n, l) {
      const o = OS(a, n, l);
      return Xp(t, e, l, o).opset;
    },
    doubleLineOps: function(t, e, a, n, l) {
      return Oa(t, e, a, n, l, true);
    }
  };
  function LS(t, e, a, n, l) {
    return {
      type: "path",
      ops: Oa(t, e, a, n, l)
    };
  }
  function pu(t, e, a) {
    const n = (t || []).length;
    if (n > 2) {
      const l = [];
      for (let o = 0; o < n - 1; o++) l.push(...Oa(t[o][0], t[o][1], t[o + 1][0], t[o + 1][1], a));
      return e && l.push(...Oa(t[n - 1][0], t[n - 1][1], t[0][0], t[0][1], a)), {
        type: "path",
        ops: l
      };
    }
    return n === 2 ? LS(t[0][0], t[0][1], t[1][0], t[1][1], a) : {
      type: "path",
      ops: []
    };
  }
  function YR(t, e, a, n, l) {
    return (function(o, h) {
      return pu(o, true, h);
    })([
      [
        t,
        e
      ],
      [
        t + a,
        e
      ],
      [
        t + a,
        e + n
      ],
      [
        t,
        e + n
      ]
    ], l);
  }
  function hx(t, e) {
    if (t.length) {
      const a = typeof t[0][0] == "number" ? [
        t
      ] : t, n = tu(a[0], 1 * (1 + 0.2 * e.roughness), e), l = e.disableMultiStroke ? [] : tu(a[0], 1.5 * (1 + 0.22 * e.roughness), px(e));
      for (let o = 1; o < a.length; o++) {
        const h = a[o];
        if (h.length) {
          const u = tu(h, 1 * (1 + 0.2 * e.roughness), e), d = e.disableMultiStroke ? [] : tu(h, 1.5 * (1 + 0.22 * e.roughness), px(e));
          for (const f of u) f.op !== "move" && n.push(f);
          for (const f of d) f.op !== "move" && l.push(f);
        }
      }
      return {
        type: "path",
        ops: n.concat(l)
      };
    }
    return {
      type: "path",
      ops: []
    };
  }
  function OS(t, e, a) {
    const n = Math.sqrt(2 * Math.PI * Math.sqrt((Math.pow(t / 2, 2) + Math.pow(e / 2, 2)) / 2)), l = Math.ceil(Math.max(a.curveStepCount, a.curveStepCount / Math.sqrt(200) * n)), o = 2 * Math.PI / l;
    let h = Math.abs(t / 2), u = Math.abs(e / 2);
    const d = 1 - a.curveFitting;
    return h += Mt(h * d, a), u += Mt(u * d, a), {
      increment: o,
      rx: h,
      ry: u
    };
  }
  function Xp(t, e, a, n) {
    const [l, o] = gx(n.increment, t, e, n.rx, n.ry, 1, n.increment * Vu(0.1, Vu(0.4, 1, a), a), a);
    let h = Zu(l, null, a);
    if (!a.disableMultiStroke && a.roughness !== 0) {
      const [u] = gx(n.increment, t, e, n.rx, n.ry, 1.5, 0, a), d = Zu(u, null, a);
      h = h.concat(d);
    }
    return {
      estimatedPoints: o,
      opset: {
        type: "path",
        ops: h
      }
    };
  }
  function fx(t, e, a, n, l, o, h, u, d) {
    const f = t, p = e;
    let m = Math.abs(a / 2), b = Math.abs(n / 2);
    m += Mt(0.01 * m, d), b += Mt(0.01 * b, d);
    let x = l, _ = o;
    for (; x < 0; ) x += 2 * Math.PI, _ += 2 * Math.PI;
    _ - x > 2 * Math.PI && (x = 0, _ = 2 * Math.PI);
    const S = 2 * Math.PI / d.curveStepCount, w = Math.min(S / 2, (_ - x) / 2), k = mx(w, f, p, m, b, x, _, 1, d);
    if (!d.disableMultiStroke) {
      const A = mx(w, f, p, m, b, x, _, 1.5, d);
      k.push(...A);
    }
    return h && (u ? k.push(...Oa(f, p, f + m * Math.cos(x), p + b * Math.sin(x), d), ...Oa(f, p, f + m * Math.cos(_), p + b * Math.sin(_), d)) : k.push({
      op: "lineTo",
      data: [
        f,
        p
      ]
    }, {
      op: "lineTo",
      data: [
        f + m * Math.cos(x),
        p + b * Math.sin(x)
      ]
    })), {
      type: "path",
      ops: k
    };
  }
  function dx(t, e) {
    const a = MS(ES(r0(t))), n = [];
    let l = [
      0,
      0
    ], o = [
      0,
      0
    ];
    for (const { key: h, data: u } of a) switch (h) {
      case "M":
        o = [
          u[0],
          u[1]
        ], l = [
          u[0],
          u[1]
        ];
        break;
      case "L":
        n.push(...Oa(o[0], o[1], u[0], u[1], e)), o = [
          u[0],
          u[1]
        ];
        break;
      case "C": {
        const [d, f, p, m, b, x] = u;
        n.push(...IR(d, f, p, m, b, x, o, e)), o = [
          b,
          x
        ];
        break;
      }
      case "Z":
        n.push(...Oa(o[0], o[1], l[0], l[1], e)), o = [
          l[0],
          l[1]
        ];
    }
    return {
      type: "path",
      ops: n
    };
  }
  function ap(t, e) {
    const a = [];
    for (const n of t) if (n.length) {
      const l = e.maxRandomnessOffset || 0, o = n.length;
      if (o > 2) {
        a.push({
          op: "move",
          data: [
            n[0][0] + Mt(l, e),
            n[0][1] + Mt(l, e)
          ]
        });
        for (let h = 1; h < o; h++) a.push({
          op: "lineTo",
          data: [
            n[h][0] + Mt(l, e),
            n[h][1] + Mt(l, e)
          ]
        });
      }
    }
    return {
      type: "fillPath",
      ops: a
    };
  }
  function fl(t, e) {
    return (function(a, n) {
      let l = a.fillStyle || "hachure";
      if (!fi[l]) switch (l) {
        case "zigzag":
          fi[l] || (fi[l] = new $R(n));
          break;
        case "cross-hatch":
          fi[l] || (fi[l] = new NR(n));
          break;
        case "dots":
          fi[l] || (fi[l] = new zR(n));
          break;
        case "dashed":
          fi[l] || (fi[l] = new FR(n));
          break;
        case "zigzag-line":
          fi[l] || (fi[l] = new qR(n));
          break;
        default:
          l = "hachure", fi[l] || (fi[l] = new i0(n));
      }
      return fi[l];
    })(e, jR).fillPolygons(t, e);
  }
  function px(t) {
    const e = Object.assign({}, t);
    return e.randomizer = void 0, t.seed && (e.seed = t.seed + 1), e;
  }
  function DS(t) {
    return t.randomizer || (t.randomizer = new HR(t.seed || 0)), t.randomizer.next();
  }
  function Vu(t, e, a, n = 1) {
    return a.roughness * n * (DS(a) * (e - t) + t);
  }
  function Mt(t, e, a = 1) {
    return Vu(-t, t, e, a);
  }
  function Oa(t, e, a, n, l, o = false) {
    const h = o ? l.disableMultiStrokeFill : l.disableMultiStroke, u = Vp(t, e, a, n, l, true, false);
    if (h) return u;
    const d = Vp(t, e, a, n, l, true, true);
    return u.concat(d);
  }
  function Vp(t, e, a, n, l, o, h) {
    const u = Math.pow(t - a, 2) + Math.pow(e - n, 2), d = Math.sqrt(u);
    let f = 1;
    f = d < 200 ? 1 : d > 500 ? 0.4 : -16668e-7 * d + 1.233334;
    let p = l.maxRandomnessOffset || 0;
    p * p * 100 > u && (p = d / 10);
    const m = p / 2, b = 0.2 + 0.2 * DS(l);
    let x = l.bowing * l.maxRandomnessOffset * (n - e) / 200, _ = l.bowing * l.maxRandomnessOffset * (t - a) / 200;
    x = Mt(x, l, f), _ = Mt(_, l, f);
    const S = [], w = () => Mt(m, l, f), k = () => Mt(p, l, f), A = l.preserveVertices;
    return h ? S.push({
      op: "move",
      data: [
        t + (A ? 0 : w()),
        e + (A ? 0 : w())
      ]
    }) : S.push({
      op: "move",
      data: [
        t + (A ? 0 : Mt(p, l, f)),
        e + (A ? 0 : Mt(p, l, f))
      ]
    }), h ? S.push({
      op: "bcurveTo",
      data: [
        x + t + (a - t) * b + w(),
        _ + e + (n - e) * b + w(),
        x + t + 2 * (a - t) * b + w(),
        _ + e + 2 * (n - e) * b + w(),
        a + (A ? 0 : w()),
        n + (A ? 0 : w())
      ]
    }) : S.push({
      op: "bcurveTo",
      data: [
        x + t + (a - t) * b + k(),
        _ + e + (n - e) * b + k(),
        x + t + 2 * (a - t) * b + k(),
        _ + e + 2 * (n - e) * b + k(),
        a + (A ? 0 : k()),
        n + (A ? 0 : k())
      ]
    }), S;
  }
  function tu(t, e, a) {
    if (!t.length) return [];
    const n = [];
    n.push([
      t[0][0] + Mt(e, a),
      t[0][1] + Mt(e, a)
    ]), n.push([
      t[0][0] + Mt(e, a),
      t[0][1] + Mt(e, a)
    ]);
    for (let l = 1; l < t.length; l++) n.push([
      t[l][0] + Mt(e, a),
      t[l][1] + Mt(e, a)
    ]), l === t.length - 1 && n.push([
      t[l][0] + Mt(e, a),
      t[l][1] + Mt(e, a)
    ]);
    return Zu(n, null, a);
  }
  function Zu(t, e, a) {
    const n = t.length, l = [];
    if (n > 3) {
      const o = [], h = 1 - a.curveTightness;
      l.push({
        op: "move",
        data: [
          t[1][0],
          t[1][1]
        ]
      });
      for (let u = 1; u + 2 < n; u++) {
        const d = t[u];
        o[0] = [
          d[0],
          d[1]
        ], o[1] = [
          d[0] + (h * t[u + 1][0] - h * t[u - 1][0]) / 6,
          d[1] + (h * t[u + 1][1] - h * t[u - 1][1]) / 6
        ], o[2] = [
          t[u + 1][0] + (h * t[u][0] - h * t[u + 2][0]) / 6,
          t[u + 1][1] + (h * t[u][1] - h * t[u + 2][1]) / 6
        ], o[3] = [
          t[u + 1][0],
          t[u + 1][1]
        ], l.push({
          op: "bcurveTo",
          data: [
            o[1][0],
            o[1][1],
            o[2][0],
            o[2][1],
            o[3][0],
            o[3][1]
          ]
        });
      }
    } else n === 3 ? (l.push({
      op: "move",
      data: [
        t[1][0],
        t[1][1]
      ]
    }), l.push({
      op: "bcurveTo",
      data: [
        t[1][0],
        t[1][1],
        t[2][0],
        t[2][1],
        t[2][0],
        t[2][1]
      ]
    })) : n === 2 && l.push(...Vp(t[0][0], t[0][1], t[1][0], t[1][1], a, true, true));
    return l;
  }
  function gx(t, e, a, n, l, o, h, u) {
    const d = [], f = [];
    if (u.roughness === 0) {
      t /= 4, f.push([
        e + n * Math.cos(-t),
        a + l * Math.sin(-t)
      ]);
      for (let p = 0; p <= 2 * Math.PI; p += t) {
        const m = [
          e + n * Math.cos(p),
          a + l * Math.sin(p)
        ];
        d.push(m), f.push(m);
      }
      f.push([
        e + n * Math.cos(0),
        a + l * Math.sin(0)
      ]), f.push([
        e + n * Math.cos(t),
        a + l * Math.sin(t)
      ]);
    } else {
      const p = Mt(0.5, u) - Math.PI / 2;
      f.push([
        Mt(o, u) + e + 0.9 * n * Math.cos(p - t),
        Mt(o, u) + a + 0.9 * l * Math.sin(p - t)
      ]);
      const m = 2 * Math.PI + p - 0.01;
      for (let b = p; b < m; b += t) {
        const x = [
          Mt(o, u) + e + n * Math.cos(b),
          Mt(o, u) + a + l * Math.sin(b)
        ];
        d.push(x), f.push(x);
      }
      f.push([
        Mt(o, u) + e + n * Math.cos(p + 2 * Math.PI + 0.5 * h),
        Mt(o, u) + a + l * Math.sin(p + 2 * Math.PI + 0.5 * h)
      ]), f.push([
        Mt(o, u) + e + 0.98 * n * Math.cos(p + h),
        Mt(o, u) + a + 0.98 * l * Math.sin(p + h)
      ]), f.push([
        Mt(o, u) + e + 0.9 * n * Math.cos(p + 0.5 * h),
        Mt(o, u) + a + 0.9 * l * Math.sin(p + 0.5 * h)
      ]);
    }
    return [
      f,
      d
    ];
  }
  function mx(t, e, a, n, l, o, h, u, d) {
    const f = o + Mt(0.1, d), p = [];
    p.push([
      Mt(u, d) + e + 0.9 * n * Math.cos(f - t),
      Mt(u, d) + a + 0.9 * l * Math.sin(f - t)
    ]);
    for (let m = f; m <= h; m += t) p.push([
      Mt(u, d) + e + n * Math.cos(m),
      Mt(u, d) + a + l * Math.sin(m)
    ]);
    return p.push([
      e + n * Math.cos(h),
      a + l * Math.sin(h)
    ]), p.push([
      e + n * Math.cos(h),
      a + l * Math.sin(h)
    ]), Zu(p, null, d);
  }
  function IR(t, e, a, n, l, o, h, u) {
    const d = [], f = [
      u.maxRandomnessOffset || 1,
      (u.maxRandomnessOffset || 1) + 0.3
    ];
    let p = [
      0,
      0
    ];
    const m = u.disableMultiStroke ? 1 : 2, b = u.preserveVertices;
    for (let x = 0; x < m; x++) x === 0 ? d.push({
      op: "move",
      data: [
        h[0],
        h[1]
      ]
    }) : d.push({
      op: "move",
      data: [
        h[0] + (b ? 0 : Mt(f[0], u)),
        h[1] + (b ? 0 : Mt(f[0], u))
      ]
    }), p = b ? [
      l,
      o
    ] : [
      l + Mt(f[x], u),
      o + Mt(f[x], u)
    ], d.push({
      op: "bcurveTo",
      data: [
        t + Mt(f[x], u),
        e + Mt(f[x], u),
        a + Mt(f[x], u),
        n + Mt(f[x], u),
        p[0],
        p[1]
      ]
    });
    return d;
  }
  function Xs(t) {
    return [
      ...t
    ];
  }
  function yx(t, e = 0) {
    const a = t.length;
    if (a < 3) throw new Error("A curve must have at least three points.");
    const n = [];
    if (a === 3) n.push(Xs(t[0]), Xs(t[1]), Xs(t[2]), Xs(t[2]));
    else {
      const l = [];
      l.push(t[0], t[0]);
      for (let u = 1; u < t.length; u++) l.push(t[u]), u === t.length - 1 && l.push(t[u]);
      const o = [], h = 1 - e;
      n.push(Xs(l[0]));
      for (let u = 1; u + 2 < l.length; u++) {
        const d = l[u];
        o[0] = [
          d[0],
          d[1]
        ], o[1] = [
          d[0] + (h * l[u + 1][0] - h * l[u - 1][0]) / 6,
          d[1] + (h * l[u + 1][1] - h * l[u - 1][1]) / 6
        ], o[2] = [
          l[u + 1][0] + (h * l[u][0] - h * l[u + 2][0]) / 6,
          l[u + 1][1] + (h * l[u][1] - h * l[u + 2][1]) / 6
        ], o[3] = [
          l[u + 1][0],
          l[u + 1][1]
        ], n.push(o[1], o[2], o[3]);
      }
    }
    return n;
  }
  function gu(t, e) {
    return Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2);
  }
  function PR(t, e, a) {
    const n = gu(e, a);
    if (n === 0) return gu(t, e);
    let l = ((t[0] - e[0]) * (a[0] - e[0]) + (t[1] - e[1]) * (a[1] - e[1])) / n;
    return l = Math.max(0, Math.min(1, l)), gu(t, on(e, a, l));
  }
  function on(t, e, a) {
    return [
      t[0] + (e[0] - t[0]) * a,
      t[1] + (e[1] - t[1]) * a
    ];
  }
  function Zp(t, e, a, n) {
    const l = n || [];
    if ((function(u, d) {
      const f = u[d + 0], p = u[d + 1], m = u[d + 2], b = u[d + 3];
      let x = 3 * p[0] - 2 * f[0] - b[0];
      x *= x;
      let _ = 3 * p[1] - 2 * f[1] - b[1];
      _ *= _;
      let S = 3 * m[0] - 2 * b[0] - f[0];
      S *= S;
      let w = 3 * m[1] - 2 * b[1] - f[1];
      return w *= w, x < S && (x = S), _ < w && (_ = w), x + _;
    })(t, e) < a) {
      const u = t[e + 0];
      l.length ? (o = l[l.length - 1], h = u, Math.sqrt(gu(o, h)) > 1 && l.push(u)) : l.push(u), l.push(t[e + 3]);
    } else {
      const d = t[e + 0], f = t[e + 1], p = t[e + 2], m = t[e + 3], b = on(d, f, 0.5), x = on(f, p, 0.5), _ = on(p, m, 0.5), S = on(b, x, 0.5), w = on(x, _, 0.5), k = on(S, w, 0.5);
      Zp([
        d,
        b,
        S,
        k
      ], 0, a, l), Zp([
        k,
        w,
        _,
        m
      ], 0, a, l);
    }
    var o, h;
    return l;
  }
  function GR(t, e) {
    return Qu(t, 0, t.length, e);
  }
  function Qu(t, e, a, n, l) {
    const o = l || [], h = t[e], u = t[a - 1];
    let d = 0, f = 1;
    for (let p = e + 1; p < a - 1; ++p) {
      const m = PR(t[p], h, u);
      m > d && (d = m, f = p);
    }
    return Math.sqrt(d) > n ? (Qu(t, e, f + 1, n, o), Qu(t, f, a, n, o)) : (o.length || o.push(h), o.push(u)), o;
  }
  function np(t, e = 0.15, a) {
    const n = [], l = (t.length - 1) / 3;
    for (let o = 0; o < l; o++) Zp(t, 3 * o, e, n);
    return a && a > 0 ? Qu(n, 0, n.length, a) : n;
  }
  const ki = "none";
  class Ku {
    constructor(e) {
      this.defaultOptions = {
        maxRandomnessOffset: 2,
        roughness: 1,
        bowing: 1,
        stroke: "#000",
        strokeWidth: 1,
        curveTightness: 0,
        curveFitting: 0.95,
        curveStepCount: 9,
        fillStyle: "hachure",
        fillWeight: -1,
        hachureAngle: -41,
        hachureGap: -1,
        dashOffset: -1,
        dashGap: -1,
        zigzagOffset: -1,
        seed: 0,
        disableMultiStroke: false,
        disableMultiStrokeFill: false,
        preserveVertices: false,
        fillShapeRoughnessGain: 0.8
      }, this.config = e || {}, this.config.options && (this.defaultOptions = this._o(this.config.options));
    }
    static newSeed() {
      return Math.floor(Math.random() * 2 ** 31);
    }
    _o(e) {
      return e ? Object.assign({}, this.defaultOptions, e) : this.defaultOptions;
    }
    _d(e, a, n) {
      return {
        shape: e,
        sets: a || [],
        options: n || this.defaultOptions
      };
    }
    line(e, a, n, l, o) {
      const h = this._o(o);
      return this._d("line", [
        LS(e, a, n, l, h)
      ], h);
    }
    rectangle(e, a, n, l, o) {
      const h = this._o(o), u = [], d = YR(e, a, n, l, h);
      if (h.fill) {
        const f = [
          [
            e,
            a
          ],
          [
            e + n,
            a
          ],
          [
            e + n,
            a + l
          ],
          [
            e,
            a + l
          ]
        ];
        h.fillStyle === "solid" ? u.push(ap([
          f
        ], h)) : u.push(fl([
          f
        ], h));
      }
      return h.stroke !== ki && u.push(d), this._d("rectangle", u, h);
    }
    ellipse(e, a, n, l, o) {
      const h = this._o(o), u = [], d = OS(n, l, h), f = Xp(e, a, h, d);
      if (h.fill) if (h.fillStyle === "solid") {
        const p = Xp(e, a, h, d).opset;
        p.type = "fillPath", u.push(p);
      } else u.push(fl([
        f.estimatedPoints
      ], h));
      return h.stroke !== ki && u.push(f.opset), this._d("ellipse", u, h);
    }
    circle(e, a, n, l) {
      const o = this.ellipse(e, a, n, n, l);
      return o.shape = "circle", o;
    }
    linearPath(e, a) {
      const n = this._o(a);
      return this._d("linearPath", [
        pu(e, false, n)
      ], n);
    }
    arc(e, a, n, l, o, h, u = false, d) {
      const f = this._o(d), p = [], m = fx(e, a, n, l, o, h, u, true, f);
      if (u && f.fill) if (f.fillStyle === "solid") {
        const b = Object.assign({}, f);
        b.disableMultiStroke = true;
        const x = fx(e, a, n, l, o, h, true, false, b);
        x.type = "fillPath", p.push(x);
      } else p.push((function(b, x, _, S, w, k, A) {
        const L = b, $ = x;
        let O = Math.abs(_ / 2), W = Math.abs(S / 2);
        O += Mt(0.01 * O, A), W += Mt(0.01 * W, A);
        let j = w, et = k;
        for (; j < 0; ) j += 2 * Math.PI, et += 2 * Math.PI;
        et - j > 2 * Math.PI && (j = 0, et = 2 * Math.PI);
        const nt = (et - j) / A.curveStepCount, lt = [];
        for (let X = j; X <= et; X += nt) lt.push([
          L + O * Math.cos(X),
          $ + W * Math.sin(X)
        ]);
        return lt.push([
          L + O * Math.cos(et),
          $ + W * Math.sin(et)
        ]), lt.push([
          L,
          $
        ]), fl([
          lt
        ], A);
      })(e, a, n, l, o, h, f));
      return f.stroke !== ki && p.push(m), this._d("arc", p, f);
    }
    curve(e, a) {
      const n = this._o(a), l = [], o = hx(e, n);
      if (n.fill && n.fill !== ki) if (n.fillStyle === "solid") {
        const h = hx(e, Object.assign(Object.assign({}, n), {
          disableMultiStroke: true,
          roughness: n.roughness ? n.roughness + n.fillShapeRoughnessGain : 0
        }));
        l.push({
          type: "fillPath",
          ops: this._mergedShape(h.ops)
        });
      } else {
        const h = [], u = e;
        if (u.length) {
          const d = typeof u[0][0] == "number" ? [
            u
          ] : u;
          for (const f of d) f.length < 3 ? h.push(...f) : f.length === 3 ? h.push(...np(yx([
            f[0],
            f[0],
            f[1],
            f[2]
          ]), 10, (1 + n.roughness) / 2)) : h.push(...np(yx(f), 10, (1 + n.roughness) / 2));
        }
        h.length && l.push(fl([
          h
        ], n));
      }
      return n.stroke !== ki && l.push(o), this._d("curve", l, n);
    }
    polygon(e, a) {
      const n = this._o(a), l = [], o = pu(e, true, n);
      return n.fill && (n.fillStyle === "solid" ? l.push(ap([
        e
      ], n)) : l.push(fl([
        e
      ], n))), n.stroke !== ki && l.push(o), this._d("polygon", l, n);
    }
    path(e, a) {
      const n = this._o(a), l = [];
      if (!e) return this._d("path", l, n);
      e = (e || "").replace(/\n/g, " ").replace(/(-\s)/g, "-").replace("/(ss)/g", " ");
      const o = n.fill && n.fill !== "transparent" && n.fill !== ki, h = n.stroke !== ki, u = !!(n.simplification && n.simplification < 1), d = (function(p, m, b) {
        const x = MS(ES(r0(p))), _ = [];
        let S = [], w = [
          0,
          0
        ], k = [];
        const A = () => {
          k.length >= 4 && S.push(...np(k, m)), k = [];
        }, L = () => {
          A(), S.length && (_.push(S), S = []);
        };
        for (const { key: O, data: W } of x) switch (O) {
          case "M":
            L(), w = [
              W[0],
              W[1]
            ], S.push(w);
            break;
          case "L":
            A(), S.push([
              W[0],
              W[1]
            ]);
            break;
          case "C":
            if (!k.length) {
              const j = S.length ? S[S.length - 1] : w;
              k.push([
                j[0],
                j[1]
              ]);
            }
            k.push([
              W[0],
              W[1]
            ]), k.push([
              W[2],
              W[3]
            ]), k.push([
              W[4],
              W[5]
            ]);
            break;
          case "Z":
            A(), S.push([
              w[0],
              w[1]
            ]);
        }
        if (L(), !b) return _;
        const $ = [];
        for (const O of _) {
          const W = GR(O, b);
          W.length && $.push(W);
        }
        return $;
      })(e, 1, u ? 4 - 4 * (n.simplification || 1) : (1 + n.roughness) / 2), f = dx(e, n);
      if (o) if (n.fillStyle === "solid") if (d.length === 1) {
        const p = dx(e, Object.assign(Object.assign({}, n), {
          disableMultiStroke: true,
          roughness: n.roughness ? n.roughness + n.fillShapeRoughnessGain : 0
        }));
        l.push({
          type: "fillPath",
          ops: this._mergedShape(p.ops)
        });
      } else l.push(ap(d, n));
      else l.push(fl(d, n));
      return h && (u ? d.forEach(((p) => {
        l.push(pu(p, false, n));
      })) : l.push(f)), this._d("path", l, n);
    }
    opsToPath(e, a) {
      let n = "";
      for (const l of e.ops) {
        const o = typeof a == "number" && a >= 0 ? l.data.map(((h) => +h.toFixed(a))) : l.data;
        switch (l.op) {
          case "move":
            n += `M${o[0]} ${o[1]} `;
            break;
          case "bcurveTo":
            n += `C${o[0]} ${o[1]}, ${o[2]} ${o[3]}, ${o[4]} ${o[5]} `;
            break;
          case "lineTo":
            n += `L${o[0]} ${o[1]} `;
        }
      }
      return n.trim();
    }
    toPaths(e) {
      const a = e.sets || [], n = e.options || this.defaultOptions, l = [];
      for (const o of a) {
        let h = null;
        switch (o.type) {
          case "path":
            h = {
              d: this.opsToPath(o),
              stroke: n.stroke,
              strokeWidth: n.strokeWidth,
              fill: ki
            };
            break;
          case "fillPath":
            h = {
              d: this.opsToPath(o),
              stroke: ki,
              strokeWidth: 0,
              fill: n.fill || ki
            };
            break;
          case "fillSketch":
            h = this.fillSketch(o, n);
        }
        h && l.push(h);
      }
      return l;
    }
    fillSketch(e, a) {
      let n = a.fillWeight;
      return n < 0 && (n = a.strokeWidth / 2), {
        d: this.opsToPath(e),
        stroke: a.fill || ki,
        strokeWidth: n,
        fill: ki
      };
    }
    _mergedShape(e) {
      return e.filter(((a, n) => n === 0 || a.op !== "move"));
    }
  }
  class WR {
    constructor(e, a) {
      this.canvas = e, this.ctx = this.canvas.getContext("2d"), this.gen = new Ku(a);
    }
    draw(e) {
      const a = e.sets || [], n = e.options || this.getDefaultOptions(), l = this.ctx, o = e.options.fixedDecimalPlaceDigits;
      for (const h of a) switch (h.type) {
        case "path":
          l.save(), l.strokeStyle = n.stroke === "none" ? "transparent" : n.stroke, l.lineWidth = n.strokeWidth, n.strokeLineDash && l.setLineDash(n.strokeLineDash), n.strokeLineDashOffset && (l.lineDashOffset = n.strokeLineDashOffset), this._drawToContext(l, h, o), l.restore();
          break;
        case "fillPath": {
          l.save(), l.fillStyle = n.fill || "";
          const u = e.shape === "curve" || e.shape === "polygon" || e.shape === "path" ? "evenodd" : "nonzero";
          this._drawToContext(l, h, o, u), l.restore();
          break;
        }
        case "fillSketch":
          this.fillSketch(l, h, n);
      }
    }
    fillSketch(e, a, n) {
      let l = n.fillWeight;
      l < 0 && (l = n.strokeWidth / 2), e.save(), n.fillLineDash && e.setLineDash(n.fillLineDash), n.fillLineDashOffset && (e.lineDashOffset = n.fillLineDashOffset), e.strokeStyle = n.fill || "", e.lineWidth = l, this._drawToContext(e, a, n.fixedDecimalPlaceDigits), e.restore();
    }
    _drawToContext(e, a, n, l = "nonzero") {
      e.beginPath();
      for (const o of a.ops) {
        const h = typeof n == "number" && n >= 0 ? o.data.map(((u) => +u.toFixed(n))) : o.data;
        switch (o.op) {
          case "move":
            e.moveTo(h[0], h[1]);
            break;
          case "bcurveTo":
            e.bezierCurveTo(h[0], h[1], h[2], h[3], h[4], h[5]);
            break;
          case "lineTo":
            e.lineTo(h[0], h[1]);
        }
      }
      a.type === "fillPath" ? e.fill(l) : e.stroke();
    }
    get generator() {
      return this.gen;
    }
    getDefaultOptions() {
      return this.gen.defaultOptions;
    }
    line(e, a, n, l, o) {
      const h = this.gen.line(e, a, n, l, o);
      return this.draw(h), h;
    }
    rectangle(e, a, n, l, o) {
      const h = this.gen.rectangle(e, a, n, l, o);
      return this.draw(h), h;
    }
    ellipse(e, a, n, l, o) {
      const h = this.gen.ellipse(e, a, n, l, o);
      return this.draw(h), h;
    }
    circle(e, a, n, l) {
      const o = this.gen.circle(e, a, n, l);
      return this.draw(o), o;
    }
    linearPath(e, a) {
      const n = this.gen.linearPath(e, a);
      return this.draw(n), n;
    }
    polygon(e, a) {
      const n = this.gen.polygon(e, a);
      return this.draw(n), n;
    }
    arc(e, a, n, l, o, h, u = false, d) {
      const f = this.gen.arc(e, a, n, l, o, h, u, d);
      return this.draw(f), f;
    }
    curve(e, a) {
      const n = this.gen.curve(e, a);
      return this.draw(n), n;
    }
    path(e, a) {
      const n = this.gen.path(e, a);
      return this.draw(n), n;
    }
  }
  const eu = "http://www.w3.org/2000/svg";
  class XR {
    constructor(e, a) {
      this.svg = e, this.gen = new Ku(a);
    }
    draw(e) {
      const a = e.sets || [], n = e.options || this.getDefaultOptions(), l = this.svg.ownerDocument || window.document, o = l.createElementNS(eu, "g"), h = e.options.fixedDecimalPlaceDigits;
      for (const u of a) {
        let d = null;
        switch (u.type) {
          case "path":
            d = l.createElementNS(eu, "path"), d.setAttribute("d", this.opsToPath(u, h)), d.setAttribute("stroke", n.stroke), d.setAttribute("stroke-width", n.strokeWidth + ""), d.setAttribute("fill", "none"), n.strokeLineDash && d.setAttribute("stroke-dasharray", n.strokeLineDash.join(" ").trim()), n.strokeLineDashOffset && d.setAttribute("stroke-dashoffset", `${n.strokeLineDashOffset}`);
            break;
          case "fillPath":
            d = l.createElementNS(eu, "path"), d.setAttribute("d", this.opsToPath(u, h)), d.setAttribute("stroke", "none"), d.setAttribute("stroke-width", "0"), d.setAttribute("fill", n.fill || ""), e.shape !== "curve" && e.shape !== "polygon" || d.setAttribute("fill-rule", "evenodd");
            break;
          case "fillSketch":
            d = this.fillSketch(l, u, n);
        }
        d && o.appendChild(d);
      }
      return o;
    }
    fillSketch(e, a, n) {
      let l = n.fillWeight;
      l < 0 && (l = n.strokeWidth / 2);
      const o = e.createElementNS(eu, "path");
      return o.setAttribute("d", this.opsToPath(a, n.fixedDecimalPlaceDigits)), o.setAttribute("stroke", n.fill || ""), o.setAttribute("stroke-width", l + ""), o.setAttribute("fill", "none"), n.fillLineDash && o.setAttribute("stroke-dasharray", n.fillLineDash.join(" ").trim()), n.fillLineDashOffset && o.setAttribute("stroke-dashoffset", `${n.fillLineDashOffset}`), o;
    }
    get generator() {
      return this.gen;
    }
    getDefaultOptions() {
      return this.gen.defaultOptions;
    }
    opsToPath(e, a) {
      return this.gen.opsToPath(e, a);
    }
    line(e, a, n, l, o) {
      const h = this.gen.line(e, a, n, l, o);
      return this.draw(h);
    }
    rectangle(e, a, n, l, o) {
      const h = this.gen.rectangle(e, a, n, l, o);
      return this.draw(h);
    }
    ellipse(e, a, n, l, o) {
      const h = this.gen.ellipse(e, a, n, l, o);
      return this.draw(h);
    }
    circle(e, a, n, l) {
      const o = this.gen.circle(e, a, n, l);
      return this.draw(o);
    }
    linearPath(e, a) {
      const n = this.gen.linearPath(e, a);
      return this.draw(n);
    }
    polygon(e, a) {
      const n = this.gen.polygon(e, a);
      return this.draw(n);
    }
    arc(e, a, n, l, o, h, u = false, d) {
      const f = this.gen.arc(e, a, n, l, o, h, u, d);
      return this.draw(f);
    }
    curve(e, a) {
      const n = this.gen.curve(e, a);
      return this.draw(n);
    }
    path(e, a) {
      const n = this.gen.path(e, a);
      return this.draw(n);
    }
  }
  let yt, At, lp, Tt;
  yt = {
    canvas: (t, e) => new WR(t, e),
    svg: (t, e) => new XR(t, e),
    generator: (t) => new Ku(t),
    newSeed: () => Ku.newSeed()
  };
  At = v(async (t, e, a) => {
    var _a2, _b2;
    let n;
    const l = e.useHtmlLabels || Ee((_a2 = Pt()) == null ? void 0 : _a2.htmlLabels);
    a ? n = a : n = "node default";
    const o = t.insert("g").attr("class", n).attr("id", e.domId || e.id), h = o.insert("g").attr("class", "label").attr("style", Ze(e.labelStyle));
    let u;
    e.label === void 0 ? u = "" : u = typeof e.label == "string" ? e.label : e.label[0];
    const d = await $a(h, ji(kn(u), Pt()), {
      useHtmlLabels: l,
      width: e.width || ((_b2 = Pt().flowchart) == null ? void 0 : _b2.wrappingWidth),
      cssClasses: "markdown-node-label",
      style: e.labelStyle,
      addSvgBackground: !!e.icon || !!e.img
    });
    let f = d.getBBox();
    const p = ((e == null ? void 0 : e.padding) ?? 0) / 2;
    if (l) {
      const m = d.children[0], b = jt(d), x = m.getElementsByTagName("img");
      if (x) {
        const _ = u.replace(/<img[^>]*>/g, "").trim() === "";
        await Promise.all([
          ...x
        ].map((S) => new Promise((w) => {
          function k() {
            if (S.style.display = "flex", S.style.flexDirection = "column", _) {
              const A = Pt().fontSize ? Pt().fontSize : window.getComputedStyle(document.body).fontSize, L = 5, [$ = Gx.fontSize] = yh(A), O = $ * L + "px";
              S.style.minWidth = O, S.style.maxWidth = O;
            } else S.style.width = "100%";
            w(S);
          }
          v(k, "setupImage"), setTimeout(() => {
            S.complete && k();
          }), S.addEventListener("error", k), S.addEventListener("load", k);
        })));
      }
      f = m.getBoundingClientRect(), b.attr("width", f.width), b.attr("height", f.height);
    }
    return l ? h.attr("transform", "translate(" + -f.width / 2 + ", " + -f.height / 2 + ")") : h.attr("transform", "translate(0, " + -f.height / 2 + ")"), e.centerLabel && h.attr("transform", "translate(" + -f.width / 2 + ", " + -f.height / 2 + ")"), h.insert("rect", ":first-child"), {
      shapeSvg: o,
      bbox: f,
      halfPadding: p,
      label: h
    };
  }, "labelHelper");
  lp = v(async (t, e, a) => {
    var _a2, _b2, _c2, _d2, _e2, _f2;
    const n = a.useHtmlLabels || Ee((_b2 = (_a2 = Pt()) == null ? void 0 : _a2.flowchart) == null ? void 0 : _b2.htmlLabels), l = t.insert("g").attr("class", "label").attr("style", a.labelStyle || ""), o = await $a(l, ji(kn(e), Pt()), {
      useHtmlLabels: n,
      width: a.width || ((_d2 = (_c2 = Pt()) == null ? void 0 : _c2.flowchart) == null ? void 0 : _d2.wrappingWidth),
      style: a.labelStyle,
      addSvgBackground: !!a.icon || !!a.img
    });
    let h = o.getBBox();
    const u = a.padding / 2;
    if (Ee((_f2 = (_e2 = Pt()) == null ? void 0 : _e2.flowchart) == null ? void 0 : _f2.htmlLabels)) {
      const d = o.children[0], f = jt(o);
      h = d.getBoundingClientRect(), f.attr("width", h.width), f.attr("height", h.height);
    }
    return n ? l.attr("transform", "translate(" + -h.width / 2 + ", " + -h.height / 2 + ")") : l.attr("transform", "translate(0, " + -h.height / 2 + ")"), a.centerLabel && l.attr("transform", "translate(" + -h.width / 2 + ", " + -h.height / 2 + ")"), l.insert("rect", ":first-child"), {
      shapeSvg: t,
      bbox: h,
      halfPadding: u,
      label: l
    };
  }, "insertLabel");
  xt = v((t, e) => {
    const a = e.node().getBBox();
    t.width = a.width, t.height = a.height;
  }, "updateNodeBounds");
  Tt = v((t, e) => (t.look === "handDrawn" ? "rough-node" : "node") + " " + t.cssClasses + " " + (e || ""), "getNodeClasses");
  function Ft(t) {
    const e = t.map((a, n) => `${n === 0 ? "M" : "L"}${a.x},${a.y}`);
    return e.push("Z"), e.join(" ");
  }
  v(Ft, "createPathFromPoints");
  function Da(t, e, a, n, l, o) {
    const h = [], d = a - t, f = n - e, p = d / o, m = 2 * Math.PI / p, b = e + f / 2;
    for (let x = 0; x <= 50; x++) {
      const _ = x / 50, S = t + _ * d, w = b + l * Math.sin(m * (S - t));
      h.push({
        x: S,
        y: w
      });
    }
    return h;
  }
  v(Da, "generateFullSineWavePoints");
  function _o(t, e, a, n, l, o) {
    const h = [], u = l * Math.PI / 180, p = (o * Math.PI / 180 - u) / (n - 1);
    for (let m = 0; m < n; m++) {
      const b = u + m * p, x = t + a * Math.cos(b), _ = e + a * Math.sin(b);
      h.push({
        x: -x,
        y: -_
      });
    }
    return h;
  }
  v(_o, "generateCirclePoints");
  var VR = v((t, e) => {
    var a = t.x, n = t.y, l = e.x - a, o = e.y - n, h = t.width / 2, u = t.height / 2, d, f;
    return Math.abs(o) * h > Math.abs(l) * u ? (o < 0 && (u = -u), d = o === 0 ? 0 : u * l / o, f = u) : (l < 0 && (h = -h), d = h, f = l === 0 ? 0 : h * o / l), {
      x: a + d,
      y: n + f
    };
  }, "intersectRect"), Ol = VR;
  function RS(t, e) {
    e && t.attr("style", e);
  }
  v(RS, "applyStyle");
  async function $S(t) {
    const e = jt(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject")), a = e.append("xhtml:div"), n = Pt();
    let l = t.label;
    t.label && _l(t.label) && (l = await ug(t.label.replace(El.lineBreakRegex, `
`), n));
    const h = '<span class="' + (t.isNode ? "nodeLabel" : "edgeLabel") + '" ' + (t.labelStyle ? 'style="' + t.labelStyle + '"' : "") + ">" + l + "</span>";
    return a.html(ji(h, n)), RS(a, t.labelStyle), a.style("display", "inline-block"), a.style("padding-right", "1px"), a.style("white-space", "nowrap"), a.attr("xmlns", "http://www.w3.org/1999/xhtml"), e.node();
  }
  v($S, "addHtmlLabel");
  let ZR, pn, Na, NS, QR, KR, JR, t6, e6, i6, zS;
  ZR = v(async (t, e, a, n) => {
    let l = t || "";
    if (typeof l == "object" && (l = l[0]), Ee(Pt().flowchart.htmlLabels)) {
      l = l.replace(/\\n|\n/g, "<br />"), it.info("vertexText" + l);
      const o = {
        isNode: n,
        label: kn(l).replace(/fa[blrs]?:fa-[\w-]+/g, (u) => `<i class='${u.replace(":", " ")}'></i>`),
        labelStyle: e && e.replace("fill:", "color:")
      };
      return await $S(o);
    } else {
      const o = document.createElementNS("http://www.w3.org/2000/svg", "text");
      o.setAttribute("style", e.replace("color:", "fill:"));
      let h = [];
      typeof l == "string" ? h = l.split(/\\n|\n|<br\s*\/?>/gi) : Array.isArray(l) ? h = l : h = [];
      for (const u of h) {
        const d = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
        d.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), d.setAttribute("dy", "1em"), d.setAttribute("x", "0"), a ? d.setAttribute("class", "title-row") : d.setAttribute("class", "row"), d.textContent = u.trim(), o.appendChild(d);
      }
      return o;
    }
  }, "createLabel");
  pn = ZR;
  Na = v((t, e, a, n, l) => [
    "M",
    t + l,
    e,
    "H",
    t + a - l,
    "A",
    l,
    l,
    0,
    0,
    1,
    t + a,
    e + l,
    "V",
    e + n - l,
    "A",
    l,
    l,
    0,
    0,
    1,
    t + a - l,
    e + n,
    "H",
    t + l,
    "A",
    l,
    l,
    0,
    0,
    1,
    t,
    e + n - l,
    "V",
    e + l,
    "A",
    l,
    l,
    0,
    0,
    1,
    t + l,
    e,
    "Z"
  ].join(" "), "createRoundedRectPathD");
  NS = v(async (t, e) => {
    it.info("Creating subgraph rect for ", e.id, e);
    const a = Pt(), { themeVariables: n, handDrawnSeed: l } = a, { clusterBkg: o, clusterBorder: h } = n, { labelStyles: u, nodeStyles: d, borderStyles: f, backgroundStyles: p } = vt(e), m = t.insert("g").attr("class", "cluster " + e.cssClasses).attr("id", e.id).attr("data-look", e.look), b = Ee(a.flowchart.htmlLabels), x = m.insert("g").attr("class", "cluster-label "), _ = await $a(x, e.label, {
      style: e.labelStyle,
      useHtmlLabels: b,
      isNode: true
    });
    let S = _.getBBox();
    if (Ee(a.flowchart.htmlLabels)) {
      const j = _.children[0], et = jt(_);
      S = j.getBoundingClientRect(), et.attr("width", S.width), et.attr("height", S.height);
    }
    const w = e.width <= S.width + e.padding ? S.width + e.padding : e.width;
    e.width <= S.width + e.padding ? e.diff = (w - e.width) / 2 - e.padding : e.diff = -e.padding;
    const k = e.height, A = e.x - w / 2, L = e.y - k / 2;
    it.trace("Data ", e, JSON.stringify(e));
    let $;
    if (e.look === "handDrawn") {
      const j = yt.svg(m), et = bt(e, {
        roughness: 0.7,
        fill: o,
        stroke: h,
        fillWeight: 3,
        seed: l
      }), nt = j.path(Na(A, L, w, k, 0), et);
      $ = m.insert(() => (it.debug("Rough node insert CXC", nt), nt), ":first-child"), $.select("path:nth-child(2)").attr("style", f.join(";")), $.select("path").attr("style", p.join(";").replace("fill", "stroke"));
    } else $ = m.insert("rect", ":first-child"), $.attr("style", d).attr("rx", e.rx).attr("ry", e.ry).attr("x", A).attr("y", L).attr("width", w).attr("height", k);
    const { subGraphTitleTopMargin: O } = $g(a);
    if (x.attr("transform", `translate(${e.x - S.width / 2}, ${e.y - e.height / 2 + O})`), u) {
      const j = x.select("span");
      j && j.attr("style", u);
    }
    const W = $.node().getBBox();
    return e.offsetX = 0, e.width = W.width, e.height = W.height, e.offsetY = S.height - e.padding / 2, e.intersect = function(j) {
      return Ol(e, j);
    }, {
      cluster: m,
      labelBBox: S
    };
  }, "rect");
  QR = v((t, e) => {
    const a = t.insert("g").attr("class", "note-cluster").attr("id", e.id), n = a.insert("rect", ":first-child"), l = 0 * e.padding, o = l / 2;
    n.attr("rx", e.rx).attr("ry", e.ry).attr("x", e.x - e.width / 2 - o).attr("y", e.y - e.height / 2 - o).attr("width", e.width + l).attr("height", e.height + l).attr("fill", "none");
    const h = n.node().getBBox();
    return e.width = h.width, e.height = h.height, e.intersect = function(u) {
      return Ol(e, u);
    }, {
      cluster: a,
      labelBBox: {
        width: 0,
        height: 0
      }
    };
  }, "noteGroup");
  KR = v(async (t, e) => {
    const a = Pt(), { themeVariables: n, handDrawnSeed: l } = a, { altBackground: o, compositeBackground: h, compositeTitleBackground: u, nodeBorder: d } = n, f = t.insert("g").attr("class", e.cssClasses).attr("id", e.id).attr("data-id", e.id).attr("data-look", e.look), p = f.insert("g", ":first-child"), m = f.insert("g").attr("class", "cluster-label");
    let b = f.append("rect");
    const x = m.node().appendChild(await pn(e.label, e.labelStyle, void 0, true));
    let _ = x.getBBox();
    if (Ee(a.flowchart.htmlLabels)) {
      const nt = x.children[0], lt = jt(x);
      _ = nt.getBoundingClientRect(), lt.attr("width", _.width), lt.attr("height", _.height);
    }
    const S = 0 * e.padding, w = S / 2, k = (e.width <= _.width + e.padding ? _.width + e.padding : e.width) + S;
    e.width <= _.width + e.padding ? e.diff = (k - e.width) / 2 - e.padding : e.diff = -e.padding;
    const A = e.height + S, L = e.height + S - _.height - 6, $ = e.x - k / 2, O = e.y - A / 2;
    e.width = k;
    const W = e.y - e.height / 2 - w + _.height + 2;
    let j;
    if (e.look === "handDrawn") {
      const nt = e.cssClasses.includes("statediagram-cluster-alt"), lt = yt.svg(f), X = e.rx || e.ry ? lt.path(Na($, O, k, A, 10), {
        roughness: 0.7,
        fill: u,
        fillStyle: "solid",
        stroke: d,
        seed: l
      }) : lt.rectangle($, O, k, A, {
        seed: l
      });
      j = f.insert(() => X, ":first-child");
      const at = lt.rectangle($, W, k, L, {
        fill: nt ? o : h,
        fillStyle: nt ? "hachure" : "solid",
        stroke: d,
        seed: l
      });
      j = f.insert(() => X, ":first-child"), b = f.insert(() => at);
    } else j = p.insert("rect", ":first-child"), j.attr("class", "outer").attr("x", $).attr("y", O).attr("width", k).attr("height", A).attr("data-look", e.look), b.attr("class", "inner").attr("x", $).attr("y", W).attr("width", k).attr("height", L);
    m.attr("transform", `translate(${e.x - _.width / 2}, ${O + 1 - (Ee(a.flowchart.htmlLabels) ? 0 : 3)})`);
    const et = j.node().getBBox();
    return e.height = et.height, e.offsetX = 0, e.offsetY = _.height - e.padding / 2, e.labelBBox = _, e.intersect = function(nt) {
      return Ol(e, nt);
    }, {
      cluster: f,
      labelBBox: _
    };
  }, "roundedWithTitle");
  JR = v(async (t, e) => {
    it.info("Creating subgraph rect for ", e.id, e);
    const a = Pt(), { themeVariables: n, handDrawnSeed: l } = a, { clusterBkg: o, clusterBorder: h } = n, { labelStyles: u, nodeStyles: d, borderStyles: f, backgroundStyles: p } = vt(e), m = t.insert("g").attr("class", "cluster " + e.cssClasses).attr("id", e.id).attr("data-look", e.look), b = Ee(a.flowchart.htmlLabels), x = m.insert("g").attr("class", "cluster-label "), _ = await $a(x, e.label, {
      style: e.labelStyle,
      useHtmlLabels: b,
      isNode: true,
      width: e.width
    });
    let S = _.getBBox();
    if (Ee(a.flowchart.htmlLabels)) {
      const j = _.children[0], et = jt(_);
      S = j.getBoundingClientRect(), et.attr("width", S.width), et.attr("height", S.height);
    }
    const w = e.width <= S.width + e.padding ? S.width + e.padding : e.width;
    e.width <= S.width + e.padding ? e.diff = (w - e.width) / 2 - e.padding : e.diff = -e.padding;
    const k = e.height, A = e.x - w / 2, L = e.y - k / 2;
    it.trace("Data ", e, JSON.stringify(e));
    let $;
    if (e.look === "handDrawn") {
      const j = yt.svg(m), et = bt(e, {
        roughness: 0.7,
        fill: o,
        stroke: h,
        fillWeight: 4,
        seed: l
      }), nt = j.path(Na(A, L, w, k, e.rx), et);
      $ = m.insert(() => (it.debug("Rough node insert CXC", nt), nt), ":first-child"), $.select("path:nth-child(2)").attr("style", f.join(";")), $.select("path").attr("style", p.join(";").replace("fill", "stroke"));
    } else $ = m.insert("rect", ":first-child"), $.attr("style", d).attr("rx", e.rx).attr("ry", e.ry).attr("x", A).attr("y", L).attr("width", w).attr("height", k);
    const { subGraphTitleTopMargin: O } = $g(a);
    if (x.attr("transform", `translate(${e.x - S.width / 2}, ${e.y - e.height / 2 + O})`), u) {
      const j = x.select("span");
      j && j.attr("style", u);
    }
    const W = $.node().getBBox();
    return e.offsetX = 0, e.width = W.width, e.height = W.height, e.offsetY = S.height - e.padding / 2, e.intersect = function(j) {
      return Ol(e, j);
    }, {
      cluster: m,
      labelBBox: S
    };
  }, "kanbanSection");
  t6 = v((t, e) => {
    const a = Pt(), { themeVariables: n, handDrawnSeed: l } = a, { nodeBorder: o } = n, h = t.insert("g").attr("class", e.cssClasses).attr("id", e.id).attr("data-look", e.look), u = h.insert("g", ":first-child"), d = 0 * e.padding, f = e.width + d;
    e.diff = -e.padding;
    const p = e.height + d, m = e.x - f / 2, b = e.y - p / 2;
    e.width = f;
    let x;
    if (e.look === "handDrawn") {
      const w = yt.svg(h).rectangle(m, b, f, p, {
        fill: "lightgrey",
        roughness: 0.5,
        strokeLineDash: [
          5
        ],
        stroke: o,
        seed: l
      });
      x = h.insert(() => w, ":first-child");
    } else x = u.insert("rect", ":first-child"), x.attr("class", "divider").attr("x", m).attr("y", b).attr("width", f).attr("height", p).attr("data-look", e.look);
    const _ = x.node().getBBox();
    return e.height = _.height, e.offsetX = 0, e.offsetY = 0, e.intersect = function(S) {
      return Ol(e, S);
    }, {
      cluster: h,
      labelBBox: {}
    };
  }, "divider");
  e6 = NS;
  i6 = {
    rect: NS,
    squareRect: e6,
    roundedWithTitle: KR,
    noteGroup: QR,
    divider: t6,
    kanbanSection: JR
  };
  zS = /* @__PURE__ */ new Map();
  r6 = v(async (t, e) => {
    const a = e.shape || "rect", n = await i6[a](t, e);
    return zS.set(e.id, n), n;
  }, "insertCluster");
  Az = v(() => {
    zS = /* @__PURE__ */ new Map();
  }, "clear");
  function FS(t, e) {
    return t.intersect(e);
  }
  v(FS, "intersectNode");
  var a6 = FS;
  function qS(t, e, a, n) {
    var l = t.x, o = t.y, h = l - n.x, u = o - n.y, d = Math.sqrt(e * e * u * u + a * a * h * h), f = Math.abs(e * a * h / d);
    n.x < l && (f = -f);
    var p = Math.abs(e * a * u / d);
    return n.y < o && (p = -p), {
      x: l + f,
      y: o + p
    };
  }
  v(qS, "intersectEllipse");
  var HS = qS;
  function US(t, e, a) {
    return HS(t, e, e, a);
  }
  v(US, "intersectCircle");
  var n6 = US;
  function jS(t, e, a, n) {
    {
      const l = e.y - t.y, o = t.x - e.x, h = e.x * t.y - t.x * e.y, u = l * a.x + o * a.y + h, d = l * n.x + o * n.y + h, f = 1e-6;
      if (u !== 0 && d !== 0 && Qp(u, d)) return;
      const p = n.y - a.y, m = a.x - n.x, b = n.x * a.y - a.x * n.y, x = p * t.x + m * t.y + b, _ = p * e.x + m * e.y + b;
      if (Math.abs(x) < f && Math.abs(_) < f && Qp(x, _)) return;
      const S = l * m - p * o;
      if (S === 0) return;
      const w = Math.abs(S / 2);
      let k = o * b - m * h;
      const A = k < 0 ? (k - w) / S : (k + w) / S;
      k = p * h - l * b;
      const L = k < 0 ? (k - w) / S : (k + w) / S;
      return {
        x: A,
        y: L
      };
    }
  }
  v(jS, "intersectLine");
  function Qp(t, e) {
    return t * e > 0;
  }
  v(Qp, "sameSign");
  var l6 = jS;
  function YS(t, e, a) {
    let n = t.x, l = t.y, o = [], h = Number.POSITIVE_INFINITY, u = Number.POSITIVE_INFINITY;
    typeof e.forEach == "function" ? e.forEach(function(p) {
      h = Math.min(h, p.x), u = Math.min(u, p.y);
    }) : (h = Math.min(h, e.x), u = Math.min(u, e.y));
    let d = n - t.width / 2 - h, f = l - t.height / 2 - u;
    for (let p = 0; p < e.length; p++) {
      let m = e[p], b = e[p < e.length - 1 ? p + 1 : 0], x = l6(t, a, {
        x: d + m.x,
        y: f + m.y
      }, {
        x: d + b.x,
        y: f + b.y
      });
      x && o.push(x);
    }
    return o.length ? (o.length > 1 && o.sort(function(p, m) {
      let b = p.x - a.x, x = p.y - a.y, _ = Math.sqrt(b * b + x * x), S = m.x - a.x, w = m.y - a.y, k = Math.sqrt(S * S + w * w);
      return _ < k ? -1 : _ === k ? 0 : 1;
    }), o[0]) : t;
  }
  v(YS, "intersectPolygon");
  var s6 = YS, ft = {
    node: a6,
    circle: n6,
    ellipse: HS,
    polygon: s6,
    rect: Ol
  };
  function IS(t, e) {
    const { labelStyles: a } = vt(e);
    e.labelStyle = a;
    const n = Tt(e);
    let l = n;
    n || (l = "anchor");
    const o = t.insert("g").attr("class", l).attr("id", e.domId || e.id), h = 1, { cssStyles: u } = e, d = yt.svg(o), f = bt(e, {
      fill: "black",
      stroke: "none",
      fillStyle: "solid"
    });
    e.look !== "handDrawn" && (f.roughness = 0);
    const p = d.circle(0, 0, h * 2, f), m = o.insert(() => p, ":first-child");
    return m.attr("class", "anchor").attr("style", Ze(u)), xt(e, m), e.intersect = function(b) {
      return it.info("Circle intersect", e, h, b), ft.circle(e, h, b);
    }, o;
  }
  v(IS, "anchor");
  function Kp(t, e, a, n, l, o, h) {
    const d = (t + a) / 2, f = (e + n) / 2, p = Math.atan2(n - e, a - t), m = (a - t) / 2, b = (n - e) / 2, x = m / l, _ = b / o, S = Math.sqrt(x ** 2 + _ ** 2);
    if (S > 1) throw new Error("The given radii are too small to create an arc between the points.");
    const w = Math.sqrt(1 - S ** 2), k = d + w * o * Math.sin(p) * (h ? -1 : 1), A = f - w * l * Math.cos(p) * (h ? -1 : 1), L = Math.atan2((e - A) / o, (t - k) / l);
    let O = Math.atan2((n - A) / o, (a - k) / l) - L;
    h && O < 0 && (O += 2 * Math.PI), !h && O > 0 && (O -= 2 * Math.PI);
    const W = [];
    for (let j = 0; j < 20; j++) {
      const et = j / 19, nt = L + et * O, lt = k + l * Math.cos(nt), X = A + o * Math.sin(nt);
      W.push({
        x: lt,
        y: X
      });
    }
    return W;
  }
  v(Kp, "generateArcPoints");
  async function PS(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o } = await At(t, e, Tt(e)), h = o.width + e.padding + 20, u = o.height + e.padding, d = u / 2, f = d / (2.5 + u / 50), { cssStyles: p } = e, m = [
      {
        x: h / 2,
        y: -u / 2
      },
      {
        x: -h / 2,
        y: -u / 2
      },
      ...Kp(-h / 2, -u / 2, -h / 2, u / 2, f, d, false),
      {
        x: h / 2,
        y: u / 2
      },
      ...Kp(h / 2, u / 2, h / 2, -u / 2, f, d, true)
    ], b = yt.svg(l), x = bt(e, {});
    e.look !== "handDrawn" && (x.roughness = 0, x.fillStyle = "solid");
    const _ = Ft(m), S = b.path(_, x), w = l.insert(() => S, ":first-child");
    return w.attr("class", "basic label-container"), p && e.look !== "handDrawn" && w.selectAll("path").attr("style", p), n && e.look !== "handDrawn" && w.selectAll("path").attr("style", n), w.attr("transform", `translate(${f / 2}, 0)`), xt(e, w), e.intersect = function(k) {
      return ft.polygon(e, m, k);
    }, l;
  }
  v(PS, "bowTieRect");
  function za(t, e, a, n) {
    return t.insert("polygon", ":first-child").attr("points", n.map(function(l) {
      return l.x + "," + l.y;
    }).join(" ")).attr("class", "label-container").attr("transform", "translate(" + -e / 2 + "," + a / 2 + ")");
  }
  v(za, "insertPolygonShape");
  async function GS(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o } = await At(t, e, Tt(e)), h = o.height + e.padding, u = 12, d = o.width + e.padding + u, f = 0, p = d, m = -h, b = 0, x = [
      {
        x: f + u,
        y: m
      },
      {
        x: p,
        y: m
      },
      {
        x: p,
        y: b
      },
      {
        x: f,
        y: b
      },
      {
        x: f,
        y: m + u
      },
      {
        x: f + u,
        y: m
      }
    ];
    let _;
    const { cssStyles: S } = e;
    if (e.look === "handDrawn") {
      const w = yt.svg(l), k = bt(e, {}), A = Ft(x), L = w.path(A, k);
      _ = l.insert(() => L, ":first-child").attr("transform", `translate(${-d / 2}, ${h / 2})`), S && _.attr("style", S);
    } else _ = za(l, d, h, x);
    return n && _.attr("style", n), xt(e, _), e.intersect = function(w) {
      return ft.polygon(e, x, w);
    }, l;
  }
  v(GS, "card");
  function WS(t, e) {
    const { nodeStyles: a } = vt(e);
    e.label = "";
    const n = t.insert("g").attr("class", Tt(e)).attr("id", e.domId ?? e.id), { cssStyles: l } = e, o = Math.max(28, e.width ?? 0), h = [
      {
        x: 0,
        y: o / 2
      },
      {
        x: o / 2,
        y: 0
      },
      {
        x: 0,
        y: -o / 2
      },
      {
        x: -o / 2,
        y: 0
      }
    ], u = yt.svg(n), d = bt(e, {});
    e.look !== "handDrawn" && (d.roughness = 0, d.fillStyle = "solid");
    const f = Ft(h), p = u.path(f, d), m = n.insert(() => p, ":first-child");
    return l && e.look !== "handDrawn" && m.selectAll("path").attr("style", l), a && e.look !== "handDrawn" && m.selectAll("path").attr("style", a), e.width = 28, e.height = 28, e.intersect = function(b) {
      return ft.polygon(e, h, b);
    }, n;
  }
  v(WS, "choice");
  async function a0(t, e, a) {
    const { labelStyles: n, nodeStyles: l } = vt(e);
    e.labelStyle = n;
    const { shapeSvg: o, bbox: h, halfPadding: u } = await At(t, e, Tt(e)), d = (a == null ? void 0 : a.padding) ?? u, f = h.width / 2 + d;
    let p;
    const { cssStyles: m } = e;
    if (e.look === "handDrawn") {
      const b = yt.svg(o), x = bt(e, {}), _ = b.circle(0, 0, f * 2, x);
      p = o.insert(() => _, ":first-child"), p.attr("class", "basic label-container").attr("style", Ze(m));
    } else p = o.insert("circle", ":first-child").attr("class", "basic label-container").attr("style", l).attr("r", f).attr("cx", 0).attr("cy", 0);
    return xt(e, p), e.calcIntersect = function(b, x) {
      const _ = b.width / 2;
      return ft.circle(b, _, x);
    }, e.intersect = function(b) {
      return it.info("Circle intersect", e, f, b), ft.circle(e, f, b);
    }, o;
  }
  v(a0, "circle");
  function XS(t) {
    const e = Math.cos(Math.PI / 4), a = Math.sin(Math.PI / 4), n = t * 2, l = {
      x: n / 2 * e,
      y: n / 2 * a
    }, o = {
      x: -(n / 2) * e,
      y: n / 2 * a
    }, h = {
      x: -(n / 2) * e,
      y: -(n / 2) * a
    }, u = {
      x: n / 2 * e,
      y: -(n / 2) * a
    };
    return `M ${o.x},${o.y} L ${u.x},${u.y}
                   M ${l.x},${l.y} L ${h.x},${h.y}`;
  }
  v(XS, "createLine");
  function VS(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a, e.label = "";
    const l = t.insert("g").attr("class", Tt(e)).attr("id", e.domId ?? e.id), o = Math.max(30, (e == null ? void 0 : e.width) ?? 0), { cssStyles: h } = e, u = yt.svg(l), d = bt(e, {});
    e.look !== "handDrawn" && (d.roughness = 0, d.fillStyle = "solid");
    const f = u.circle(0, 0, o * 2, d), p = XS(o), m = u.path(p, d), b = l.insert(() => f, ":first-child");
    return b.insert(() => m), h && e.look !== "handDrawn" && b.selectAll("path").attr("style", h), n && e.look !== "handDrawn" && b.selectAll("path").attr("style", n), xt(e, b), e.intersect = function(x) {
      return it.info("crossedCircle intersect", e, {
        radius: o,
        point: x
      }), ft.circle(e, o, x);
    }, l;
  }
  v(VS, "crossedCircle");
  function Ir(t, e, a, n = 100, l = 0, o = 180) {
    const h = [], u = l * Math.PI / 180, p = (o * Math.PI / 180 - u) / (n - 1);
    for (let m = 0; m < n; m++) {
      const b = u + m * p, x = t + a * Math.cos(b), _ = e + a * Math.sin(b);
      h.push({
        x: -x,
        y: -_
      });
    }
    return h;
  }
  v(Ir, "generateCirclePoints");
  async function ZS(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o, label: h } = await At(t, e, Tt(e)), u = o.width + (e.padding ?? 0), d = o.height + (e.padding ?? 0), f = Math.max(5, d * 0.1), { cssStyles: p } = e, m = [
      ...Ir(u / 2, -d / 2, f, 30, -90, 0),
      {
        x: -u / 2 - f,
        y: f
      },
      ...Ir(u / 2 + f * 2, -f, f, 20, -180, -270),
      ...Ir(u / 2 + f * 2, f, f, 20, -90, -180),
      {
        x: -u / 2 - f,
        y: -d / 2
      },
      ...Ir(u / 2, d / 2, f, 20, 0, 90)
    ], b = [
      {
        x: u / 2,
        y: -d / 2 - f
      },
      {
        x: -u / 2,
        y: -d / 2 - f
      },
      ...Ir(u / 2, -d / 2, f, 20, -90, 0),
      {
        x: -u / 2 - f,
        y: -f
      },
      ...Ir(u / 2 + u * 0.1, -f, f, 20, -180, -270),
      ...Ir(u / 2 + u * 0.1, f, f, 20, -90, -180),
      {
        x: -u / 2 - f,
        y: d / 2
      },
      ...Ir(u / 2, d / 2, f, 20, 0, 90),
      {
        x: -u / 2,
        y: d / 2 + f
      },
      {
        x: u / 2,
        y: d / 2 + f
      }
    ], x = yt.svg(l), _ = bt(e, {
      fill: "none"
    });
    e.look !== "handDrawn" && (_.roughness = 0, _.fillStyle = "solid");
    const w = Ft(m).replace("Z", ""), k = x.path(w, _), A = Ft(b), L = x.path(A, {
      ..._
    }), $ = l.insert("g", ":first-child");
    return $.insert(() => L, ":first-child").attr("stroke-opacity", 0), $.insert(() => k, ":first-child"), $.attr("class", "text"), p && e.look !== "handDrawn" && $.selectAll("path").attr("style", p), n && e.look !== "handDrawn" && $.selectAll("path").attr("style", n), $.attr("transform", `translate(${f}, 0)`), h.attr("transform", `translate(${-u / 2 + f - (o.x - (o.left ?? 0))},${-d / 2 + (e.padding ?? 0) / 2 - (o.y - (o.top ?? 0))})`), xt(e, $), e.intersect = function(O) {
      return ft.polygon(e, b, O);
    }, l;
  }
  v(ZS, "curlyBraceLeft");
  function Pr(t, e, a, n = 100, l = 0, o = 180) {
    const h = [], u = l * Math.PI / 180, p = (o * Math.PI / 180 - u) / (n - 1);
    for (let m = 0; m < n; m++) {
      const b = u + m * p, x = t + a * Math.cos(b), _ = e + a * Math.sin(b);
      h.push({
        x,
        y: _
      });
    }
    return h;
  }
  v(Pr, "generateCirclePoints");
  async function QS(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o, label: h } = await At(t, e, Tt(e)), u = o.width + (e.padding ?? 0), d = o.height + (e.padding ?? 0), f = Math.max(5, d * 0.1), { cssStyles: p } = e, m = [
      ...Pr(u / 2, -d / 2, f, 20, -90, 0),
      {
        x: u / 2 + f,
        y: -f
      },
      ...Pr(u / 2 + f * 2, -f, f, 20, -180, -270),
      ...Pr(u / 2 + f * 2, f, f, 20, -90, -180),
      {
        x: u / 2 + f,
        y: d / 2
      },
      ...Pr(u / 2, d / 2, f, 20, 0, 90)
    ], b = [
      {
        x: -u / 2,
        y: -d / 2 - f
      },
      {
        x: u / 2,
        y: -d / 2 - f
      },
      ...Pr(u / 2, -d / 2, f, 20, -90, 0),
      {
        x: u / 2 + f,
        y: -f
      },
      ...Pr(u / 2 + f * 2, -f, f, 20, -180, -270),
      ...Pr(u / 2 + f * 2, f, f, 20, -90, -180),
      {
        x: u / 2 + f,
        y: d / 2
      },
      ...Pr(u / 2, d / 2, f, 20, 0, 90),
      {
        x: u / 2,
        y: d / 2 + f
      },
      {
        x: -u / 2,
        y: d / 2 + f
      }
    ], x = yt.svg(l), _ = bt(e, {
      fill: "none"
    });
    e.look !== "handDrawn" && (_.roughness = 0, _.fillStyle = "solid");
    const w = Ft(m).replace("Z", ""), k = x.path(w, _), A = Ft(b), L = x.path(A, {
      ..._
    }), $ = l.insert("g", ":first-child");
    return $.insert(() => L, ":first-child").attr("stroke-opacity", 0), $.insert(() => k, ":first-child"), $.attr("class", "text"), p && e.look !== "handDrawn" && $.selectAll("path").attr("style", p), n && e.look !== "handDrawn" && $.selectAll("path").attr("style", n), $.attr("transform", `translate(${-f}, 0)`), h.attr("transform", `translate(${-u / 2 + (e.padding ?? 0) / 2 - (o.x - (o.left ?? 0))},${-d / 2 + (e.padding ?? 0) / 2 - (o.y - (o.top ?? 0))})`), xt(e, $), e.intersect = function(O) {
      return ft.polygon(e, b, O);
    }, l;
  }
  v(QS, "curlyBraceRight");
  function ze(t, e, a, n = 100, l = 0, o = 180) {
    const h = [], u = l * Math.PI / 180, p = (o * Math.PI / 180 - u) / (n - 1);
    for (let m = 0; m < n; m++) {
      const b = u + m * p, x = t + a * Math.cos(b), _ = e + a * Math.sin(b);
      h.push({
        x: -x,
        y: -_
      });
    }
    return h;
  }
  v(ze, "generateCirclePoints");
  async function KS(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o, label: h } = await At(t, e, Tt(e)), u = o.width + (e.padding ?? 0), d = o.height + (e.padding ?? 0), f = Math.max(5, d * 0.1), { cssStyles: p } = e, m = [
      ...ze(u / 2, -d / 2, f, 30, -90, 0),
      {
        x: -u / 2 - f,
        y: f
      },
      ...ze(u / 2 + f * 2, -f, f, 20, -180, -270),
      ...ze(u / 2 + f * 2, f, f, 20, -90, -180),
      {
        x: -u / 2 - f,
        y: -d / 2
      },
      ...ze(u / 2, d / 2, f, 20, 0, 90)
    ], b = [
      ...ze(-u / 2 + f + f / 2, -d / 2, f, 20, -90, -180),
      {
        x: u / 2 - f / 2,
        y: f
      },
      ...ze(-u / 2 - f / 2, -f, f, 20, 0, 90),
      ...ze(-u / 2 - f / 2, f, f, 20, -90, 0),
      {
        x: u / 2 - f / 2,
        y: -f
      },
      ...ze(-u / 2 + f + f / 2, d / 2, f, 30, -180, -270)
    ], x = [
      {
        x: u / 2,
        y: -d / 2 - f
      },
      {
        x: -u / 2,
        y: -d / 2 - f
      },
      ...ze(u / 2, -d / 2, f, 20, -90, 0),
      {
        x: -u / 2 - f,
        y: -f
      },
      ...ze(u / 2 + f * 2, -f, f, 20, -180, -270),
      ...ze(u / 2 + f * 2, f, f, 20, -90, -180),
      {
        x: -u / 2 - f,
        y: d / 2
      },
      ...ze(u / 2, d / 2, f, 20, 0, 90),
      {
        x: -u / 2,
        y: d / 2 + f
      },
      {
        x: u / 2 - f - f / 2,
        y: d / 2 + f
      },
      ...ze(-u / 2 + f + f / 2, -d / 2, f, 20, -90, -180),
      {
        x: u / 2 - f / 2,
        y: f
      },
      ...ze(-u / 2 - f / 2, -f, f, 20, 0, 90),
      ...ze(-u / 2 - f / 2, f, f, 20, -90, 0),
      {
        x: u / 2 - f / 2,
        y: -f
      },
      ...ze(-u / 2 + f + f / 2, d / 2, f, 30, -180, -270)
    ], _ = yt.svg(l), S = bt(e, {
      fill: "none"
    });
    e.look !== "handDrawn" && (S.roughness = 0, S.fillStyle = "solid");
    const k = Ft(m).replace("Z", ""), A = _.path(k, S), $ = Ft(b).replace("Z", ""), O = _.path($, S), W = Ft(x), j = _.path(W, {
      ...S
    }), et = l.insert("g", ":first-child");
    return et.insert(() => j, ":first-child").attr("stroke-opacity", 0), et.insert(() => A, ":first-child"), et.insert(() => O, ":first-child"), et.attr("class", "text"), p && e.look !== "handDrawn" && et.selectAll("path").attr("style", p), n && e.look !== "handDrawn" && et.selectAll("path").attr("style", n), et.attr("transform", `translate(${f - f / 4}, 0)`), h.attr("transform", `translate(${-u / 2 + (e.padding ?? 0) / 2 - (o.x - (o.left ?? 0))},${-d / 2 + (e.padding ?? 0) / 2 - (o.y - (o.top ?? 0))})`), xt(e, et), e.intersect = function(nt) {
      return ft.polygon(e, x, nt);
    }, l;
  }
  v(KS, "curlyBraces");
  async function JS(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o } = await At(t, e, Tt(e)), h = 80, u = 20, d = Math.max(h, (o.width + (e.padding ?? 0) * 2) * 1.25, (e == null ? void 0 : e.width) ?? 0), f = Math.max(u, o.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), p = f / 2, { cssStyles: m } = e, b = yt.svg(l), x = bt(e, {});
    e.look !== "handDrawn" && (x.roughness = 0, x.fillStyle = "solid");
    const _ = d, S = f, w = _ - p, k = S / 4, A = [
      {
        x: w,
        y: 0
      },
      {
        x: k,
        y: 0
      },
      {
        x: 0,
        y: S / 2
      },
      {
        x: k,
        y: S
      },
      {
        x: w,
        y: S
      },
      ..._o(-w, -S / 2, p, 50, 270, 90)
    ], L = Ft(A), $ = b.path(L, x), O = l.insert(() => $, ":first-child");
    return O.attr("class", "basic label-container"), m && e.look !== "handDrawn" && O.selectChildren("path").attr("style", m), n && e.look !== "handDrawn" && O.selectChildren("path").attr("style", n), O.attr("transform", `translate(${-d / 2}, ${-f / 2})`), xt(e, O), e.intersect = function(W) {
      return ft.polygon(e, A, W);
    }, l;
  }
  v(JS, "curvedTrapezoid");
  var o6 = v((t, e, a, n, l, o) => [
    `M${t},${e + o}`,
    `a${l},${o} 0,0,0 ${a},0`,
    `a${l},${o} 0,0,0 ${-a},0`,
    `l0,${n}`,
    `a${l},${o} 0,0,0 ${a},0`,
    `l0,${-n}`
  ].join(" "), "createCylinderPathD"), c6 = v((t, e, a, n, l, o) => [
    `M${t},${e + o}`,
    `M${t + a},${e + o}`,
    `a${l},${o} 0,0,0 ${-a},0`,
    `l0,${n}`,
    `a${l},${o} 0,0,0 ${a},0`,
    `l0,${-n}`
  ].join(" "), "createOuterCylinderPathD"), u6 = v((t, e, a, n, l, o) => [
    `M${t - a / 2},${-n / 2}`,
    `a${l},${o} 0,0,0 ${a},0`
  ].join(" "), "createInnerCylinderPathD");
  async function tC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o, label: h } = await At(t, e, Tt(e)), u = Math.max(o.width + e.padding, e.width ?? 0), d = u / 2, f = d / (2.5 + u / 50), p = Math.max(o.height + f + e.padding, e.height ?? 0);
    let m;
    const { cssStyles: b } = e;
    if (e.look === "handDrawn") {
      const x = yt.svg(l), _ = c6(0, 0, u, p, d, f), S = u6(0, f, u, p, d, f), w = x.path(_, bt(e, {})), k = x.path(S, bt(e, {
        fill: "none"
      }));
      m = l.insert(() => k, ":first-child"), m = l.insert(() => w, ":first-child"), m.attr("class", "basic label-container"), b && m.attr("style", b);
    } else {
      const x = o6(0, 0, u, p, d, f);
      m = l.insert("path", ":first-child").attr("d", x).attr("class", "basic label-container").attr("style", Ze(b)).attr("style", n);
    }
    return m.attr("label-offset-y", f), m.attr("transform", `translate(${-u / 2}, ${-(p / 2 + f)})`), xt(e, m), h.attr("transform", `translate(${-(o.width / 2) - (o.x - (o.left ?? 0))}, ${-(o.height / 2) + (e.padding ?? 0) / 1.5 - (o.y - (o.top ?? 0))})`), e.intersect = function(x) {
      const _ = ft.rect(e, x), S = _.x - (e.x ?? 0);
      if (d != 0 && (Math.abs(S) < (e.width ?? 0) / 2 || Math.abs(S) == (e.width ?? 0) / 2 && Math.abs(_.y - (e.y ?? 0)) > (e.height ?? 0) / 2 - f)) {
        let w = f * f * (1 - S * S / (d * d));
        w > 0 && (w = Math.sqrt(w)), w = f - w, x.y - (e.y ?? 0) > 0 && (w = -w), _.y += w;
      }
      return _;
    }, l;
  }
  v(tC, "cylinder");
  async function eC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o, label: h } = await At(t, e, Tt(e)), u = o.width + e.padding, d = o.height + e.padding, f = d * 0.2, p = -u / 2, m = -d / 2 - f / 2, { cssStyles: b } = e, x = yt.svg(l), _ = bt(e, {});
    e.look !== "handDrawn" && (_.roughness = 0, _.fillStyle = "solid");
    const S = [
      {
        x: p,
        y: m + f
      },
      {
        x: -p,
        y: m + f
      },
      {
        x: -p,
        y: -m
      },
      {
        x: p,
        y: -m
      },
      {
        x: p,
        y: m
      },
      {
        x: -p,
        y: m
      },
      {
        x: -p,
        y: m + f
      }
    ], w = x.polygon(S.map((A) => [
      A.x,
      A.y
    ]), _), k = l.insert(() => w, ":first-child");
    return k.attr("class", "basic label-container"), b && e.look !== "handDrawn" && k.selectAll("path").attr("style", b), n && e.look !== "handDrawn" && k.selectAll("path").attr("style", n), h.attr("transform", `translate(${p + (e.padding ?? 0) / 2 - (o.x - (o.left ?? 0))}, ${m + f + (e.padding ?? 0) / 2 - (o.y - (o.top ?? 0))})`), xt(e, k), e.intersect = function(A) {
      return ft.rect(e, A);
    }, l;
  }
  v(eC, "dividedRectangle");
  async function iC(t, e) {
    var _a2, _b2;
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o, halfPadding: h } = await At(t, e, Tt(e)), d = o.width / 2 + h + 5, f = o.width / 2 + h;
    let p;
    const { cssStyles: m } = e;
    if (e.look === "handDrawn") {
      const b = yt.svg(l), x = bt(e, {
        roughness: 0.2,
        strokeWidth: 2.5
      }), _ = bt(e, {
        roughness: 0.2,
        strokeWidth: 1.5
      }), S = b.circle(0, 0, d * 2, x), w = b.circle(0, 0, f * 2, _);
      p = l.insert("g", ":first-child"), p.attr("class", Ze(e.cssClasses)).attr("style", Ze(m)), (_a2 = p.node()) == null ? void 0 : _a2.appendChild(S), (_b2 = p.node()) == null ? void 0 : _b2.appendChild(w);
    } else {
      p = l.insert("g", ":first-child");
      const b = p.insert("circle", ":first-child"), x = p.insert("circle");
      p.attr("class", "basic label-container").attr("style", n), b.attr("class", "outer-circle").attr("style", n).attr("r", d).attr("cx", 0).attr("cy", 0), x.attr("class", "inner-circle").attr("style", n).attr("r", f).attr("cx", 0).attr("cy", 0);
    }
    return xt(e, p), e.intersect = function(b) {
      return it.info("DoubleCircle intersect", e, d, b), ft.circle(e, d, b);
    }, l;
  }
  v(iC, "doublecircle");
  function rC(t, e, { config: { themeVariables: a } }) {
    const { labelStyles: n, nodeStyles: l } = vt(e);
    e.label = "", e.labelStyle = n;
    const o = t.insert("g").attr("class", Tt(e)).attr("id", e.domId ?? e.id), h = 7, { cssStyles: u } = e, d = yt.svg(o), { nodeBorder: f } = a, p = bt(e, {
      fillStyle: "solid"
    });
    e.look !== "handDrawn" && (p.roughness = 0);
    const m = d.circle(0, 0, h * 2, p), b = o.insert(() => m, ":first-child");
    return b.selectAll("path").attr("style", `fill: ${f} !important;`), u && u.length > 0 && e.look !== "handDrawn" && b.selectAll("path").attr("style", u), l && e.look !== "handDrawn" && b.selectAll("path").attr("style", l), xt(e, b), e.intersect = function(x) {
      return it.info("filledCircle intersect", e, {
        radius: h,
        point: x
      }), ft.circle(e, h, x);
    }, o;
  }
  v(rC, "filledCircle");
  async function aC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o, label: h } = await At(t, e, Tt(e)), u = o.width + (e.padding ?? 0), d = u + o.height, f = u + o.height, p = [
      {
        x: 0,
        y: -d
      },
      {
        x: f,
        y: -d
      },
      {
        x: f / 2,
        y: 0
      }
    ], { cssStyles: m } = e, b = yt.svg(l), x = bt(e, {});
    e.look !== "handDrawn" && (x.roughness = 0, x.fillStyle = "solid");
    const _ = Ft(p), S = b.path(_, x), w = l.insert(() => S, ":first-child").attr("transform", `translate(${-d / 2}, ${d / 2})`);
    return m && e.look !== "handDrawn" && w.selectChildren("path").attr("style", m), n && e.look !== "handDrawn" && w.selectChildren("path").attr("style", n), e.width = u, e.height = d, xt(e, w), h.attr("transform", `translate(${-o.width / 2 - (o.x - (o.left ?? 0))}, ${-d / 2 + (e.padding ?? 0) / 2 + (o.y - (o.top ?? 0))})`), e.intersect = function(k) {
      return it.info("Triangle intersect", e, p, k), ft.polygon(e, p, k);
    }, l;
  }
  v(aC, "flippedTriangle");
  function nC(t, e, { dir: a, config: { state: n, themeVariables: l } }) {
    const { nodeStyles: o } = vt(e);
    e.label = "";
    const h = t.insert("g").attr("class", Tt(e)).attr("id", e.domId ?? e.id), { cssStyles: u } = e;
    let d = Math.max(70, (e == null ? void 0 : e.width) ?? 0), f = Math.max(10, (e == null ? void 0 : e.height) ?? 0);
    a === "LR" && (d = Math.max(10, (e == null ? void 0 : e.width) ?? 0), f = Math.max(70, (e == null ? void 0 : e.height) ?? 0));
    const p = -1 * d / 2, m = -1 * f / 2, b = yt.svg(h), x = bt(e, {
      stroke: l.lineColor,
      fill: l.lineColor
    });
    e.look !== "handDrawn" && (x.roughness = 0, x.fillStyle = "solid");
    const _ = b.rectangle(p, m, d, f, x), S = h.insert(() => _, ":first-child");
    u && e.look !== "handDrawn" && S.selectAll("path").attr("style", u), o && e.look !== "handDrawn" && S.selectAll("path").attr("style", o), xt(e, S);
    const w = (n == null ? void 0 : n.padding) ?? 0;
    return e.width && e.height && (e.width += w / 2 || 0, e.height += w / 2 || 0), e.intersect = function(k) {
      return ft.rect(e, k);
    }, h;
  }
  v(nC, "forkJoin");
  async function lC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const l = 80, o = 50, { shapeSvg: h, bbox: u } = await At(t, e, Tt(e)), d = Math.max(l, u.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), f = Math.max(o, u.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), p = f / 2, { cssStyles: m } = e, b = yt.svg(h), x = bt(e, {});
    e.look !== "handDrawn" && (x.roughness = 0, x.fillStyle = "solid");
    const _ = [
      {
        x: -d / 2,
        y: -f / 2
      },
      {
        x: d / 2 - p,
        y: -f / 2
      },
      ..._o(-d / 2 + p, 0, p, 50, 90, 270),
      {
        x: d / 2 - p,
        y: f / 2
      },
      {
        x: -d / 2,
        y: f / 2
      }
    ], S = Ft(_), w = b.path(S, x), k = h.insert(() => w, ":first-child");
    return k.attr("class", "basic label-container"), m && e.look !== "handDrawn" && k.selectChildren("path").attr("style", m), n && e.look !== "handDrawn" && k.selectChildren("path").attr("style", n), xt(e, k), e.intersect = function(A) {
      return it.info("Pill intersect", e, {
        radius: p,
        point: A
      }), ft.polygon(e, _, A);
    }, h;
  }
  v(lC, "halfRoundedRectangle");
  async function sC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o } = await At(t, e, Tt(e)), h = o.height + (e.padding ?? 0), u = o.width + (e.padding ?? 0) * 2.5, { cssStyles: d } = e, f = yt.svg(l), p = bt(e, {});
    e.look !== "handDrawn" && (p.roughness = 0, p.fillStyle = "solid");
    let m = u / 2;
    const b = m / 6;
    m = m + b;
    const x = h / 2, _ = x / 2, S = m - _, w = [
      {
        x: -S,
        y: -x
      },
      {
        x: 0,
        y: -x
      },
      {
        x: S,
        y: -x
      },
      {
        x: m,
        y: 0
      },
      {
        x: S,
        y: x
      },
      {
        x: 0,
        y: x
      },
      {
        x: -S,
        y: x
      },
      {
        x: -m,
        y: 0
      }
    ], k = Ft(w), A = f.path(k, p), L = l.insert(() => A, ":first-child");
    return L.attr("class", "basic label-container"), d && e.look !== "handDrawn" && L.selectChildren("path").attr("style", d), n && e.look !== "handDrawn" && L.selectChildren("path").attr("style", n), e.width = u, e.height = h, xt(e, L), e.intersect = function($) {
      return ft.polygon(e, w, $);
    }, l;
  }
  v(sC, "hexagon");
  async function oC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.label = "", e.labelStyle = a;
    const { shapeSvg: l } = await At(t, e, Tt(e)), o = Math.max(30, (e == null ? void 0 : e.width) ?? 0), h = Math.max(30, (e == null ? void 0 : e.height) ?? 0), { cssStyles: u } = e, d = yt.svg(l), f = bt(e, {});
    e.look !== "handDrawn" && (f.roughness = 0, f.fillStyle = "solid");
    const p = [
      {
        x: 0,
        y: 0
      },
      {
        x: o,
        y: 0
      },
      {
        x: 0,
        y: h
      },
      {
        x: o,
        y: h
      }
    ], m = Ft(p), b = d.path(m, f), x = l.insert(() => b, ":first-child");
    return x.attr("class", "basic label-container"), u && e.look !== "handDrawn" && x.selectChildren("path").attr("style", u), n && e.look !== "handDrawn" && x.selectChildren("path").attr("style", n), x.attr("transform", `translate(${-o / 2}, ${-h / 2})`), xt(e, x), e.intersect = function(_) {
      return it.info("Pill intersect", e, {
        points: p
      }), ft.polygon(e, p, _);
    }, l;
  }
  v(oC, "hourglass");
  async function cC(t, e, { config: { themeVariables: a, flowchart: n } }) {
    const { labelStyles: l } = vt(e);
    e.labelStyle = l;
    const o = e.assetHeight ?? 48, h = e.assetWidth ?? 48, u = Math.max(o, h), d = n == null ? void 0 : n.wrappingWidth;
    e.width = Math.max(u, d ?? 0);
    const { shapeSvg: f, bbox: p, label: m } = await At(t, e, "icon-shape default"), b = e.pos === "t", x = u, _ = u, { nodeBorder: S } = a, { stylesMap: w } = Ml(e), k = -_ / 2, A = -x / 2, L = e.label ? 8 : 0, $ = yt.svg(f), O = bt(e, {
      stroke: "none",
      fill: "none"
    });
    e.look !== "handDrawn" && (O.roughness = 0, O.fillStyle = "solid");
    const W = $.rectangle(k, A, _, x, O), j = Math.max(_, p.width), et = x + p.height + L, nt = $.rectangle(-j / 2, -et / 2, j, et, {
      ...O,
      fill: "transparent",
      stroke: "none"
    }), lt = f.insert(() => W, ":first-child"), X = f.insert(() => nt);
    if (e.icon) {
      const at = f.append("g");
      at.html(`<g>${await Oo(e.icon, {
        height: u,
        width: u,
        fallbackPrefix: ""
      })}</g>`);
      const rt = at.node().getBBox(), V = rt.width, G = rt.height, E = rt.x, N = rt.y;
      at.attr("transform", `translate(${-V / 2 - E},${b ? p.height / 2 + L / 2 - G / 2 - N : -p.height / 2 - L / 2 - G / 2 - N})`), at.attr("style", `color: ${w.get("stroke") ?? S};`);
    }
    return m.attr("transform", `translate(${-p.width / 2 - (p.x - (p.left ?? 0))},${b ? -et / 2 : et / 2 - p.height})`), lt.attr("transform", `translate(0,${b ? p.height / 2 + L / 2 : -p.height / 2 - L / 2})`), xt(e, X), e.intersect = function(at) {
      if (it.info("iconSquare intersect", e, at), !e.label) return ft.rect(e, at);
      const rt = e.x ?? 0, V = e.y ?? 0, G = e.height ?? 0;
      let E = [];
      return b ? E = [
        {
          x: rt - p.width / 2,
          y: V - G / 2
        },
        {
          x: rt + p.width / 2,
          y: V - G / 2
        },
        {
          x: rt + p.width / 2,
          y: V - G / 2 + p.height + L
        },
        {
          x: rt + _ / 2,
          y: V - G / 2 + p.height + L
        },
        {
          x: rt + _ / 2,
          y: V + G / 2
        },
        {
          x: rt - _ / 2,
          y: V + G / 2
        },
        {
          x: rt - _ / 2,
          y: V - G / 2 + p.height + L
        },
        {
          x: rt - p.width / 2,
          y: V - G / 2 + p.height + L
        }
      ] : E = [
        {
          x: rt - _ / 2,
          y: V - G / 2
        },
        {
          x: rt + _ / 2,
          y: V - G / 2
        },
        {
          x: rt + _ / 2,
          y: V - G / 2 + x
        },
        {
          x: rt + p.width / 2,
          y: V - G / 2 + x
        },
        {
          x: rt + p.width / 2 / 2,
          y: V + G / 2
        },
        {
          x: rt - p.width / 2,
          y: V + G / 2
        },
        {
          x: rt - p.width / 2,
          y: V - G / 2 + x
        },
        {
          x: rt - _ / 2,
          y: V - G / 2 + x
        }
      ], ft.polygon(e, E, at);
    }, f;
  }
  v(cC, "icon");
  async function uC(t, e, { config: { themeVariables: a, flowchart: n } }) {
    const { labelStyles: l } = vt(e);
    e.labelStyle = l;
    const o = e.assetHeight ?? 48, h = e.assetWidth ?? 48, u = Math.max(o, h), d = n == null ? void 0 : n.wrappingWidth;
    e.width = Math.max(u, d ?? 0);
    const { shapeSvg: f, bbox: p, label: m } = await At(t, e, "icon-shape default"), b = 20, x = e.label ? 8 : 0, _ = e.pos === "t", { nodeBorder: S, mainBkg: w } = a, { stylesMap: k } = Ml(e), A = yt.svg(f), L = bt(e, {});
    e.look !== "handDrawn" && (L.roughness = 0, L.fillStyle = "solid");
    const $ = k.get("fill");
    L.stroke = $ ?? w;
    const O = f.append("g");
    e.icon && O.html(`<g>${await Oo(e.icon, {
      height: u,
      width: u,
      fallbackPrefix: ""
    })}</g>`);
    const W = O.node().getBBox(), j = W.width, et = W.height, nt = W.x, lt = W.y, X = Math.max(j, et) * Math.SQRT2 + b * 2, at = A.circle(0, 0, X, L), rt = Math.max(X, p.width), V = X + p.height + x, G = A.rectangle(-rt / 2, -V / 2, rt, V, {
      ...L,
      fill: "transparent",
      stroke: "none"
    }), E = f.insert(() => at, ":first-child"), N = f.insert(() => G);
    return O.attr("transform", `translate(${-j / 2 - nt},${_ ? p.height / 2 + x / 2 - et / 2 - lt : -p.height / 2 - x / 2 - et / 2 - lt})`), O.attr("style", `color: ${k.get("stroke") ?? S};`), m.attr("transform", `translate(${-p.width / 2 - (p.x - (p.left ?? 0))},${_ ? -V / 2 : V / 2 - p.height})`), E.attr("transform", `translate(0,${_ ? p.height / 2 + x / 2 : -p.height / 2 - x / 2})`), xt(e, N), e.intersect = function(F) {
      return it.info("iconSquare intersect", e, F), ft.rect(e, F);
    }, f;
  }
  v(uC, "iconCircle");
  async function hC(t, e, { config: { themeVariables: a, flowchart: n } }) {
    const { labelStyles: l } = vt(e);
    e.labelStyle = l;
    const o = e.assetHeight ?? 48, h = e.assetWidth ?? 48, u = Math.max(o, h), d = n == null ? void 0 : n.wrappingWidth;
    e.width = Math.max(u, d ?? 0);
    const { shapeSvg: f, bbox: p, halfPadding: m, label: b } = await At(t, e, "icon-shape default"), x = e.pos === "t", _ = u + m * 2, S = u + m * 2, { nodeBorder: w, mainBkg: k } = a, { stylesMap: A } = Ml(e), L = -S / 2, $ = -_ / 2, O = e.label ? 8 : 0, W = yt.svg(f), j = bt(e, {});
    e.look !== "handDrawn" && (j.roughness = 0, j.fillStyle = "solid");
    const et = A.get("fill");
    j.stroke = et ?? k;
    const nt = W.path(Na(L, $, S, _, 5), j), lt = Math.max(S, p.width), X = _ + p.height + O, at = W.rectangle(-lt / 2, -X / 2, lt, X, {
      ...j,
      fill: "transparent",
      stroke: "none"
    }), rt = f.insert(() => nt, ":first-child").attr("class", "icon-shape2"), V = f.insert(() => at);
    if (e.icon) {
      const G = f.append("g");
      G.html(`<g>${await Oo(e.icon, {
        height: u,
        width: u,
        fallbackPrefix: ""
      })}</g>`);
      const E = G.node().getBBox(), N = E.width, F = E.height, ot = E.x, M = E.y;
      G.attr("transform", `translate(${-N / 2 - ot},${x ? p.height / 2 + O / 2 - F / 2 - M : -p.height / 2 - O / 2 - F / 2 - M})`), G.attr("style", `color: ${A.get("stroke") ?? w};`);
    }
    return b.attr("transform", `translate(${-p.width / 2 - (p.x - (p.left ?? 0))},${x ? -X / 2 : X / 2 - p.height})`), rt.attr("transform", `translate(0,${x ? p.height / 2 + O / 2 : -p.height / 2 - O / 2})`), xt(e, V), e.intersect = function(G) {
      if (it.info("iconSquare intersect", e, G), !e.label) return ft.rect(e, G);
      const E = e.x ?? 0, N = e.y ?? 0, F = e.height ?? 0;
      let ot = [];
      return x ? ot = [
        {
          x: E - p.width / 2,
          y: N - F / 2
        },
        {
          x: E + p.width / 2,
          y: N - F / 2
        },
        {
          x: E + p.width / 2,
          y: N - F / 2 + p.height + O
        },
        {
          x: E + S / 2,
          y: N - F / 2 + p.height + O
        },
        {
          x: E + S / 2,
          y: N + F / 2
        },
        {
          x: E - S / 2,
          y: N + F / 2
        },
        {
          x: E - S / 2,
          y: N - F / 2 + p.height + O
        },
        {
          x: E - p.width / 2,
          y: N - F / 2 + p.height + O
        }
      ] : ot = [
        {
          x: E - S / 2,
          y: N - F / 2
        },
        {
          x: E + S / 2,
          y: N - F / 2
        },
        {
          x: E + S / 2,
          y: N - F / 2 + _
        },
        {
          x: E + p.width / 2,
          y: N - F / 2 + _
        },
        {
          x: E + p.width / 2 / 2,
          y: N + F / 2
        },
        {
          x: E - p.width / 2,
          y: N + F / 2
        },
        {
          x: E - p.width / 2,
          y: N - F / 2 + _
        },
        {
          x: E - S / 2,
          y: N - F / 2 + _
        }
      ], ft.polygon(e, ot, G);
    }, f;
  }
  v(hC, "iconRounded");
  async function fC(t, e, { config: { themeVariables: a, flowchart: n } }) {
    const { labelStyles: l } = vt(e);
    e.labelStyle = l;
    const o = e.assetHeight ?? 48, h = e.assetWidth ?? 48, u = Math.max(o, h), d = n == null ? void 0 : n.wrappingWidth;
    e.width = Math.max(u, d ?? 0);
    const { shapeSvg: f, bbox: p, halfPadding: m, label: b } = await At(t, e, "icon-shape default"), x = e.pos === "t", _ = u + m * 2, S = u + m * 2, { nodeBorder: w, mainBkg: k } = a, { stylesMap: A } = Ml(e), L = -S / 2, $ = -_ / 2, O = e.label ? 8 : 0, W = yt.svg(f), j = bt(e, {});
    e.look !== "handDrawn" && (j.roughness = 0, j.fillStyle = "solid");
    const et = A.get("fill");
    j.stroke = et ?? k;
    const nt = W.path(Na(L, $, S, _, 0.1), j), lt = Math.max(S, p.width), X = _ + p.height + O, at = W.rectangle(-lt / 2, -X / 2, lt, X, {
      ...j,
      fill: "transparent",
      stroke: "none"
    }), rt = f.insert(() => nt, ":first-child"), V = f.insert(() => at);
    if (e.icon) {
      const G = f.append("g");
      G.html(`<g>${await Oo(e.icon, {
        height: u,
        width: u,
        fallbackPrefix: ""
      })}</g>`);
      const E = G.node().getBBox(), N = E.width, F = E.height, ot = E.x, M = E.y;
      G.attr("transform", `translate(${-N / 2 - ot},${x ? p.height / 2 + O / 2 - F / 2 - M : -p.height / 2 - O / 2 - F / 2 - M})`), G.attr("style", `color: ${A.get("stroke") ?? w};`);
    }
    return b.attr("transform", `translate(${-p.width / 2 - (p.x - (p.left ?? 0))},${x ? -X / 2 : X / 2 - p.height})`), rt.attr("transform", `translate(0,${x ? p.height / 2 + O / 2 : -p.height / 2 - O / 2})`), xt(e, V), e.intersect = function(G) {
      if (it.info("iconSquare intersect", e, G), !e.label) return ft.rect(e, G);
      const E = e.x ?? 0, N = e.y ?? 0, F = e.height ?? 0;
      let ot = [];
      return x ? ot = [
        {
          x: E - p.width / 2,
          y: N - F / 2
        },
        {
          x: E + p.width / 2,
          y: N - F / 2
        },
        {
          x: E + p.width / 2,
          y: N - F / 2 + p.height + O
        },
        {
          x: E + S / 2,
          y: N - F / 2 + p.height + O
        },
        {
          x: E + S / 2,
          y: N + F / 2
        },
        {
          x: E - S / 2,
          y: N + F / 2
        },
        {
          x: E - S / 2,
          y: N - F / 2 + p.height + O
        },
        {
          x: E - p.width / 2,
          y: N - F / 2 + p.height + O
        }
      ] : ot = [
        {
          x: E - S / 2,
          y: N - F / 2
        },
        {
          x: E + S / 2,
          y: N - F / 2
        },
        {
          x: E + S / 2,
          y: N - F / 2 + _
        },
        {
          x: E + p.width / 2,
          y: N - F / 2 + _
        },
        {
          x: E + p.width / 2 / 2,
          y: N + F / 2
        },
        {
          x: E - p.width / 2,
          y: N + F / 2
        },
        {
          x: E - p.width / 2,
          y: N - F / 2 + _
        },
        {
          x: E - S / 2,
          y: N - F / 2 + _
        }
      ], ft.polygon(e, ot, G);
    }, f;
  }
  v(fC, "iconSquare");
  async function dC(t, e, { config: { flowchart: a } }) {
    const n = new Image();
    n.src = (e == null ? void 0 : e.img) ?? "", await n.decode();
    const l = Number(n.naturalWidth.toString().replace("px", "")), o = Number(n.naturalHeight.toString().replace("px", ""));
    e.imageAspectRatio = l / o;
    const { labelStyles: h } = vt(e);
    e.labelStyle = h;
    const u = a == null ? void 0 : a.wrappingWidth;
    e.defaultWidth = a == null ? void 0 : a.wrappingWidth;
    const d = Math.max(e.label ? u ?? 0 : 0, (e == null ? void 0 : e.assetWidth) ?? l), f = e.constraint === "on" && (e == null ? void 0 : e.assetHeight) ? e.assetHeight * e.imageAspectRatio : d, p = e.constraint === "on" ? f / e.imageAspectRatio : (e == null ? void 0 : e.assetHeight) ?? o;
    e.width = Math.max(f, u ?? 0);
    const { shapeSvg: m, bbox: b, label: x } = await At(t, e, "image-shape default"), _ = e.pos === "t", S = -f / 2, w = -p / 2, k = e.label ? 8 : 0, A = yt.svg(m), L = bt(e, {});
    e.look !== "handDrawn" && (L.roughness = 0, L.fillStyle = "solid");
    const $ = A.rectangle(S, w, f, p, L), O = Math.max(f, b.width), W = p + b.height + k, j = A.rectangle(-O / 2, -W / 2, O, W, {
      ...L,
      fill: "none",
      stroke: "none"
    }), et = m.insert(() => $, ":first-child"), nt = m.insert(() => j);
    if (e.img) {
      const lt = m.append("image");
      lt.attr("href", e.img), lt.attr("width", f), lt.attr("height", p), lt.attr("preserveAspectRatio", "none"), lt.attr("transform", `translate(${-f / 2},${_ ? W / 2 - p : -W / 2})`);
    }
    return x.attr("transform", `translate(${-b.width / 2 - (b.x - (b.left ?? 0))},${_ ? -p / 2 - b.height / 2 - k / 2 : p / 2 - b.height / 2 + k / 2})`), et.attr("transform", `translate(0,${_ ? b.height / 2 + k / 2 : -b.height / 2 - k / 2})`), xt(e, nt), e.intersect = function(lt) {
      if (it.info("iconSquare intersect", e, lt), !e.label) return ft.rect(e, lt);
      const X = e.x ?? 0, at = e.y ?? 0, rt = e.height ?? 0;
      let V = [];
      return _ ? V = [
        {
          x: X - b.width / 2,
          y: at - rt / 2
        },
        {
          x: X + b.width / 2,
          y: at - rt / 2
        },
        {
          x: X + b.width / 2,
          y: at - rt / 2 + b.height + k
        },
        {
          x: X + f / 2,
          y: at - rt / 2 + b.height + k
        },
        {
          x: X + f / 2,
          y: at + rt / 2
        },
        {
          x: X - f / 2,
          y: at + rt / 2
        },
        {
          x: X - f / 2,
          y: at - rt / 2 + b.height + k
        },
        {
          x: X - b.width / 2,
          y: at - rt / 2 + b.height + k
        }
      ] : V = [
        {
          x: X - f / 2,
          y: at - rt / 2
        },
        {
          x: X + f / 2,
          y: at - rt / 2
        },
        {
          x: X + f / 2,
          y: at - rt / 2 + p
        },
        {
          x: X + b.width / 2,
          y: at - rt / 2 + p
        },
        {
          x: X + b.width / 2 / 2,
          y: at + rt / 2
        },
        {
          x: X - b.width / 2,
          y: at + rt / 2
        },
        {
          x: X - b.width / 2,
          y: at - rt / 2 + p
        },
        {
          x: X - f / 2,
          y: at - rt / 2 + p
        }
      ], ft.polygon(e, V, lt);
    }, m;
  }
  v(dC, "imageSquare");
  async function pC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o } = await At(t, e, Tt(e)), h = Math.max(o.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), u = Math.max(o.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), d = [
      {
        x: 0,
        y: 0
      },
      {
        x: h,
        y: 0
      },
      {
        x: h + 3 * u / 6,
        y: -u
      },
      {
        x: -3 * u / 6,
        y: -u
      }
    ];
    let f;
    const { cssStyles: p } = e;
    if (e.look === "handDrawn") {
      const m = yt.svg(l), b = bt(e, {}), x = Ft(d), _ = m.path(x, b);
      f = l.insert(() => _, ":first-child").attr("transform", `translate(${-h / 2}, ${u / 2})`), p && f.attr("style", p);
    } else f = za(l, h, u, d);
    return n && f.attr("style", n), e.width = h, e.height = u, xt(e, f), e.intersect = function(m) {
      return ft.polygon(e, d, m);
    }, l;
  }
  v(pC, "inv_trapezoid");
  async function Ch(t, e, a) {
    const { labelStyles: n, nodeStyles: l } = vt(e);
    e.labelStyle = n;
    const { shapeSvg: o, bbox: h } = await At(t, e, Tt(e)), u = Math.max(h.width + a.labelPaddingX * 2, (e == null ? void 0 : e.width) || 0), d = Math.max(h.height + a.labelPaddingY * 2, (e == null ? void 0 : e.height) || 0), f = -u / 2, p = -d / 2;
    let m, { rx: b, ry: x } = e;
    const { cssStyles: _ } = e;
    if ((a == null ? void 0 : a.rx) && a.ry && (b = a.rx, x = a.ry), e.look === "handDrawn") {
      const S = yt.svg(o), w = bt(e, {}), k = b || x ? S.path(Na(f, p, u, d, b || 0), w) : S.rectangle(f, p, u, d, w);
      m = o.insert(() => k, ":first-child"), m.attr("class", "basic label-container").attr("style", Ze(_));
    } else m = o.insert("rect", ":first-child"), m.attr("class", "basic label-container").attr("style", l).attr("rx", Ze(b)).attr("ry", Ze(x)).attr("x", f).attr("y", p).attr("width", u).attr("height", d);
    return xt(e, m), e.calcIntersect = function(S, w) {
      return ft.rect(S, w);
    }, e.intersect = function(S) {
      return ft.rect(e, S);
    }, o;
  }
  v(Ch, "drawRect");
  async function gC(t, e) {
    const { shapeSvg: a, bbox: n, label: l } = await At(t, e, "label"), o = a.insert("rect", ":first-child");
    return o.attr("width", 0.1).attr("height", 0.1), a.attr("class", "label edgeLabel"), l.attr("transform", `translate(${-(n.width / 2) - (n.x - (n.left ?? 0))}, ${-(n.height / 2) - (n.y - (n.top ?? 0))})`), xt(e, o), e.intersect = function(d) {
      return ft.rect(e, d);
    }, a;
  }
  v(gC, "labelRect");
  async function mC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o } = await At(t, e, Tt(e)), h = Math.max(o.width + (e.padding ?? 0), (e == null ? void 0 : e.width) ?? 0), u = Math.max(o.height + (e.padding ?? 0), (e == null ? void 0 : e.height) ?? 0), d = [
      {
        x: 0,
        y: 0
      },
      {
        x: h + 3 * u / 6,
        y: 0
      },
      {
        x: h,
        y: -u
      },
      {
        x: -(3 * u) / 6,
        y: -u
      }
    ];
    let f;
    const { cssStyles: p } = e;
    if (e.look === "handDrawn") {
      const m = yt.svg(l), b = bt(e, {}), x = Ft(d), _ = m.path(x, b);
      f = l.insert(() => _, ":first-child").attr("transform", `translate(${-h / 2}, ${u / 2})`), p && f.attr("style", p);
    } else f = za(l, h, u, d);
    return n && f.attr("style", n), e.width = h, e.height = u, xt(e, f), e.intersect = function(m) {
      return ft.polygon(e, d, m);
    }, l;
  }
  v(mC, "lean_left");
  async function yC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o } = await At(t, e, Tt(e)), h = Math.max(o.width + (e.padding ?? 0), (e == null ? void 0 : e.width) ?? 0), u = Math.max(o.height + (e.padding ?? 0), (e == null ? void 0 : e.height) ?? 0), d = [
      {
        x: -3 * u / 6,
        y: 0
      },
      {
        x: h,
        y: 0
      },
      {
        x: h + 3 * u / 6,
        y: -u
      },
      {
        x: 0,
        y: -u
      }
    ];
    let f;
    const { cssStyles: p } = e;
    if (e.look === "handDrawn") {
      const m = yt.svg(l), b = bt(e, {}), x = Ft(d), _ = m.path(x, b);
      f = l.insert(() => _, ":first-child").attr("transform", `translate(${-h / 2}, ${u / 2})`), p && f.attr("style", p);
    } else f = za(l, h, u, d);
    return n && f.attr("style", n), e.width = h, e.height = u, xt(e, f), e.intersect = function(m) {
      return ft.polygon(e, d, m);
    }, l;
  }
  v(yC, "lean_right");
  function bC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.label = "", e.labelStyle = a;
    const l = t.insert("g").attr("class", Tt(e)).attr("id", e.domId ?? e.id), { cssStyles: o } = e, h = Math.max(35, (e == null ? void 0 : e.width) ?? 0), u = Math.max(35, (e == null ? void 0 : e.height) ?? 0), d = 7, f = [
      {
        x: h,
        y: 0
      },
      {
        x: 0,
        y: u + d / 2
      },
      {
        x: h - 2 * d,
        y: u + d / 2
      },
      {
        x: 0,
        y: 2 * u
      },
      {
        x: h,
        y: u - d / 2
      },
      {
        x: 2 * d,
        y: u - d / 2
      }
    ], p = yt.svg(l), m = bt(e, {});
    e.look !== "handDrawn" && (m.roughness = 0, m.fillStyle = "solid");
    const b = Ft(f), x = p.path(b, m), _ = l.insert(() => x, ":first-child");
    return o && e.look !== "handDrawn" && _.selectAll("path").attr("style", o), n && e.look !== "handDrawn" && _.selectAll("path").attr("style", n), _.attr("transform", `translate(-${h / 2},${-u})`), xt(e, _), e.intersect = function(S) {
      return it.info("lightningBolt intersect", e, S), ft.polygon(e, f, S);
    }, l;
  }
  v(bC, "lightningBolt");
  var h6 = v((t, e, a, n, l, o, h) => [
    `M${t},${e + o}`,
    `a${l},${o} 0,0,0 ${a},0`,
    `a${l},${o} 0,0,0 ${-a},0`,
    `l0,${n}`,
    `a${l},${o} 0,0,0 ${a},0`,
    `l0,${-n}`,
    `M${t},${e + o + h}`,
    `a${l},${o} 0,0,0 ${a},0`
  ].join(" "), "createCylinderPathD"), f6 = v((t, e, a, n, l, o, h) => [
    `M${t},${e + o}`,
    `M${t + a},${e + o}`,
    `a${l},${o} 0,0,0 ${-a},0`,
    `l0,${n}`,
    `a${l},${o} 0,0,0 ${a},0`,
    `l0,${-n}`,
    `M${t},${e + o + h}`,
    `a${l},${o} 0,0,0 ${a},0`
  ].join(" "), "createOuterCylinderPathD"), d6 = v((t, e, a, n, l, o) => [
    `M${t - a / 2},${-n / 2}`,
    `a${l},${o} 0,0,0 ${a},0`
  ].join(" "), "createInnerCylinderPathD");
  async function xC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o, label: h } = await At(t, e, Tt(e)), u = Math.max(o.width + (e.padding ?? 0), e.width ?? 0), d = u / 2, f = d / (2.5 + u / 50), p = Math.max(o.height + f + (e.padding ?? 0), e.height ?? 0), m = p * 0.1;
    let b;
    const { cssStyles: x } = e;
    if (e.look === "handDrawn") {
      const _ = yt.svg(l), S = f6(0, 0, u, p, d, f, m), w = d6(0, f, u, p, d, f), k = bt(e, {}), A = _.path(S, k), L = _.path(w, k);
      l.insert(() => L, ":first-child").attr("class", "line"), b = l.insert(() => A, ":first-child"), b.attr("class", "basic label-container"), x && b.attr("style", x);
    } else {
      const _ = h6(0, 0, u, p, d, f, m);
      b = l.insert("path", ":first-child").attr("d", _).attr("class", "basic label-container").attr("style", Ze(x)).attr("style", n);
    }
    return b.attr("label-offset-y", f), b.attr("transform", `translate(${-u / 2}, ${-(p / 2 + f)})`), xt(e, b), h.attr("transform", `translate(${-(o.width / 2) - (o.x - (o.left ?? 0))}, ${-(o.height / 2) + f - (o.y - (o.top ?? 0))})`), e.intersect = function(_) {
      const S = ft.rect(e, _), w = S.x - (e.x ?? 0);
      if (d != 0 && (Math.abs(w) < (e.width ?? 0) / 2 || Math.abs(w) == (e.width ?? 0) / 2 && Math.abs(S.y - (e.y ?? 0)) > (e.height ?? 0) / 2 - f)) {
        let k = f * f * (1 - w * w / (d * d));
        k > 0 && (k = Math.sqrt(k)), k = f - k, _.y - (e.y ?? 0) > 0 && (k = -k), S.y += k;
      }
      return S;
    }, l;
  }
  v(xC, "linedCylinder");
  async function vC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o, label: h } = await At(t, e, Tt(e)), u = Math.max(o.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), d = Math.max(o.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), f = d / 4, p = d + f, { cssStyles: m } = e, b = yt.svg(l), x = bt(e, {});
    e.look !== "handDrawn" && (x.roughness = 0, x.fillStyle = "solid");
    const _ = [
      {
        x: -u / 2 - u / 2 * 0.1,
        y: -p / 2
      },
      {
        x: -u / 2 - u / 2 * 0.1,
        y: p / 2
      },
      ...Da(-u / 2 - u / 2 * 0.1, p / 2, u / 2 + u / 2 * 0.1, p / 2, f, 0.8),
      {
        x: u / 2 + u / 2 * 0.1,
        y: -p / 2
      },
      {
        x: -u / 2 - u / 2 * 0.1,
        y: -p / 2
      },
      {
        x: -u / 2,
        y: -p / 2
      },
      {
        x: -u / 2,
        y: p / 2 * 1.1
      },
      {
        x: -u / 2,
        y: -p / 2
      }
    ], S = b.polygon(_.map((k) => [
      k.x,
      k.y
    ]), x), w = l.insert(() => S, ":first-child");
    return w.attr("class", "basic label-container"), m && e.look !== "handDrawn" && w.selectAll("path").attr("style", m), n && e.look !== "handDrawn" && w.selectAll("path").attr("style", n), w.attr("transform", `translate(0,${-f / 2})`), h.attr("transform", `translate(${-u / 2 + (e.padding ?? 0) + u / 2 * 0.1 / 2 - (o.x - (o.left ?? 0))},${-d / 2 + (e.padding ?? 0) - f / 2 - (o.y - (o.top ?? 0))})`), xt(e, w), e.intersect = function(k) {
      return ft.polygon(e, _, k);
    }, l;
  }
  v(vC, "linedWaveEdgedRect");
  async function _C(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o, label: h } = await At(t, e, Tt(e)), u = Math.max(o.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), d = Math.max(o.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), f = 5, p = -u / 2, m = -d / 2, { cssStyles: b } = e, x = yt.svg(l), _ = bt(e, {}), S = [
      {
        x: p - f,
        y: m + f
      },
      {
        x: p - f,
        y: m + d + f
      },
      {
        x: p + u - f,
        y: m + d + f
      },
      {
        x: p + u - f,
        y: m + d
      },
      {
        x: p + u,
        y: m + d
      },
      {
        x: p + u,
        y: m + d - f
      },
      {
        x: p + u + f,
        y: m + d - f
      },
      {
        x: p + u + f,
        y: m - f
      },
      {
        x: p + f,
        y: m - f
      },
      {
        x: p + f,
        y: m
      },
      {
        x: p,
        y: m
      },
      {
        x: p,
        y: m + f
      }
    ], w = [
      {
        x: p,
        y: m + f
      },
      {
        x: p + u - f,
        y: m + f
      },
      {
        x: p + u - f,
        y: m + d
      },
      {
        x: p + u,
        y: m + d
      },
      {
        x: p + u,
        y: m
      },
      {
        x: p,
        y: m
      }
    ];
    e.look !== "handDrawn" && (_.roughness = 0, _.fillStyle = "solid");
    const k = Ft(S), A = x.path(k, _), L = Ft(w), $ = x.path(L, {
      ..._,
      fill: "none"
    }), O = l.insert(() => $, ":first-child");
    return O.insert(() => A, ":first-child"), O.attr("class", "basic label-container"), b && e.look !== "handDrawn" && O.selectAll("path").attr("style", b), n && e.look !== "handDrawn" && O.selectAll("path").attr("style", n), h.attr("transform", `translate(${-(o.width / 2) - f - (o.x - (o.left ?? 0))}, ${-(o.height / 2) + f - (o.y - (o.top ?? 0))})`), xt(e, O), e.intersect = function(W) {
      return ft.polygon(e, S, W);
    }, l;
  }
  v(_C, "multiRect");
  async function SC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o, label: h } = await At(t, e, Tt(e)), u = Math.max(o.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), d = Math.max(o.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), f = d / 4, p = d + f, m = -u / 2, b = -p / 2, x = 5, { cssStyles: _ } = e, S = Da(m - x, b + p + x, m + u - x, b + p + x, f, 0.8), w = S == null ? void 0 : S[S.length - 1], k = [
      {
        x: m - x,
        y: b + x
      },
      {
        x: m - x,
        y: b + p + x
      },
      ...S,
      {
        x: m + u - x,
        y: w.y - x
      },
      {
        x: m + u,
        y: w.y - x
      },
      {
        x: m + u,
        y: w.y - 2 * x
      },
      {
        x: m + u + x,
        y: w.y - 2 * x
      },
      {
        x: m + u + x,
        y: b - x
      },
      {
        x: m + x,
        y: b - x
      },
      {
        x: m + x,
        y: b
      },
      {
        x: m,
        y: b
      },
      {
        x: m,
        y: b + x
      }
    ], A = [
      {
        x: m,
        y: b + x
      },
      {
        x: m + u - x,
        y: b + x
      },
      {
        x: m + u - x,
        y: w.y - x
      },
      {
        x: m + u,
        y: w.y - x
      },
      {
        x: m + u,
        y: b
      },
      {
        x: m,
        y: b
      }
    ], L = yt.svg(l), $ = bt(e, {});
    e.look !== "handDrawn" && ($.roughness = 0, $.fillStyle = "solid");
    const O = Ft(k), W = L.path(O, $), j = Ft(A), et = L.path(j, $), nt = l.insert(() => W, ":first-child");
    return nt.insert(() => et), nt.attr("class", "basic label-container"), _ && e.look !== "handDrawn" && nt.selectAll("path").attr("style", _), n && e.look !== "handDrawn" && nt.selectAll("path").attr("style", n), nt.attr("transform", `translate(0,${-f / 2})`), h.attr("transform", `translate(${-(o.width / 2) - x - (o.x - (o.left ?? 0))}, ${-(o.height / 2) + x - f / 2 - (o.y - (o.top ?? 0))})`), xt(e, nt), e.intersect = function(lt) {
      return ft.polygon(e, k, lt);
    }, l;
  }
  v(SC, "multiWaveEdgedRectangle");
  async function CC(t, e, { config: { themeVariables: a } }) {
    var _a2;
    const { labelStyles: n, nodeStyles: l } = vt(e);
    e.labelStyle = n, e.useHtmlLabels || ((_a2 = Xe().flowchart) == null ? void 0 : _a2.htmlLabels) !== false || (e.centerLabel = true);
    const { shapeSvg: h, bbox: u, label: d } = await At(t, e, Tt(e)), f = Math.max(u.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), p = Math.max(u.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), m = -f / 2, b = -p / 2, { cssStyles: x } = e, _ = yt.svg(h), S = bt(e, {
      fill: a.noteBkgColor,
      stroke: a.noteBorderColor
    });
    e.look !== "handDrawn" && (S.roughness = 0, S.fillStyle = "solid");
    const w = _.rectangle(m, b, f, p, S), k = h.insert(() => w, ":first-child");
    return k.attr("class", "basic label-container"), x && e.look !== "handDrawn" && k.selectAll("path").attr("style", x), l && e.look !== "handDrawn" && k.selectAll("path").attr("style", l), d.attr("transform", `translate(${-u.width / 2 - (u.x - (u.left ?? 0))}, ${-(u.height / 2) - (u.y - (u.top ?? 0))})`), xt(e, k), e.intersect = function(A) {
      return ft.rect(e, A);
    }, h;
  }
  v(CC, "note");
  var p6 = v((t, e, a) => [
    `M${t + a / 2},${e}`,
    `L${t + a},${e - a / 2}`,
    `L${t + a / 2},${e - a}`,
    `L${t},${e - a / 2}`,
    "Z"
  ].join(" "), "createDecisionBoxPathD");
  async function wC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o } = await At(t, e, Tt(e)), h = o.width + e.padding, u = o.height + e.padding, d = h + u, f = 0.5, p = [
      {
        x: d / 2,
        y: 0
      },
      {
        x: d,
        y: -d / 2
      },
      {
        x: d / 2,
        y: -d
      },
      {
        x: 0,
        y: -d / 2
      }
    ];
    let m;
    const { cssStyles: b } = e;
    if (e.look === "handDrawn") {
      const x = yt.svg(l), _ = bt(e, {}), S = p6(0, 0, d), w = x.path(S, _);
      m = l.insert(() => w, ":first-child").attr("transform", `translate(${-d / 2 + f}, ${d / 2})`), b && m.attr("style", b);
    } else m = za(l, d, d, p), m.attr("transform", `translate(${-d / 2 + f}, ${d / 2})`);
    return n && m.attr("style", n), xt(e, m), e.calcIntersect = function(x, _) {
      const S = x.width, w = [
        {
          x: S / 2,
          y: 0
        },
        {
          x: S,
          y: -S / 2
        },
        {
          x: S / 2,
          y: -S
        },
        {
          x: 0,
          y: -S / 2
        }
      ], k = ft.polygon(x, w, _);
      return {
        x: k.x - 0.5,
        y: k.y - 0.5
      };
    }, e.intersect = function(x) {
      return this.calcIntersect(e, x);
    }, l;
  }
  v(wC, "question");
  async function TC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o, label: h } = await At(t, e, Tt(e)), u = Math.max(o.width + (e.padding ?? 0), (e == null ? void 0 : e.width) ?? 0), d = Math.max(o.height + (e.padding ?? 0), (e == null ? void 0 : e.height) ?? 0), f = -u / 2, p = -d / 2, m = p / 2, b = [
      {
        x: f + m,
        y: p
      },
      {
        x: f,
        y: 0
      },
      {
        x: f + m,
        y: -p
      },
      {
        x: -f,
        y: -p
      },
      {
        x: -f,
        y: p
      }
    ], { cssStyles: x } = e, _ = yt.svg(l), S = bt(e, {});
    e.look !== "handDrawn" && (S.roughness = 0, S.fillStyle = "solid");
    const w = Ft(b), k = _.path(w, S), A = l.insert(() => k, ":first-child");
    return A.attr("class", "basic label-container"), x && e.look !== "handDrawn" && A.selectAll("path").attr("style", x), n && e.look !== "handDrawn" && A.selectAll("path").attr("style", n), A.attr("transform", `translate(${-m / 2},0)`), h.attr("transform", `translate(${-m / 2 - o.width / 2 - (o.x - (o.left ?? 0))}, ${-(o.height / 2) - (o.y - (o.top ?? 0))})`), xt(e, A), e.intersect = function(L) {
      return ft.polygon(e, b, L);
    }, l;
  }
  v(TC, "rect_left_inv_arrow");
  async function kC(t, e) {
    var _a2, _b2;
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    let l;
    e.cssClasses ? l = "node " + e.cssClasses : l = "node default";
    const o = t.insert("g").attr("class", l).attr("id", e.domId || e.id), h = o.insert("g"), u = o.insert("g").attr("class", "label").attr("style", n), d = e.description, f = e.label, p = u.node().appendChild(await pn(f, e.labelStyle, true, true));
    let m = {
      width: 0,
      height: 0
    };
    if (Ee((_b2 = (_a2 = Pt()) == null ? void 0 : _a2.flowchart) == null ? void 0 : _b2.htmlLabels)) {
      const et = p.children[0], nt = jt(p);
      m = et.getBoundingClientRect(), nt.attr("width", m.width), nt.attr("height", m.height);
    }
    it.info("Text 2", d);
    const b = d || [], x = p.getBBox(), _ = u.node().appendChild(await pn(b.join ? b.join("<br/>") : b, e.labelStyle, true, true)), S = _.children[0], w = jt(_);
    m = S.getBoundingClientRect(), w.attr("width", m.width), w.attr("height", m.height);
    const k = (e.padding || 0) / 2;
    jt(_).attr("transform", "translate( " + (m.width > x.width ? 0 : (x.width - m.width) / 2) + ", " + (x.height + k + 5) + ")"), jt(p).attr("transform", "translate( " + (m.width < x.width ? 0 : -(x.width - m.width) / 2) + ", 0)"), m = u.node().getBBox(), u.attr("transform", "translate(" + -m.width / 2 + ", " + (-m.height / 2 - k + 3) + ")");
    const A = m.width + (e.padding || 0), L = m.height + (e.padding || 0), $ = -m.width / 2 - k, O = -m.height / 2 - k;
    let W, j;
    if (e.look === "handDrawn") {
      const et = yt.svg(o), nt = bt(e, {}), lt = et.path(Na($, O, A, L, e.rx || 0), nt), X = et.line(-m.width / 2 - k, -m.height / 2 - k + x.height + k, m.width / 2 + k, -m.height / 2 - k + x.height + k, nt);
      j = o.insert(() => (it.debug("Rough node insert CXC", lt), X), ":first-child"), W = o.insert(() => (it.debug("Rough node insert CXC", lt), lt), ":first-child");
    } else W = h.insert("rect", ":first-child"), j = h.insert("line"), W.attr("class", "outer title-state").attr("style", n).attr("x", -m.width / 2 - k).attr("y", -m.height / 2 - k).attr("width", m.width + (e.padding || 0)).attr("height", m.height + (e.padding || 0)), j.attr("class", "divider").attr("x1", -m.width / 2 - k).attr("x2", m.width / 2 + k).attr("y1", -m.height / 2 - k + x.height + k).attr("y2", -m.height / 2 - k + x.height + k);
    return xt(e, W), e.intersect = function(et) {
      return ft.rect(e, et);
    }, o;
  }
  v(kC, "rectWithTitle");
  function eo(t, e, a, n, l, o, h) {
    const d = (t + a) / 2, f = (e + n) / 2, p = Math.atan2(n - e, a - t), m = (a - t) / 2, b = (n - e) / 2, x = m / l, _ = b / o, S = Math.sqrt(x ** 2 + _ ** 2);
    if (S > 1) throw new Error("The given radii are too small to create an arc between the points.");
    const w = Math.sqrt(1 - S ** 2), k = d + w * o * Math.sin(p) * (h ? -1 : 1), A = f - w * l * Math.cos(p) * (h ? -1 : 1), L = Math.atan2((e - A) / o, (t - k) / l);
    let O = Math.atan2((n - A) / o, (a - k) / l) - L;
    h && O < 0 && (O += 2 * Math.PI), !h && O > 0 && (O -= 2 * Math.PI);
    const W = [];
    for (let j = 0; j < 20; j++) {
      const et = j / 19, nt = L + et * O, lt = k + l * Math.cos(nt), X = A + o * Math.sin(nt);
      W.push({
        x: lt,
        y: X
      });
    }
    return W;
  }
  v(eo, "generateArcPoints");
  async function AC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o } = await At(t, e, Tt(e)), h = (e == null ? void 0 : e.padding) ?? 0, u = (e == null ? void 0 : e.padding) ?? 0, d = ((e == null ? void 0 : e.width) ? e == null ? void 0 : e.width : o.width) + h * 2, f = ((e == null ? void 0 : e.height) ? e == null ? void 0 : e.height : o.height) + u * 2, p = e.radius || 5, m = e.taper || 5, { cssStyles: b } = e, x = yt.svg(l), _ = bt(e, {});
    e.stroke && (_.stroke = e.stroke), e.look !== "handDrawn" && (_.roughness = 0, _.fillStyle = "solid");
    const S = [
      {
        x: -d / 2 + m,
        y: -f / 2
      },
      {
        x: d / 2 - m,
        y: -f / 2
      },
      ...eo(d / 2 - m, -f / 2, d / 2, -f / 2 + m, p, p, true),
      {
        x: d / 2,
        y: -f / 2 + m
      },
      {
        x: d / 2,
        y: f / 2 - m
      },
      ...eo(d / 2, f / 2 - m, d / 2 - m, f / 2, p, p, true),
      {
        x: d / 2 - m,
        y: f / 2
      },
      {
        x: -d / 2 + m,
        y: f / 2
      },
      ...eo(-d / 2 + m, f / 2, -d / 2, f / 2 - m, p, p, true),
      {
        x: -d / 2,
        y: f / 2 - m
      },
      {
        x: -d / 2,
        y: -f / 2 + m
      },
      ...eo(-d / 2, -f / 2 + m, -d / 2 + m, -f / 2, p, p, true)
    ], w = Ft(S), k = x.path(w, _), A = l.insert(() => k, ":first-child");
    return A.attr("class", "basic label-container outer-path"), b && e.look !== "handDrawn" && A.selectChildren("path").attr("style", b), n && e.look !== "handDrawn" && A.selectChildren("path").attr("style", n), xt(e, A), e.intersect = function(L) {
      return ft.polygon(e, S, L);
    }, l;
  }
  v(AC, "roundedRect");
  async function EC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o, label: h } = await At(t, e, Tt(e)), u = (e == null ? void 0 : e.padding) ?? 0, d = Math.max(o.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), f = Math.max(o.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), p = -o.width / 2 - u, m = -o.height / 2 - u, { cssStyles: b } = e, x = yt.svg(l), _ = bt(e, {});
    e.look !== "handDrawn" && (_.roughness = 0, _.fillStyle = "solid");
    const S = [
      {
        x: p,
        y: m
      },
      {
        x: p + d + 8,
        y: m
      },
      {
        x: p + d + 8,
        y: m + f
      },
      {
        x: p - 8,
        y: m + f
      },
      {
        x: p - 8,
        y: m
      },
      {
        x: p,
        y: m
      },
      {
        x: p,
        y: m + f
      }
    ], w = x.polygon(S.map((A) => [
      A.x,
      A.y
    ]), _), k = l.insert(() => w, ":first-child");
    return k.attr("class", "basic label-container").attr("style", Ze(b)), n && e.look !== "handDrawn" && k.selectAll("path").attr("style", n), b && e.look !== "handDrawn" && k.selectAll("path").attr("style", n), h.attr("transform", `translate(${-d / 2 + 4 + (e.padding ?? 0) - (o.x - (o.left ?? 0))},${-f / 2 + (e.padding ?? 0) - (o.y - (o.top ?? 0))})`), xt(e, k), e.intersect = function(A) {
      return ft.rect(e, A);
    }, l;
  }
  v(EC, "shadedProcess");
  async function MC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o, label: h } = await At(t, e, Tt(e)), u = Math.max(o.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), d = Math.max(o.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), f = -u / 2, p = -d / 2, { cssStyles: m } = e, b = yt.svg(l), x = bt(e, {});
    e.look !== "handDrawn" && (x.roughness = 0, x.fillStyle = "solid");
    const _ = [
      {
        x: f,
        y: p
      },
      {
        x: f,
        y: p + d
      },
      {
        x: f + u,
        y: p + d
      },
      {
        x: f + u,
        y: p - d / 2
      }
    ], S = Ft(_), w = b.path(S, x), k = l.insert(() => w, ":first-child");
    return k.attr("class", "basic label-container"), m && e.look !== "handDrawn" && k.selectChildren("path").attr("style", m), n && e.look !== "handDrawn" && k.selectChildren("path").attr("style", n), k.attr("transform", `translate(0, ${d / 4})`), h.attr("transform", `translate(${-u / 2 + (e.padding ?? 0) - (o.x - (o.left ?? 0))}, ${-d / 4 + (e.padding ?? 0) - (o.y - (o.top ?? 0))})`), xt(e, k), e.intersect = function(A) {
      return ft.polygon(e, _, A);
    }, l;
  }
  v(MC, "slopedRect");
  async function BC(t, e) {
    const a = {
      rx: 0,
      ry: 0,
      labelPaddingX: e.labelPaddingX ?? ((e == null ? void 0 : e.padding) || 0) * 2,
      labelPaddingY: ((e == null ? void 0 : e.padding) || 0) * 1
    };
    return Ch(t, e, a);
  }
  v(BC, "squareRect");
  async function LC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o } = await At(t, e, Tt(e)), h = o.height + e.padding, u = o.width + h / 4 + e.padding, d = h / 2, { cssStyles: f } = e, p = yt.svg(l), m = bt(e, {});
    e.look !== "handDrawn" && (m.roughness = 0, m.fillStyle = "solid");
    const b = [
      {
        x: -u / 2 + d,
        y: -h / 2
      },
      {
        x: u / 2 - d,
        y: -h / 2
      },
      ..._o(-u / 2 + d, 0, d, 50, 90, 270),
      {
        x: u / 2 - d,
        y: h / 2
      },
      ..._o(u / 2 - d, 0, d, 50, 270, 450)
    ], x = Ft(b), _ = p.path(x, m), S = l.insert(() => _, ":first-child");
    return S.attr("class", "basic label-container outer-path"), f && e.look !== "handDrawn" && S.selectChildren("path").attr("style", f), n && e.look !== "handDrawn" && S.selectChildren("path").attr("style", n), xt(e, S), e.intersect = function(w) {
      return ft.polygon(e, b, w);
    }, l;
  }
  v(LC, "stadium");
  async function OC(t, e) {
    return Ch(t, e, {
      rx: 5,
      ry: 5
    });
  }
  v(OC, "state");
  function DC(t, e, { config: { themeVariables: a } }) {
    const { labelStyles: n, nodeStyles: l } = vt(e);
    e.labelStyle = n;
    const { cssStyles: o } = e, { lineColor: h, stateBorder: u, nodeBorder: d } = a, f = t.insert("g").attr("class", "node default").attr("id", e.domId || e.id), p = yt.svg(f), m = bt(e, {});
    e.look !== "handDrawn" && (m.roughness = 0, m.fillStyle = "solid");
    const b = p.circle(0, 0, 14, {
      ...m,
      stroke: h,
      strokeWidth: 2
    }), x = u ?? d, _ = p.circle(0, 0, 5, {
      ...m,
      fill: x,
      stroke: x,
      strokeWidth: 2,
      fillStyle: "solid"
    }), S = f.insert(() => b, ":first-child");
    return S.insert(() => _), o && S.selectAll("path").attr("style", o), l && S.selectAll("path").attr("style", l), xt(e, S), e.intersect = function(w) {
      return ft.circle(e, 7, w);
    }, f;
  }
  v(DC, "stateEnd");
  function RC(t, e, { config: { themeVariables: a } }) {
    const { lineColor: n } = a, l = t.insert("g").attr("class", "node default").attr("id", e.domId || e.id);
    let o;
    if (e.look === "handDrawn") {
      const u = yt.svg(l).circle(0, 0, 14, M5(n));
      o = l.insert(() => u), o.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);
    } else o = l.insert("circle", ":first-child"), o.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);
    return xt(e, o), e.intersect = function(h) {
      return ft.circle(e, 7, h);
    }, l;
  }
  v(RC, "stateStart");
  async function $C(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o } = await At(t, e, Tt(e)), h = ((e == null ? void 0 : e.padding) || 0) / 2, u = o.width + e.padding, d = o.height + e.padding, f = -o.width / 2 - h, p = -o.height / 2 - h, m = [
      {
        x: 0,
        y: 0
      },
      {
        x: u,
        y: 0
      },
      {
        x: u,
        y: -d
      },
      {
        x: 0,
        y: -d
      },
      {
        x: 0,
        y: 0
      },
      {
        x: -8,
        y: 0
      },
      {
        x: u + 8,
        y: 0
      },
      {
        x: u + 8,
        y: -d
      },
      {
        x: -8,
        y: -d
      },
      {
        x: -8,
        y: 0
      }
    ];
    if (e.look === "handDrawn") {
      const b = yt.svg(l), x = bt(e, {}), _ = b.rectangle(f - 8, p, u + 16, d, x), S = b.line(f, p, f, p + d, x), w = b.line(f + u, p, f + u, p + d, x);
      l.insert(() => S, ":first-child"), l.insert(() => w, ":first-child");
      const k = l.insert(() => _, ":first-child"), { cssStyles: A } = e;
      k.attr("class", "basic label-container").attr("style", Ze(A)), xt(e, k);
    } else {
      const b = za(l, u, d, m);
      n && b.attr("style", n), xt(e, b);
    }
    return e.intersect = function(b) {
      return ft.polygon(e, m, b);
    }, l;
  }
  v($C, "subroutine");
  async function NC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o } = await At(t, e, Tt(e)), h = Math.max(o.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), u = Math.max(o.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), d = -h / 2, f = -u / 2, p = 0.2 * u, m = 0.2 * u, { cssStyles: b } = e, x = yt.svg(l), _ = bt(e, {}), S = [
      {
        x: d - p / 2,
        y: f
      },
      {
        x: d + h + p / 2,
        y: f
      },
      {
        x: d + h + p / 2,
        y: f + u
      },
      {
        x: d - p / 2,
        y: f + u
      }
    ], w = [
      {
        x: d + h - p / 2,
        y: f + u
      },
      {
        x: d + h + p / 2,
        y: f + u
      },
      {
        x: d + h + p / 2,
        y: f + u - m
      }
    ];
    e.look !== "handDrawn" && (_.roughness = 0, _.fillStyle = "solid");
    const k = Ft(S), A = x.path(k, _), L = Ft(w), $ = x.path(L, {
      ..._,
      fillStyle: "solid"
    }), O = l.insert(() => $, ":first-child");
    return O.insert(() => A, ":first-child"), O.attr("class", "basic label-container"), b && e.look !== "handDrawn" && O.selectAll("path").attr("style", b), n && e.look !== "handDrawn" && O.selectAll("path").attr("style", n), xt(e, O), e.intersect = function(W) {
      return ft.polygon(e, S, W);
    }, l;
  }
  v(NC, "taggedRect");
  async function zC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o, label: h } = await At(t, e, Tt(e)), u = Math.max(o.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), d = Math.max(o.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), f = d / 4, p = 0.2 * u, m = 0.2 * d, b = d + f, { cssStyles: x } = e, _ = yt.svg(l), S = bt(e, {});
    e.look !== "handDrawn" && (S.roughness = 0, S.fillStyle = "solid");
    const w = [
      {
        x: -u / 2 - u / 2 * 0.1,
        y: b / 2
      },
      ...Da(-u / 2 - u / 2 * 0.1, b / 2, u / 2 + u / 2 * 0.1, b / 2, f, 0.8),
      {
        x: u / 2 + u / 2 * 0.1,
        y: -b / 2
      },
      {
        x: -u / 2 - u / 2 * 0.1,
        y: -b / 2
      }
    ], k = -u / 2 + u / 2 * 0.1, A = -b / 2 - m * 0.4, L = [
      {
        x: k + u - p,
        y: (A + d) * 1.4
      },
      {
        x: k + u,
        y: A + d - m
      },
      {
        x: k + u,
        y: (A + d) * 0.9
      },
      ...Da(k + u, (A + d) * 1.3, k + u - p, (A + d) * 1.5, -d * 0.03, 0.5)
    ], $ = Ft(w), O = _.path($, S), W = Ft(L), j = _.path(W, {
      ...S,
      fillStyle: "solid"
    }), et = l.insert(() => j, ":first-child");
    return et.insert(() => O, ":first-child"), et.attr("class", "basic label-container"), x && e.look !== "handDrawn" && et.selectAll("path").attr("style", x), n && e.look !== "handDrawn" && et.selectAll("path").attr("style", n), et.attr("transform", `translate(0,${-f / 2})`), h.attr("transform", `translate(${-u / 2 + (e.padding ?? 0) - (o.x - (o.left ?? 0))},${-d / 2 + (e.padding ?? 0) - f / 2 - (o.y - (o.top ?? 0))})`), xt(e, et), e.intersect = function(nt) {
      return ft.polygon(e, w, nt);
    }, l;
  }
  v(zC, "taggedWaveEdgedRectangle");
  async function FC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o } = await At(t, e, Tt(e)), h = Math.max(o.width + e.padding, (e == null ? void 0 : e.width) || 0), u = Math.max(o.height + e.padding, (e == null ? void 0 : e.height) || 0), d = -h / 2, f = -u / 2, p = l.insert("rect", ":first-child");
    return p.attr("class", "text").attr("style", n).attr("rx", 0).attr("ry", 0).attr("x", d).attr("y", f).attr("width", h).attr("height", u), xt(e, p), e.intersect = function(m) {
      return ft.rect(e, m);
    }, l;
  }
  v(FC, "text");
  var g6 = v((t, e, a, n, l, o) => `M${t},${e}
    a${l},${o} 0,0,1 0,${-n}
    l${a},0
    a${l},${o} 0,0,1 0,${n}
    M${a},${-n}
    a${l},${o} 0,0,0 0,${n}
    l${-a},0`, "createCylinderPathD"), m6 = v((t, e, a, n, l, o) => [
    `M${t},${e}`,
    `M${t + a},${e}`,
    `a${l},${o} 0,0,0 0,${-n}`,
    `l${-a},0`,
    `a${l},${o} 0,0,0 0,${n}`,
    `l${a},0`
  ].join(" "), "createOuterCylinderPathD"), y6 = v((t, e, a, n, l, o) => [
    `M${t + a / 2},${-n / 2}`,
    `a${l},${o} 0,0,0 0,${n}`
  ].join(" "), "createInnerCylinderPathD");
  async function qC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o, label: h, halfPadding: u } = await At(t, e, Tt(e)), d = e.look === "neo" ? u * 2 : u, f = o.height + d, p = f / 2, m = p / (2.5 + f / 50), b = o.width + m + d, { cssStyles: x } = e;
    let _;
    if (e.look === "handDrawn") {
      const S = yt.svg(l), w = m6(0, 0, b, f, m, p), k = y6(0, 0, b, f, m, p), A = S.path(w, bt(e, {})), L = S.path(k, bt(e, {
        fill: "none"
      }));
      _ = l.insert(() => L, ":first-child"), _ = l.insert(() => A, ":first-child"), _.attr("class", "basic label-container"), x && _.attr("style", x);
    } else {
      const S = g6(0, 0, b, f, m, p);
      _ = l.insert("path", ":first-child").attr("d", S).attr("class", "basic label-container").attr("style", Ze(x)).attr("style", n), _.attr("class", "basic label-container"), x && _.selectAll("path").attr("style", x), n && _.selectAll("path").attr("style", n);
    }
    return _.attr("label-offset-x", m), _.attr("transform", `translate(${-b / 2}, ${f / 2} )`), h.attr("transform", `translate(${-(o.width / 2) - m - (o.x - (o.left ?? 0))}, ${-(o.height / 2) - (o.y - (o.top ?? 0))})`), xt(e, _), e.intersect = function(S) {
      const w = ft.rect(e, S), k = w.y - (e.y ?? 0);
      if (p != 0 && (Math.abs(k) < (e.height ?? 0) / 2 || Math.abs(k) == (e.height ?? 0) / 2 && Math.abs(w.x - (e.x ?? 0)) > (e.width ?? 0) / 2 - m)) {
        let A = m * m * (1 - k * k / (p * p));
        A != 0 && (A = Math.sqrt(Math.abs(A))), A = m - A, S.x - (e.x ?? 0) > 0 && (A = -A), w.x += A;
      }
      return w;
    }, l;
  }
  v(qC, "tiltedCylinder");
  async function HC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o } = await At(t, e, Tt(e)), h = o.width + e.padding, u = o.height + e.padding, d = [
      {
        x: -3 * u / 6,
        y: 0
      },
      {
        x: h + 3 * u / 6,
        y: 0
      },
      {
        x: h,
        y: -u
      },
      {
        x: 0,
        y: -u
      }
    ];
    let f;
    const { cssStyles: p } = e;
    if (e.look === "handDrawn") {
      const m = yt.svg(l), b = bt(e, {}), x = Ft(d), _ = m.path(x, b);
      f = l.insert(() => _, ":first-child").attr("transform", `translate(${-h / 2}, ${u / 2})`), p && f.attr("style", p);
    } else f = za(l, h, u, d);
    return n && f.attr("style", n), e.width = h, e.height = u, xt(e, f), e.intersect = function(m) {
      return ft.polygon(e, d, m);
    }, l;
  }
  v(HC, "trapezoid");
  async function UC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o } = await At(t, e, Tt(e)), h = 60, u = 20, d = Math.max(h, o.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), f = Math.max(u, o.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), { cssStyles: p } = e, m = yt.svg(l), b = bt(e, {});
    e.look !== "handDrawn" && (b.roughness = 0, b.fillStyle = "solid");
    const x = [
      {
        x: -d / 2 * 0.8,
        y: -f / 2
      },
      {
        x: d / 2 * 0.8,
        y: -f / 2
      },
      {
        x: d / 2,
        y: -f / 2 * 0.6
      },
      {
        x: d / 2,
        y: f / 2
      },
      {
        x: -d / 2,
        y: f / 2
      },
      {
        x: -d / 2,
        y: -f / 2 * 0.6
      }
    ], _ = Ft(x), S = m.path(_, b), w = l.insert(() => S, ":first-child");
    return w.attr("class", "basic label-container"), p && e.look !== "handDrawn" && w.selectChildren("path").attr("style", p), n && e.look !== "handDrawn" && w.selectChildren("path").attr("style", n), xt(e, w), e.intersect = function(k) {
      return ft.polygon(e, x, k);
    }, l;
  }
  v(UC, "trapezoidalPentagon");
  async function jC(t, e) {
    var _a2;
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o, label: h } = await At(t, e, Tt(e)), u = Ee((_a2 = Pt().flowchart) == null ? void 0 : _a2.htmlLabels), d = o.width + (e.padding ?? 0), f = d + o.height, p = d + o.height, m = [
      {
        x: 0,
        y: 0
      },
      {
        x: p,
        y: 0
      },
      {
        x: p / 2,
        y: -f
      }
    ], { cssStyles: b } = e, x = yt.svg(l), _ = bt(e, {});
    e.look !== "handDrawn" && (_.roughness = 0, _.fillStyle = "solid");
    const S = Ft(m), w = x.path(S, _), k = l.insert(() => w, ":first-child").attr("transform", `translate(${-f / 2}, ${f / 2})`);
    return b && e.look !== "handDrawn" && k.selectChildren("path").attr("style", b), n && e.look !== "handDrawn" && k.selectChildren("path").attr("style", n), e.width = d, e.height = f, xt(e, k), h.attr("transform", `translate(${-o.width / 2 - (o.x - (o.left ?? 0))}, ${f / 2 - (o.height + (e.padding ?? 0) / (u ? 2 : 1) - (o.y - (o.top ?? 0)))})`), e.intersect = function(A) {
      return it.info("Triangle intersect", e, m, A), ft.polygon(e, m, A);
    }, l;
  }
  v(jC, "triangle");
  async function YC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o, label: h } = await At(t, e, Tt(e)), u = Math.max(o.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), d = Math.max(o.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), f = d / 8, p = d + f, { cssStyles: m } = e, x = 70 - u, _ = x > 0 ? x / 2 : 0, S = yt.svg(l), w = bt(e, {});
    e.look !== "handDrawn" && (w.roughness = 0, w.fillStyle = "solid");
    const k = [
      {
        x: -u / 2 - _,
        y: p / 2
      },
      ...Da(-u / 2 - _, p / 2, u / 2 + _, p / 2, f, 0.8),
      {
        x: u / 2 + _,
        y: -p / 2
      },
      {
        x: -u / 2 - _,
        y: -p / 2
      }
    ], A = Ft(k), L = S.path(A, w), $ = l.insert(() => L, ":first-child");
    return $.attr("class", "basic label-container"), m && e.look !== "handDrawn" && $.selectAll("path").attr("style", m), n && e.look !== "handDrawn" && $.selectAll("path").attr("style", n), $.attr("transform", `translate(0,${-f / 2})`), h.attr("transform", `translate(${-u / 2 + (e.padding ?? 0) - (o.x - (o.left ?? 0))},${-d / 2 + (e.padding ?? 0) - f - (o.y - (o.top ?? 0))})`), xt(e, $), e.intersect = function(O) {
      return ft.polygon(e, k, O);
    }, l;
  }
  v(YC, "waveEdgedRectangle");
  async function IC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o } = await At(t, e, Tt(e)), h = 100, u = 50, d = Math.max(o.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), f = Math.max(o.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), p = d / f;
    let m = d, b = f;
    m > b * p ? b = m / p : m = b * p, m = Math.max(m, h), b = Math.max(b, u);
    const x = Math.min(b * 0.2, b / 4), _ = b + x * 2, { cssStyles: S } = e, w = yt.svg(l), k = bt(e, {});
    e.look !== "handDrawn" && (k.roughness = 0, k.fillStyle = "solid");
    const A = [
      {
        x: -m / 2,
        y: _ / 2
      },
      ...Da(-m / 2, _ / 2, m / 2, _ / 2, x, 1),
      {
        x: m / 2,
        y: -_ / 2
      },
      ...Da(m / 2, -_ / 2, -m / 2, -_ / 2, x, -1)
    ], L = Ft(A), $ = w.path(L, k), O = l.insert(() => $, ":first-child");
    return O.attr("class", "basic label-container"), S && e.look !== "handDrawn" && O.selectAll("path").attr("style", S), n && e.look !== "handDrawn" && O.selectAll("path").attr("style", n), xt(e, O), e.intersect = function(W) {
      return ft.polygon(e, A, W);
    }, l;
  }
  v(IC, "waveRectangle");
  async function PC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o, label: h } = await At(t, e, Tt(e)), u = Math.max(o.width + (e.padding ?? 0) * 2, (e == null ? void 0 : e.width) ?? 0), d = Math.max(o.height + (e.padding ?? 0) * 2, (e == null ? void 0 : e.height) ?? 0), f = 5, p = -u / 2, m = -d / 2, { cssStyles: b } = e, x = yt.svg(l), _ = bt(e, {}), S = [
      {
        x: p - f,
        y: m - f
      },
      {
        x: p - f,
        y: m + d
      },
      {
        x: p + u,
        y: m + d
      },
      {
        x: p + u,
        y: m - f
      }
    ], w = `M${p - f},${m - f} L${p + u},${m - f} L${p + u},${m + d} L${p - f},${m + d} L${p - f},${m - f}
                M${p - f},${m} L${p + u},${m}
                M${p},${m - f} L${p},${m + d}`;
    e.look !== "handDrawn" && (_.roughness = 0, _.fillStyle = "solid");
    const k = x.path(w, _), A = l.insert(() => k, ":first-child");
    return A.attr("transform", `translate(${f / 2}, ${f / 2})`), A.attr("class", "basic label-container"), b && e.look !== "handDrawn" && A.selectAll("path").attr("style", b), n && e.look !== "handDrawn" && A.selectAll("path").attr("style", n), h.attr("transform", `translate(${-(o.width / 2) + f / 2 - (o.x - (o.left ?? 0))}, ${-(o.height / 2) + f / 2 - (o.y - (o.top ?? 0))})`), xt(e, A), e.intersect = function(L) {
      return ft.polygon(e, S, L);
    }, l;
  }
  v(PC, "windowPane");
  async function n0(t, e) {
    var _a2, _b2, _c2, _d2, _e2;
    const a = e;
    if (a.alias && (e.label = a.alias), e.look === "handDrawn") {
      const { themeVariables: K } = Xe(), { background: Z } = K, ct = {
        ...e,
        id: e.id + "-background",
        look: "default",
        cssStyles: [
          "stroke: none",
          `fill: ${Z}`
        ]
      };
      await n0(t, ct);
    }
    const n = Xe();
    e.useHtmlLabels = n.htmlLabels;
    let l = ((_a2 = n.er) == null ? void 0 : _a2.diagramPadding) ?? 10, o = ((_b2 = n.er) == null ? void 0 : _b2.entityPadding) ?? 6;
    const { cssStyles: h } = e, { labelStyles: u, nodeStyles: d } = vt(e);
    if (a.attributes.length === 0 && e.label) {
      const K = {
        rx: 0,
        ry: 0,
        labelPaddingX: l,
        labelPaddingY: l * 1.5
      };
      Qr(e.label, n) + K.labelPaddingX * 2 < n.er.minEntityWidth && (e.width = n.er.minEntityWidth);
      const Z = await Ch(t, e, K);
      if (!Ee(n.htmlLabels)) {
        const ct = Z.select("text"), ut = (_c2 = ct.node()) == null ? void 0 : _c2.getBBox();
        ct.attr("transform", `translate(${-ut.width / 2}, 0)`);
      }
      return Z;
    }
    n.htmlLabels || (l *= 1.25, o *= 1.25);
    let f = Tt(e);
    f || (f = "node default");
    const p = t.insert("g").attr("class", f).attr("id", e.domId || e.id), m = await pl(p, e.label ?? "", n, 0, 0, [
      "name"
    ], u);
    m.height += o;
    let b = 0;
    const x = [], _ = [];
    let S = 0, w = 0, k = 0, A = 0, L = true, $ = true;
    for (const K of a.attributes) {
      const Z = await pl(p, K.type, n, 0, b, [
        "attribute-type"
      ], u);
      S = Math.max(S, Z.width + l);
      const ct = await pl(p, K.name, n, 0, b, [
        "attribute-name"
      ], u);
      w = Math.max(w, ct.width + l);
      const ut = await pl(p, K.keys.join(), n, 0, b, [
        "attribute-keys"
      ], u);
      k = Math.max(k, ut.width + l);
      const pt = await pl(p, K.comment, n, 0, b, [
        "attribute-comment"
      ], u);
      A = Math.max(A, pt.width + l);
      const Ht = Math.max(Z.height, ct.height, ut.height, pt.height) + o;
      _.push({
        yOffset: b,
        rowHeight: Ht
      }), b += Ht;
    }
    let O = 4;
    k <= l && (L = false, k = 0, O--), A <= l && ($ = false, A = 0, O--);
    const W = p.node().getBBox();
    if (m.width + l * 2 - (S + w + k + A) > 0) {
      const K = m.width + l * 2 - (S + w + k + A);
      S += K / O, w += K / O, k > 0 && (k += K / O), A > 0 && (A += K / O);
    }
    const j = S + w + k + A, et = yt.svg(p), nt = bt(e, {});
    e.look !== "handDrawn" && (nt.roughness = 0, nt.fillStyle = "solid");
    let lt = 0;
    _.length > 0 && (lt = _.reduce((K, Z) => K + ((Z == null ? void 0 : Z.rowHeight) ?? 0), 0));
    const X = Math.max(W.width + l * 2, (e == null ? void 0 : e.width) || 0, j), at = Math.max((lt ?? 0) + m.height, (e == null ? void 0 : e.height) || 0), rt = -X / 2, V = -at / 2;
    p.selectAll("g:not(:first-child)").each((K, Z, ct) => {
      const ut = jt(ct[Z]), pt = ut.attr("transform");
      let Ht = 0, qt = 0;
      if (pt) {
        const re = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(pt);
        re && (Ht = parseFloat(re[1]), qt = parseFloat(re[2]), ut.attr("class").includes("attribute-name") ? Ht += S : ut.attr("class").includes("attribute-keys") ? Ht += S + w : ut.attr("class").includes("attribute-comment") && (Ht += S + w + k));
      }
      ut.attr("transform", `translate(${rt + l / 2 + Ht}, ${qt + V + m.height + o / 2})`);
    }), p.select(".name").attr("transform", "translate(" + -m.width / 2 + ", " + (V + o / 2) + ")");
    const G = et.rectangle(rt, V, X, at, nt), E = p.insert(() => G, ":first-child").attr("style", h.join("")), { themeVariables: N } = Xe(), { rowEven: F, rowOdd: ot, nodeBorder: M } = N;
    x.push(0);
    for (const [K, Z] of _.entries()) {
      const ut = (K + 1) % 2 === 0 && Z.yOffset !== 0, pt = et.rectangle(rt, m.height + V + (Z == null ? void 0 : Z.yOffset), X, Z == null ? void 0 : Z.rowHeight, {
        ...nt,
        fill: ut ? F : ot,
        stroke: M
      });
      p.insert(() => pt, "g.label").attr("style", h.join("")).attr("class", `row-rect-${ut ? "even" : "odd"}`);
    }
    let Y = et.line(rt, m.height + V, X + rt, m.height + V, nt);
    p.insert(() => Y).attr("class", "divider"), Y = et.line(S + rt, m.height + V, S + rt, at + V, nt), p.insert(() => Y).attr("class", "divider"), L && (Y = et.line(S + w + rt, m.height + V, S + w + rt, at + V, nt), p.insert(() => Y).attr("class", "divider")), $ && (Y = et.line(S + w + k + rt, m.height + V, S + w + k + rt, at + V, nt), p.insert(() => Y).attr("class", "divider"));
    for (const K of x) Y = et.line(rt, m.height + V + K, X + rt, m.height + V + K, nt), p.insert(() => Y).attr("class", "divider");
    if (xt(e, E), d && e.look !== "handDrawn") {
      const Z = (_e2 = (_d2 = d.split(";")) == null ? void 0 : _d2.filter((ct) => ct.includes("stroke"))) == null ? void 0 : _e2.map((ct) => `${ct}`).join("; ");
      p.selectAll("path").attr("style", Z ?? ""), p.selectAll(".row-rect-even path").attr("style", d);
    }
    return e.intersect = function(K) {
      return ft.rect(e, K);
    }, p;
  }
  v(n0, "erBox");
  async function pl(t, e, a, n = 0, l = 0, o = [], h = "") {
    const u = t.insert("g").attr("class", `label ${o.join(" ")}`).attr("transform", `translate(${n}, ${l})`).attr("style", h);
    e !== f1(e) && (e = f1(e), e = e.replaceAll("<", "&lt;").replaceAll(">", "&gt;"));
    const d = u.node().appendChild(await $a(u, e, {
      width: Qr(e, a) + 100,
      style: h,
      useHtmlLabels: a.htmlLabels
    }, a));
    if (e.includes("&lt;") || e.includes("&gt;")) {
      let p = d.children[0];
      for (p.textContent = p.textContent.replaceAll("&lt;", "<").replaceAll("&gt;", ">"); p.childNodes[0]; ) p = p.childNodes[0], p.textContent = p.textContent.replaceAll("&lt;", "<").replaceAll("&gt;", ">");
    }
    let f = d.getBBox();
    if (Ee(a.htmlLabels)) {
      const p = d.children[0];
      p.style.textAlign = "start";
      const m = jt(d);
      f = p.getBoundingClientRect(), m.attr("width", f.width), m.attr("height", f.height);
    }
    return f;
  }
  v(pl, "addText");
  async function GC(t, e, a, n, l = a.class.padding ?? 12) {
    const o = n ? 0 : 3, h = t.insert("g").attr("class", Tt(e)).attr("id", e.domId || e.id);
    let u = null, d = null, f = null, p = null, m = 0, b = 0, x = 0;
    if (u = h.insert("g").attr("class", "annotation-group text"), e.annotations.length > 0) {
      const A = e.annotations[0];
      await io(u, {
        text: `\xAB${A}\xBB`
      }, 0), m = u.node().getBBox().height;
    }
    d = h.insert("g").attr("class", "label-group text"), await io(d, e, 0, [
      "font-weight: bolder"
    ]);
    const _ = d.node().getBBox();
    b = _.height, f = h.insert("g").attr("class", "members-group text");
    let S = 0;
    for (const A of e.members) {
      const L = await io(f, A, S, [
        A.parseClassifier()
      ]);
      S += L + o;
    }
    x = f.node().getBBox().height, x <= 0 && (x = l / 2), p = h.insert("g").attr("class", "methods-group text");
    let w = 0;
    for (const A of e.methods) {
      const L = await io(p, A, w, [
        A.parseClassifier()
      ]);
      w += L + o;
    }
    let k = h.node().getBBox();
    if (u !== null) {
      const A = u.node().getBBox();
      u.attr("transform", `translate(${-A.width / 2})`);
    }
    return d.attr("transform", `translate(${-_.width / 2}, ${m})`), k = h.node().getBBox(), f.attr("transform", `translate(0, ${m + b + l * 2})`), k = h.node().getBBox(), p.attr("transform", `translate(0, ${m + b + (x ? x + l * 4 : l * 2)})`), k = h.node().getBBox(), {
      shapeSvg: h,
      bbox: k
    };
  }
  v(GC, "textHelper");
  async function io(t, e, a, n = []) {
    const l = t.insert("g").attr("class", "label").attr("style", n.join("; ")), o = Xe();
    let h = "useHtmlLabels" in e ? e.useHtmlLabels : Ee(o.htmlLabels) ?? true, u = "";
    "text" in e ? u = e.text : u = e.label, !h && u.startsWith("\\") && (u = u.substring(1)), _l(u) && (h = true);
    const d = await $a(l, gg(kn(u)), {
      width: Qr(u, o) + 50,
      classes: "markdown-node-label",
      useHtmlLabels: h
    }, o);
    let f, p = 1;
    if (h) {
      const m = d.children[0], b = jt(d);
      p = m.innerHTML.split("<br>").length, m.innerHTML.includes("</math>") && (p += m.innerHTML.split("<mrow>").length - 1);
      const x = m.getElementsByTagName("img");
      if (x) {
        const _ = u.replace(/<img[^>]*>/g, "").trim() === "";
        await Promise.all([
          ...x
        ].map((S) => new Promise((w) => {
          function k() {
            var _a2;
            if (S.style.display = "flex", S.style.flexDirection = "column", _) {
              const A = ((_a2 = o.fontSize) == null ? void 0 : _a2.toString()) ?? window.getComputedStyle(document.body).fontSize, $ = parseInt(A, 10) * 5 + "px";
              S.style.minWidth = $, S.style.maxWidth = $;
            } else S.style.width = "100%";
            w(S);
          }
          v(k, "setupImage"), setTimeout(() => {
            S.complete && k();
          }), S.addEventListener("error", k), S.addEventListener("load", k);
        })));
      }
      f = m.getBoundingClientRect(), b.attr("width", f.width), b.attr("height", f.height);
    } else {
      n.includes("font-weight: bolder") && jt(d).selectAll("tspan").attr("font-weight", ""), p = d.children.length;
      const m = d.children[0];
      (d.textContent === "" || d.textContent.includes("&gt")) && (m.textContent = u[0] + u.substring(1).replaceAll("&gt;", ">").replaceAll("&lt;", "<").trim(), u[1] === " " && (m.textContent = m.textContent[0] + " " + m.textContent.substring(1))), m.textContent === "undefined" && (m.textContent = ""), f = d.getBBox();
    }
    return l.attr("transform", "translate(0," + (-f.height / (2 * p) + a) + ")"), f.height;
  }
  v(io, "addText");
  async function WC(t, e) {
    var _a2, _b2;
    const a = Pt(), n = a.class.padding ?? 12, l = n, o = e.useHtmlLabels ?? Ee(a.htmlLabels) ?? true, h = e;
    h.annotations = h.annotations ?? [], h.members = h.members ?? [], h.methods = h.methods ?? [];
    const { shapeSvg: u, bbox: d } = await GC(t, e, a, o, l), { labelStyles: f, nodeStyles: p } = vt(e);
    e.labelStyle = f, e.cssStyles = h.styles || "";
    const m = ((_a2 = h.styles) == null ? void 0 : _a2.join(";")) || p || "";
    e.cssStyles || (e.cssStyles = m.replaceAll("!important", "").split(";"));
    const b = h.members.length === 0 && h.methods.length === 0 && !((_b2 = a.class) == null ? void 0 : _b2.hideEmptyMembersBox), x = yt.svg(u), _ = bt(e, {});
    e.look !== "handDrawn" && (_.roughness = 0, _.fillStyle = "solid");
    const S = d.width;
    let w = d.height;
    h.members.length === 0 && h.methods.length === 0 ? w += l : h.members.length > 0 && h.methods.length === 0 && (w += l * 2);
    const k = -S / 2, A = -w / 2, L = x.rectangle(k - n, A - n - (b ? n : h.members.length === 0 && h.methods.length === 0 ? -n / 2 : 0), S + 2 * n, w + 2 * n + (b ? n * 2 : h.members.length === 0 && h.methods.length === 0 ? -n : 0), _), $ = u.insert(() => L, ":first-child");
    $.attr("class", "basic label-container");
    const O = $.node().getBBox();
    u.selectAll(".text").each((nt, lt, X) => {
      var _a3;
      const at = jt(X[lt]), rt = at.attr("transform");
      let V = 0;
      if (rt) {
        const F = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(rt);
        F && (V = parseFloat(F[2]));
      }
      let G = V + A + n - (b ? n : h.members.length === 0 && h.methods.length === 0 ? -n / 2 : 0);
      o || (G -= 4);
      let E = k;
      (at.attr("class").includes("label-group") || at.attr("class").includes("annotation-group")) && (E = -((_a3 = at.node()) == null ? void 0 : _a3.getBBox().width) / 2 || 0, u.selectAll("text").each(function(N, F, ot) {
        window.getComputedStyle(ot[F]).textAnchor === "middle" && (E = 0);
      })), at.attr("transform", `translate(${E}, ${G})`);
    });
    const W = u.select(".annotation-group").node().getBBox().height - (b ? n / 2 : 0) || 0, j = u.select(".label-group").node().getBBox().height - (b ? n / 2 : 0) || 0, et = u.select(".members-group").node().getBBox().height - (b ? n / 2 : 0) || 0;
    if (h.members.length > 0 || h.methods.length > 0 || b) {
      const nt = x.line(O.x, W + j + A + n, O.x + O.width, W + j + A + n, _);
      u.insert(() => nt).attr("class", "divider").attr("style", m);
    }
    if (b || h.members.length > 0 || h.methods.length > 0) {
      const nt = x.line(O.x, W + j + et + A + l * 2 + n, O.x + O.width, W + j + et + A + n + l * 2, _);
      u.insert(() => nt).attr("class", "divider").attr("style", m);
    }
    if (h.look !== "handDrawn" && u.selectAll("path").attr("style", m), $.select(":nth-child(2)").attr("style", m), u.selectAll(".divider").select("path").attr("style", m), e.labelStyle ? u.selectAll("span").attr("style", e.labelStyle) : u.selectAll("span").attr("style", m), !o) {
      const nt = RegExp(/color\s*:\s*([^;]*)/), lt = nt.exec(m);
      if (lt) {
        const X = lt[0].replace("color", "fill");
        u.selectAll("tspan").attr("style", X);
      } else if (f) {
        const X = nt.exec(f);
        if (X) {
          const at = X[0].replace("color", "fill");
          u.selectAll("tspan").attr("style", at);
        }
      }
    }
    return xt(e, $), e.intersect = function(nt) {
      return ft.rect(e, nt);
    }, u;
  }
  v(WC, "classBox");
  async function XC(t, e) {
    var _a2, _b2;
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const l = e, o = e, h = 20, u = 20, d = "verifyMethod" in e, f = Tt(e), p = t.insert("g").attr("class", f).attr("id", e.domId ?? e.id);
    let m;
    d ? m = await pr(p, `&lt;&lt;${l.type}&gt;&gt;`, 0, e.labelStyle) : m = await pr(p, "&lt;&lt;Element&gt;&gt;", 0, e.labelStyle);
    let b = m;
    const x = await pr(p, l.name, b, e.labelStyle + "; font-weight: bold;");
    if (b += x + u, d) {
      const W = await pr(p, `${l.requirementId ? `ID: ${l.requirementId}` : ""}`, b, e.labelStyle);
      b += W;
      const j = await pr(p, `${l.text ? `Text: ${l.text}` : ""}`, b, e.labelStyle);
      b += j;
      const et = await pr(p, `${l.risk ? `Risk: ${l.risk}` : ""}`, b, e.labelStyle);
      b += et, await pr(p, `${l.verifyMethod ? `Verification: ${l.verifyMethod}` : ""}`, b, e.labelStyle);
    } else {
      const W = await pr(p, `${o.type ? `Type: ${o.type}` : ""}`, b, e.labelStyle);
      b += W, await pr(p, `${o.docRef ? `Doc Ref: ${o.docRef}` : ""}`, b, e.labelStyle);
    }
    const _ = (((_a2 = p.node()) == null ? void 0 : _a2.getBBox().width) ?? 200) + h, S = (((_b2 = p.node()) == null ? void 0 : _b2.getBBox().height) ?? 200) + h, w = -_ / 2, k = -S / 2, A = yt.svg(p), L = bt(e, {});
    e.look !== "handDrawn" && (L.roughness = 0, L.fillStyle = "solid");
    const $ = A.rectangle(w, k, _, S, L), O = p.insert(() => $, ":first-child");
    if (O.attr("class", "basic label-container").attr("style", n), p.selectAll(".label").each((W, j, et) => {
      const nt = jt(et[j]), lt = nt.attr("transform");
      let X = 0, at = 0;
      if (lt) {
        const E = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(lt);
        E && (X = parseFloat(E[1]), at = parseFloat(E[2]));
      }
      const rt = at - S / 2;
      let V = w + h / 2;
      (j === 0 || j === 1) && (V = X), nt.attr("transform", `translate(${V}, ${rt + h})`);
    }), b > m + x + u) {
      const W = A.line(w, k + m + x + u, w + _, k + m + x + u, L);
      p.insert(() => W).attr("style", n);
    }
    return xt(e, O), e.intersect = function(W) {
      return ft.rect(e, W);
    }, p;
  }
  v(XC, "requirementBox");
  async function pr(t, e, a, n = "") {
    if (e === "") return 0;
    const l = t.insert("g").attr("class", "label").attr("style", n), o = Pt(), h = o.htmlLabels ?? true, u = await $a(l, gg(kn(e)), {
      width: Qr(e, o) + 50,
      classes: "markdown-node-label",
      useHtmlLabels: h,
      style: n
    }, o);
    let d;
    if (h) {
      const f = u.children[0], p = jt(u);
      d = f.getBoundingClientRect(), p.attr("width", d.width), p.attr("height", d.height);
    } else {
      const f = u.children[0];
      for (const p of f.children) p.textContent = p.textContent.replaceAll("&gt;", ">").replaceAll("&lt;", "<"), n && p.setAttribute("style", n);
      d = u.getBBox(), d.height += 6;
    }
    return l.attr("transform", `translate(${-d.width / 2},${-d.height / 2 + a})`), d.height;
  }
  v(pr, "addText");
  var b6 = v((t) => {
    switch (t) {
      case "Very High":
        return "red";
      case "High":
        return "orange";
      case "Medium":
        return null;
      case "Low":
        return "blue";
      case "Very Low":
        return "lightblue";
    }
  }, "colorFromPriority");
  async function VC(t, e, { config: a }) {
    var _a2, _b2;
    const { labelStyles: n, nodeStyles: l } = vt(e);
    e.labelStyle = n || "";
    const o = 10, h = e.width;
    e.width = (e.width ?? 200) - 10;
    const { shapeSvg: u, bbox: d, label: f } = await At(t, e, Tt(e)), p = e.padding || 10;
    let m = "", b;
    "ticket" in e && e.ticket && ((_a2 = a == null ? void 0 : a.kanban) == null ? void 0 : _a2.ticketBaseUrl) && (m = (_b2 = a == null ? void 0 : a.kanban) == null ? void 0 : _b2.ticketBaseUrl.replace("#TICKET#", e.ticket), b = u.insert("svg:a", ":first-child").attr("class", "kanban-ticket-link").attr("xlink:href", m).attr("target", "_blank"));
    const x = {
      useHtmlLabels: e.useHtmlLabels,
      labelStyle: e.labelStyle || "",
      width: e.width,
      img: e.img,
      padding: e.padding || 8,
      centerLabel: false
    };
    let _, S;
    b ? { label: _, bbox: S } = await lp(b, "ticket" in e && e.ticket || "", x) : { label: _, bbox: S } = await lp(u, "ticket" in e && e.ticket || "", x);
    const { label: w, bbox: k } = await lp(u, "assigned" in e && e.assigned || "", x);
    e.width = h;
    const A = 10, L = (e == null ? void 0 : e.width) || 0, $ = Math.max(S.height, k.height) / 2, O = Math.max(d.height + A * 2, (e == null ? void 0 : e.height) || 0) + $, W = -L / 2, j = -O / 2;
    f.attr("transform", "translate(" + (p - L / 2) + ", " + (-$ - d.height / 2) + ")"), _.attr("transform", "translate(" + (p - L / 2) + ", " + (-$ + d.height / 2) + ")"), w.attr("transform", "translate(" + (p + L / 2 - k.width - 2 * o) + ", " + (-$ + d.height / 2) + ")");
    let et;
    const { rx: nt, ry: lt } = e, { cssStyles: X } = e;
    if (e.look === "handDrawn") {
      const at = yt.svg(u), rt = bt(e, {}), V = nt || lt ? at.path(Na(W, j, L, O, nt || 0), rt) : at.rectangle(W, j, L, O, rt);
      et = u.insert(() => V, ":first-child"), et.attr("class", "basic label-container").attr("style", X || null);
    } else {
      et = u.insert("rect", ":first-child"), et.attr("class", "basic label-container __APA__").attr("style", l).attr("rx", nt ?? 5).attr("ry", lt ?? 5).attr("x", W).attr("y", j).attr("width", L).attr("height", O);
      const at = "priority" in e && e.priority;
      if (at) {
        const rt = u.append("line"), V = W + 2, G = j + Math.floor((nt ?? 0) / 2), E = j + O - Math.floor((nt ?? 0) / 2);
        rt.attr("x1", V).attr("y1", G).attr("x2", V).attr("y2", E).attr("stroke-width", "4").attr("stroke", b6(at));
      }
    }
    return xt(e, et), e.height = O, e.intersect = function(at) {
      return ft.rect(e, at);
    }, u;
  }
  v(VC, "kanbanItem");
  async function ZC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o, halfPadding: h, label: u } = await At(t, e, Tt(e)), d = o.width + 10 * h, f = o.height + 8 * h, p = 0.15 * d, { cssStyles: m } = e, b = o.width + 20, x = o.height + 20, _ = Math.max(d, b), S = Math.max(f, x);
    u.attr("transform", `translate(${-o.width / 2}, ${-o.height / 2})`);
    let w;
    const k = `M0 0 
    a${p},${p} 1 0,0 ${_ * 0.25},${-1 * S * 0.1}
    a${p},${p} 1 0,0 ${_ * 0.25},0
    a${p},${p} 1 0,0 ${_ * 0.25},0
    a${p},${p} 1 0,0 ${_ * 0.25},${S * 0.1}

    a${p},${p} 1 0,0 ${_ * 0.15},${S * 0.33}
    a${p * 0.8},${p * 0.8} 1 0,0 0,${S * 0.34}
    a${p},${p} 1 0,0 ${-1 * _ * 0.15},${S * 0.33}

    a${p},${p} 1 0,0 ${-1 * _ * 0.25},${S * 0.15}
    a${p},${p} 1 0,0 ${-1 * _ * 0.25},0
    a${p},${p} 1 0,0 ${-1 * _ * 0.25},0
    a${p},${p} 1 0,0 ${-1 * _ * 0.25},${-1 * S * 0.15}

    a${p},${p} 1 0,0 ${-1 * _ * 0.1},${-1 * S * 0.33}
    a${p * 0.8},${p * 0.8} 1 0,0 0,${-1 * S * 0.34}
    a${p},${p} 1 0,0 ${_ * 0.1},${-1 * S * 0.33}
  H0 V0 Z`;
    if (e.look === "handDrawn") {
      const A = yt.svg(l), L = bt(e, {}), $ = A.path(k, L);
      w = l.insert(() => $, ":first-child"), w.attr("class", "basic label-container").attr("style", Ze(m));
    } else w = l.insert("path", ":first-child").attr("class", "basic label-container").attr("style", n).attr("d", k);
    return w.attr("transform", `translate(${-_ / 2}, ${-S / 2})`), xt(e, w), e.calcIntersect = function(A, L) {
      return ft.rect(A, L);
    }, e.intersect = function(A) {
      return it.info("Bang intersect", e, A), ft.rect(e, A);
    }, l;
  }
  v(ZC, "bang");
  async function QC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o, halfPadding: h, label: u } = await At(t, e, Tt(e)), d = o.width + 2 * h, f = o.height + 2 * h, p = 0.15 * d, m = 0.25 * d, b = 0.35 * d, x = 0.2 * d, { cssStyles: _ } = e;
    let S;
    const w = `M0 0 
    a${p},${p} 0 0,1 ${d * 0.25},${-1 * d * 0.1}
    a${b},${b} 1 0,1 ${d * 0.4},${-1 * d * 0.1}
    a${m},${m} 1 0,1 ${d * 0.35},${d * 0.2}

    a${p},${p} 1 0,1 ${d * 0.15},${f * 0.35}
    a${x},${x} 1 0,1 ${-1 * d * 0.15},${f * 0.65}

    a${m},${p} 1 0,1 ${-1 * d * 0.25},${d * 0.15}
    a${b},${b} 1 0,1 ${-1 * d * 0.5},0
    a${p},${p} 1 0,1 ${-1 * d * 0.25},${-1 * d * 0.15}

    a${p},${p} 1 0,1 ${-1 * d * 0.1},${-1 * f * 0.35}
    a${x},${x} 1 0,1 ${d * 0.1},${-1 * f * 0.65}
  H0 V0 Z`;
    if (e.look === "handDrawn") {
      const k = yt.svg(l), A = bt(e, {}), L = k.path(w, A);
      S = l.insert(() => L, ":first-child"), S.attr("class", "basic label-container").attr("style", Ze(_));
    } else S = l.insert("path", ":first-child").attr("class", "basic label-container").attr("style", n).attr("d", w);
    return u.attr("transform", `translate(${-o.width / 2}, ${-o.height / 2})`), S.attr("transform", `translate(${-d / 2}, ${-f / 2})`), xt(e, S), e.calcIntersect = function(k, A) {
      return ft.rect(k, A);
    }, e.intersect = function(k) {
      return it.info("Cloud intersect", e, k), ft.rect(e, k);
    }, l;
  }
  v(QC, "cloud");
  async function KC(t, e) {
    const { labelStyles: a, nodeStyles: n } = vt(e);
    e.labelStyle = a;
    const { shapeSvg: l, bbox: o, halfPadding: h, label: u } = await At(t, e, Tt(e)), d = o.width + 8 * h, f = o.height + 2 * h, p = 5, m = `
    M${-d / 2} ${f / 2 - p}
    v${-f + 2 * p}
    q0,-${p} ${p},-${p}
    h${d - 2 * p}
    q${p},0 ${p},${p}
    v${f - 2 * p}
    q0,${p} -${p},${p}
    h${-d + 2 * p}
    q-${p},0 -${p},-${p}
    Z
  `, b = l.append("path").attr("id", "node-" + e.id).attr("class", "node-bkg node-" + e.type).attr("style", n).attr("d", m);
    return l.append("line").attr("class", "node-line-").attr("x1", -d / 2).attr("y1", f / 2).attr("x2", d / 2).attr("y2", f / 2), u.attr("transform", `translate(${-o.width / 2}, ${-o.height / 2})`), l.append(() => u.node()), xt(e, b), e.calcIntersect = function(x, _) {
      return ft.rect(x, _);
    }, e.intersect = function(x) {
      return ft.rect(e, x);
    }, l;
  }
  v(KC, "defaultMindmapNode");
  async function JC(t, e) {
    const a = {
      padding: e.padding ?? 0
    };
    return a0(t, e, a);
  }
  v(JC, "mindmapCircle");
  var x6 = [
    {
      semanticName: "Process",
      name: "Rectangle",
      shortName: "rect",
      description: "Standard process shape",
      aliases: [
        "proc",
        "process",
        "rectangle"
      ],
      internalAliases: [
        "squareRect"
      ],
      handler: BC
    },
    {
      semanticName: "Event",
      name: "Rounded Rectangle",
      shortName: "rounded",
      description: "Represents an event",
      aliases: [
        "event"
      ],
      internalAliases: [
        "roundedRect"
      ],
      handler: AC
    },
    {
      semanticName: "Terminal Point",
      name: "Stadium",
      shortName: "stadium",
      description: "Terminal point",
      aliases: [
        "terminal",
        "pill"
      ],
      handler: LC
    },
    {
      semanticName: "Subprocess",
      name: "Framed Rectangle",
      shortName: "fr-rect",
      description: "Subprocess",
      aliases: [
        "subprocess",
        "subproc",
        "framed-rectangle",
        "subroutine"
      ],
      handler: $C
    },
    {
      semanticName: "Database",
      name: "Cylinder",
      shortName: "cyl",
      description: "Database storage",
      aliases: [
        "db",
        "database",
        "cylinder"
      ],
      handler: tC
    },
    {
      semanticName: "Start",
      name: "Circle",
      shortName: "circle",
      description: "Starting point",
      aliases: [
        "circ"
      ],
      handler: a0
    },
    {
      semanticName: "Bang",
      name: "Bang",
      shortName: "bang",
      description: "Bang",
      aliases: [
        "bang"
      ],
      handler: ZC
    },
    {
      semanticName: "Cloud",
      name: "Cloud",
      shortName: "cloud",
      description: "cloud",
      aliases: [
        "cloud"
      ],
      handler: QC
    },
    {
      semanticName: "Decision",
      name: "Diamond",
      shortName: "diam",
      description: "Decision-making step",
      aliases: [
        "decision",
        "diamond",
        "question"
      ],
      handler: wC
    },
    {
      semanticName: "Prepare Conditional",
      name: "Hexagon",
      shortName: "hex",
      description: "Preparation or condition step",
      aliases: [
        "hexagon",
        "prepare"
      ],
      handler: sC
    },
    {
      semanticName: "Data Input/Output",
      name: "Lean Right",
      shortName: "lean-r",
      description: "Represents input or output",
      aliases: [
        "lean-right",
        "in-out"
      ],
      internalAliases: [
        "lean_right"
      ],
      handler: yC
    },
    {
      semanticName: "Data Input/Output",
      name: "Lean Left",
      shortName: "lean-l",
      description: "Represents output or input",
      aliases: [
        "lean-left",
        "out-in"
      ],
      internalAliases: [
        "lean_left"
      ],
      handler: mC
    },
    {
      semanticName: "Priority Action",
      name: "Trapezoid Base Bottom",
      shortName: "trap-b",
      description: "Priority action",
      aliases: [
        "priority",
        "trapezoid-bottom",
        "trapezoid"
      ],
      handler: HC
    },
    {
      semanticName: "Manual Operation",
      name: "Trapezoid Base Top",
      shortName: "trap-t",
      description: "Represents a manual task",
      aliases: [
        "manual",
        "trapezoid-top",
        "inv-trapezoid"
      ],
      internalAliases: [
        "inv_trapezoid"
      ],
      handler: pC
    },
    {
      semanticName: "Stop",
      name: "Double Circle",
      shortName: "dbl-circ",
      description: "Represents a stop point",
      aliases: [
        "double-circle"
      ],
      internalAliases: [
        "doublecircle"
      ],
      handler: iC
    },
    {
      semanticName: "Text Block",
      name: "Text Block",
      shortName: "text",
      description: "Text block",
      handler: FC
    },
    {
      semanticName: "Card",
      name: "Notched Rectangle",
      shortName: "notch-rect",
      description: "Represents a card",
      aliases: [
        "card",
        "notched-rectangle"
      ],
      handler: GS
    },
    {
      semanticName: "Lined/Shaded Process",
      name: "Lined Rectangle",
      shortName: "lin-rect",
      description: "Lined process shape",
      aliases: [
        "lined-rectangle",
        "lined-process",
        "lin-proc",
        "shaded-process"
      ],
      handler: EC
    },
    {
      semanticName: "Start",
      name: "Small Circle",
      shortName: "sm-circ",
      description: "Small starting point",
      aliases: [
        "start",
        "small-circle"
      ],
      internalAliases: [
        "stateStart"
      ],
      handler: RC
    },
    {
      semanticName: "Stop",
      name: "Framed Circle",
      shortName: "fr-circ",
      description: "Stop point",
      aliases: [
        "stop",
        "framed-circle"
      ],
      internalAliases: [
        "stateEnd"
      ],
      handler: DC
    },
    {
      semanticName: "Fork/Join",
      name: "Filled Rectangle",
      shortName: "fork",
      description: "Fork or join in process flow",
      aliases: [
        "join"
      ],
      internalAliases: [
        "forkJoin"
      ],
      handler: nC
    },
    {
      semanticName: "Collate",
      name: "Hourglass",
      shortName: "hourglass",
      description: "Represents a collate operation",
      aliases: [
        "hourglass",
        "collate"
      ],
      handler: oC
    },
    {
      semanticName: "Comment",
      name: "Curly Brace",
      shortName: "brace",
      description: "Adds a comment",
      aliases: [
        "comment",
        "brace-l"
      ],
      handler: ZS
    },
    {
      semanticName: "Comment Right",
      name: "Curly Brace",
      shortName: "brace-r",
      description: "Adds a comment",
      handler: QS
    },
    {
      semanticName: "Comment with braces on both sides",
      name: "Curly Braces",
      shortName: "braces",
      description: "Adds a comment",
      handler: KS
    },
    {
      semanticName: "Com Link",
      name: "Lightning Bolt",
      shortName: "bolt",
      description: "Communication link",
      aliases: [
        "com-link",
        "lightning-bolt"
      ],
      handler: bC
    },
    {
      semanticName: "Document",
      name: "Document",
      shortName: "doc",
      description: "Represents a document",
      aliases: [
        "doc",
        "document"
      ],
      handler: YC
    },
    {
      semanticName: "Delay",
      name: "Half-Rounded Rectangle",
      shortName: "delay",
      description: "Represents a delay",
      aliases: [
        "half-rounded-rectangle"
      ],
      handler: lC
    },
    {
      semanticName: "Direct Access Storage",
      name: "Horizontal Cylinder",
      shortName: "h-cyl",
      description: "Direct access storage",
      aliases: [
        "das",
        "horizontal-cylinder"
      ],
      handler: qC
    },
    {
      semanticName: "Disk Storage",
      name: "Lined Cylinder",
      shortName: "lin-cyl",
      description: "Disk storage",
      aliases: [
        "disk",
        "lined-cylinder"
      ],
      handler: xC
    },
    {
      semanticName: "Display",
      name: "Curved Trapezoid",
      shortName: "curv-trap",
      description: "Represents a display",
      aliases: [
        "curved-trapezoid",
        "display"
      ],
      handler: JS
    },
    {
      semanticName: "Divided Process",
      name: "Divided Rectangle",
      shortName: "div-rect",
      description: "Divided process shape",
      aliases: [
        "div-proc",
        "divided-rectangle",
        "divided-process"
      ],
      handler: eC
    },
    {
      semanticName: "Extract",
      name: "Triangle",
      shortName: "tri",
      description: "Extraction process",
      aliases: [
        "extract",
        "triangle"
      ],
      handler: jC
    },
    {
      semanticName: "Internal Storage",
      name: "Window Pane",
      shortName: "win-pane",
      description: "Internal storage",
      aliases: [
        "internal-storage",
        "window-pane"
      ],
      handler: PC
    },
    {
      semanticName: "Junction",
      name: "Filled Circle",
      shortName: "f-circ",
      description: "Junction point",
      aliases: [
        "junction",
        "filled-circle"
      ],
      handler: rC
    },
    {
      semanticName: "Loop Limit",
      name: "Trapezoidal Pentagon",
      shortName: "notch-pent",
      description: "Loop limit step",
      aliases: [
        "loop-limit",
        "notched-pentagon"
      ],
      handler: UC
    },
    {
      semanticName: "Manual File",
      name: "Flipped Triangle",
      shortName: "flip-tri",
      description: "Manual file operation",
      aliases: [
        "manual-file",
        "flipped-triangle"
      ],
      handler: aC
    },
    {
      semanticName: "Manual Input",
      name: "Sloped Rectangle",
      shortName: "sl-rect",
      description: "Manual input step",
      aliases: [
        "manual-input",
        "sloped-rectangle"
      ],
      handler: MC
    },
    {
      semanticName: "Multi-Document",
      name: "Stacked Document",
      shortName: "docs",
      description: "Multiple documents",
      aliases: [
        "documents",
        "st-doc",
        "stacked-document"
      ],
      handler: SC
    },
    {
      semanticName: "Multi-Process",
      name: "Stacked Rectangle",
      shortName: "st-rect",
      description: "Multiple processes",
      aliases: [
        "procs",
        "processes",
        "stacked-rectangle"
      ],
      handler: _C
    },
    {
      semanticName: "Stored Data",
      name: "Bow Tie Rectangle",
      shortName: "bow-rect",
      description: "Stored data",
      aliases: [
        "stored-data",
        "bow-tie-rectangle"
      ],
      handler: PS
    },
    {
      semanticName: "Summary",
      name: "Crossed Circle",
      shortName: "cross-circ",
      description: "Summary",
      aliases: [
        "summary",
        "crossed-circle"
      ],
      handler: VS
    },
    {
      semanticName: "Tagged Document",
      name: "Tagged Document",
      shortName: "tag-doc",
      description: "Tagged document",
      aliases: [
        "tag-doc",
        "tagged-document"
      ],
      handler: zC
    },
    {
      semanticName: "Tagged Process",
      name: "Tagged Rectangle",
      shortName: "tag-rect",
      description: "Tagged process",
      aliases: [
        "tagged-rectangle",
        "tag-proc",
        "tagged-process"
      ],
      handler: NC
    },
    {
      semanticName: "Paper Tape",
      name: "Flag",
      shortName: "flag",
      description: "Paper tape",
      aliases: [
        "paper-tape"
      ],
      handler: IC
    },
    {
      semanticName: "Odd",
      name: "Odd",
      shortName: "odd",
      description: "Odd shape",
      internalAliases: [
        "rect_left_inv_arrow"
      ],
      handler: TC
    },
    {
      semanticName: "Lined Document",
      name: "Lined Document",
      shortName: "lin-doc",
      description: "Lined document",
      aliases: [
        "lined-document"
      ],
      handler: vC
    }
  ], v6 = v(() => {
    const e = [
      ...Object.entries({
        state: OC,
        choice: WS,
        note: CC,
        rectWithTitle: kC,
        labelRect: gC,
        iconSquare: fC,
        iconCircle: uC,
        icon: cC,
        iconRounded: hC,
        imageSquare: dC,
        anchor: IS,
        kanbanItem: VC,
        mindmapCircle: JC,
        defaultMindmapNode: KC,
        classBox: WC,
        erBox: n0,
        requirementBox: XC
      }),
      ...x6.flatMap((a) => [
        a.shortName,
        ..."aliases" in a ? a.aliases : [],
        ..."internalAliases" in a ? a.internalAliases : []
      ].map((l) => [
        l,
        a.handler
      ]))
    ];
    return Object.fromEntries(e);
  }, "generateShapeMap"), tw = v6();
  _6 = function(t) {
    return t in tw;
  };
  v(_6, "isValidShape");
  var wh = /* @__PURE__ */ new Map();
  ew = async function(t, e, a) {
    let n, l;
    e.shape === "rect" && (e.rx && e.ry ? e.shape = "roundedRect" : e.shape = "squareRect");
    const o = e.shape ? tw[e.shape] : void 0;
    if (!o) throw new Error(`No such shape: ${e.shape}. Please check your syntax.`);
    if (e.link) {
      let h;
      a.config.securityLevel === "sandbox" ? h = "_top" : e.linkTarget && (h = e.linkTarget || "_blank"), n = t.insert("svg:a").attr("xlink:href", e.link).attr("target", h ?? null), l = await o(n, e, a);
    } else l = await o(t, e, a), n = l;
    return e.tooltip && l.attr("title", e.tooltip), wh.set(e.id, n), e.haveCallback && n.attr("class", n.attr("class") + " clickable"), n;
  };
  v(ew, "insertNode");
  let S6, C6, bx, Ju, Fe, Vs;
  Ez = v((t, e) => {
    wh.set(e.id, t);
  }, "setNodeElem");
  Mz = v(() => {
    wh.clear();
  }, "clear");
  Bz = v((t) => {
    const e = wh.get(t.id);
    it.trace("Transforming node", t.diff, t, "translate(" + (t.x - t.width / 2 - 5) + ", " + t.width / 2 + ")");
    const a = 8, n = t.diff || 0;
    return t.clusterNode ? e.attr("transform", "translate(" + (t.x + n - t.width / 2) + ", " + (t.y - t.height / 2 - a) + ")") : e.attr("transform", "translate(" + t.x + ", " + t.y + ")"), n;
  }, "positionNode");
  S6 = v((t, e, a, n, l, o) => {
    e.arrowTypeStart && bx(t, "start", e.arrowTypeStart, a, n, l, o), e.arrowTypeEnd && bx(t, "end", e.arrowTypeEnd, a, n, l, o);
  }, "addEdgeMarkers");
  C6 = {
    arrow_cross: {
      type: "cross",
      fill: false
    },
    arrow_point: {
      type: "point",
      fill: true
    },
    arrow_barb: {
      type: "barb",
      fill: true
    },
    arrow_circle: {
      type: "circle",
      fill: false
    },
    aggregation: {
      type: "aggregation",
      fill: false
    },
    extension: {
      type: "extension",
      fill: false
    },
    composition: {
      type: "composition",
      fill: true
    },
    dependency: {
      type: "dependency",
      fill: true
    },
    lollipop: {
      type: "lollipop",
      fill: false
    },
    only_one: {
      type: "onlyOne",
      fill: false
    },
    zero_or_one: {
      type: "zeroOrOne",
      fill: false
    },
    one_or_more: {
      type: "oneOrMore",
      fill: false
    },
    zero_or_more: {
      type: "zeroOrMore",
      fill: false
    },
    requirement_arrow: {
      type: "requirement_arrow",
      fill: false
    },
    requirement_contains: {
      type: "requirement_contains",
      fill: false
    }
  };
  bx = v((t, e, a, n, l, o, h) => {
    var _a2;
    const u = C6[a];
    if (!u) {
      it.warn(`Unknown arrow type: ${a}`);
      return;
    }
    const d = u.type, p = `${l}_${o}-${d}${e === "start" ? "Start" : "End"}`;
    if (h && h.trim() !== "") {
      const m = h.replace(/[^\dA-Za-z]/g, "_"), b = `${p}_${m}`;
      if (!document.getElementById(b)) {
        const x = document.getElementById(p);
        if (x) {
          const _ = x.cloneNode(true);
          _.id = b, _.querySelectorAll("path, circle, line").forEach((w) => {
            w.setAttribute("stroke", h), u.fill && w.setAttribute("fill", h);
          }), (_a2 = x.parentNode) == null ? void 0 : _a2.appendChild(_);
        }
      }
      t.attr(`marker-${e}`, `url(${n}#${b})`);
    } else t.attr(`marker-${e}`, `url(${n}#${p})`);
  }, "addEdgeMarker");
  Ju = /* @__PURE__ */ new Map();
  Fe = /* @__PURE__ */ new Map();
  Lz = v(() => {
    Ju.clear(), Fe.clear();
  }, "clear");
  Vs = v((t) => t ? t.reduce((a, n) => a + ";" + n, "") : "", "getLabelStyles");
  w6 = v(async (t, e) => {
    let a = Ee(Pt().flowchart.htmlLabels);
    const n = await $a(t, e.label, {
      style: Vs(e.labelStyle),
      useHtmlLabels: a,
      addSvgBackground: true,
      isNode: false
    });
    it.info("abc82", e, e.labelType);
    const l = t.insert("g").attr("class", "edgeLabel"), o = l.insert("g").attr("class", "label");
    o.node().appendChild(n);
    let h = n.getBBox();
    if (a) {
      const d = n.children[0], f = jt(n);
      h = d.getBoundingClientRect(), f.attr("width", h.width), f.attr("height", h.height);
    }
    o.attr("transform", "translate(" + -h.width / 2 + ", " + -h.height / 2 + ")"), Ju.set(e.id, l), e.width = h.width, e.height = h.height;
    let u;
    if (e.startLabelLeft) {
      const d = await pn(e.startLabelLeft, Vs(e.labelStyle)), f = t.insert("g").attr("class", "edgeTerminals"), p = f.insert("g").attr("class", "inner");
      u = p.node().appendChild(d);
      const m = d.getBBox();
      p.attr("transform", "translate(" + -m.width / 2 + ", " + -m.height / 2 + ")"), Fe.get(e.id) || Fe.set(e.id, {}), Fe.get(e.id).startLeft = f, ro(u, e.startLabelLeft);
    }
    if (e.startLabelRight) {
      const d = await pn(e.startLabelRight, Vs(e.labelStyle)), f = t.insert("g").attr("class", "edgeTerminals"), p = f.insert("g").attr("class", "inner");
      u = f.node().appendChild(d), p.node().appendChild(d);
      const m = d.getBBox();
      p.attr("transform", "translate(" + -m.width / 2 + ", " + -m.height / 2 + ")"), Fe.get(e.id) || Fe.set(e.id, {}), Fe.get(e.id).startRight = f, ro(u, e.startLabelRight);
    }
    if (e.endLabelLeft) {
      const d = await pn(e.endLabelLeft, Vs(e.labelStyle)), f = t.insert("g").attr("class", "edgeTerminals"), p = f.insert("g").attr("class", "inner");
      u = p.node().appendChild(d);
      const m = d.getBBox();
      p.attr("transform", "translate(" + -m.width / 2 + ", " + -m.height / 2 + ")"), f.node().appendChild(d), Fe.get(e.id) || Fe.set(e.id, {}), Fe.get(e.id).endLeft = f, ro(u, e.endLabelLeft);
    }
    if (e.endLabelRight) {
      const d = await pn(e.endLabelRight, Vs(e.labelStyle)), f = t.insert("g").attr("class", "edgeTerminals"), p = f.insert("g").attr("class", "inner");
      u = p.node().appendChild(d);
      const m = d.getBBox();
      p.attr("transform", "translate(" + -m.width / 2 + ", " + -m.height / 2 + ")"), f.node().appendChild(d), Fe.get(e.id) || Fe.set(e.id, {}), Fe.get(e.id).endRight = f, ro(u, e.endLabelRight);
    }
    return n;
  }, "insertEdgeLabel");
  function ro(t, e) {
    Pt().flowchart.htmlLabels && t && (t.style.width = e.length * 9 + "px", t.style.height = "12px");
  }
  v(ro, "setTerminalWidth");
  let k6, A6, xx;
  T6 = v((t, e) => {
    it.debug("Moving label abc88 ", t.id, t.label, Ju.get(t.id), e);
    let a = e.updatedPath ? e.updatedPath : e.originalPath;
    const n = Pt(), { subGraphTitleTotalMargin: l } = $g(n);
    if (t.label) {
      const o = Ju.get(t.id);
      let h = t.x, u = t.y;
      if (a) {
        const d = tr.calcLabelPosition(a);
        it.debug("Moving label " + t.label + " from (", h, ",", u, ") to (", d.x, ",", d.y, ") abc88"), e.updatedPath && (h = d.x, u = d.y);
      }
      o.attr("transform", `translate(${h}, ${u + l / 2})`);
    }
    if (t.startLabelLeft) {
      const o = Fe.get(t.id).startLeft;
      let h = t.x, u = t.y;
      if (a) {
        const d = tr.calcTerminalLabelPosition(t.arrowTypeStart ? 10 : 0, "start_left", a);
        h = d.x, u = d.y;
      }
      o.attr("transform", `translate(${h}, ${u})`);
    }
    if (t.startLabelRight) {
      const o = Fe.get(t.id).startRight;
      let h = t.x, u = t.y;
      if (a) {
        const d = tr.calcTerminalLabelPosition(t.arrowTypeStart ? 10 : 0, "start_right", a);
        h = d.x, u = d.y;
      }
      o.attr("transform", `translate(${h}, ${u})`);
    }
    if (t.endLabelLeft) {
      const o = Fe.get(t.id).endLeft;
      let h = t.x, u = t.y;
      if (a) {
        const d = tr.calcTerminalLabelPosition(t.arrowTypeEnd ? 10 : 0, "end_left", a);
        h = d.x, u = d.y;
      }
      o.attr("transform", `translate(${h}, ${u})`);
    }
    if (t.endLabelRight) {
      const o = Fe.get(t.id).endRight;
      let h = t.x, u = t.y;
      if (a) {
        const d = tr.calcTerminalLabelPosition(t.arrowTypeEnd ? 10 : 0, "end_right", a);
        h = d.x, u = d.y;
      }
      o.attr("transform", `translate(${h}, ${u})`);
    }
  }, "positionEdgeLabel");
  k6 = v((t, e) => {
    const a = t.x, n = t.y, l = Math.abs(e.x - a), o = Math.abs(e.y - n), h = t.width / 2, u = t.height / 2;
    return l >= h || o >= u;
  }, "outsideNode");
  A6 = v((t, e, a) => {
    it.debug(`intersection calc abc89:
  outsidePoint: ${JSON.stringify(e)}
  insidePoint : ${JSON.stringify(a)}
  node        : x:${t.x} y:${t.y} w:${t.width} h:${t.height}`);
    const n = t.x, l = t.y, o = Math.abs(n - a.x), h = t.width / 2;
    let u = a.x < e.x ? h - o : h + o;
    const d = t.height / 2, f = Math.abs(e.y - a.y), p = Math.abs(e.x - a.x);
    if (Math.abs(l - e.y) * h > Math.abs(n - e.x) * d) {
      let m = a.y < e.y ? e.y - d - l : l - d - e.y;
      u = p * m / f;
      const b = {
        x: a.x < e.x ? a.x + u : a.x - p + u,
        y: a.y < e.y ? a.y + f - m : a.y - f + m
      };
      return u === 0 && (b.x = e.x, b.y = e.y), p === 0 && (b.x = e.x), f === 0 && (b.y = e.y), it.debug(`abc89 top/bottom calc, Q ${f}, q ${m}, R ${p}, r ${u}`, b), b;
    } else {
      a.x < e.x ? u = e.x - h - n : u = n - h - e.x;
      let m = f * u / p, b = a.x < e.x ? a.x + p - u : a.x - p + u, x = a.y < e.y ? a.y + m : a.y - m;
      return it.debug(`sides calc abc89, Q ${f}, q ${m}, R ${p}, r ${u}`, {
        _x: b,
        _y: x
      }), u === 0 && (b = e.x, x = e.y), p === 0 && (b = e.x), f === 0 && (x = e.y), {
        x: b,
        y: x
      };
    }
  }, "intersection");
  xx = v((t, e) => {
    it.warn("abc88 cutPathAtIntersect", t, e);
    let a = [], n = t[0], l = false;
    return t.forEach((o) => {
      if (it.info("abc88 checking point", o, e), !k6(e, o) && !l) {
        const h = A6(e, n, o);
        it.debug("abc88 inside", o, n, h), it.debug("abc88 intersection", h, e);
        let u = false;
        a.forEach((d) => {
          u = u || d.x === h.x && d.y === h.y;
        }), a.some((d) => d.x === h.x && d.y === h.y) ? it.warn("abc88 no intersect", h, a) : a.push(h), l = true;
      } else it.warn("abc88 outside", o, n), n = o, l || a.push(o);
    }), it.debug("returning points", a), a;
  }, "cutPathAtIntersect");
  function iw(t) {
    const e = [], a = [];
    for (let n = 1; n < t.length - 1; n++) {
      const l = t[n - 1], o = t[n], h = t[n + 1];
      (l.x === o.x && o.y === h.y && Math.abs(o.x - h.x) > 5 && Math.abs(o.y - l.y) > 5 || l.y === o.y && o.x === h.x && Math.abs(o.x - l.x) > 5 && Math.abs(o.y - h.y) > 5) && (e.push(o), a.push(n));
    }
    return {
      cornerPoints: e,
      cornerPointPositions: a
    };
  }
  v(iw, "extractCornerPoints");
  let vx, E6, B6, L6, O6, D6, R6, $6, N6, z6, F6, q6, H6, U6, j6, Y6, I6, P6, G6, X6, So, rw, V6;
  vx = v(function(t, e, a) {
    const n = e.x - t.x, l = e.y - t.y, o = Math.sqrt(n * n + l * l), h = a / o;
    return {
      x: e.x - h * n,
      y: e.y - h * l
    };
  }, "findAdjacentPoint");
  E6 = v(function(t) {
    const { cornerPointPositions: e } = iw(t), a = [];
    for (let n = 0; n < t.length; n++) if (e.includes(n)) {
      const l = t[n - 1], o = t[n + 1], h = t[n], u = vx(l, h, 5), d = vx(o, h, 5), f = d.x - u.x, p = d.y - u.y;
      a.push(u);
      const m = Math.sqrt(2) * 2;
      let b = {
        x: h.x,
        y: h.y
      };
      if (Math.abs(o.x - l.x) > 10 && Math.abs(o.y - l.y) >= 10) {
        it.debug("Corner point fixing", Math.abs(o.x - l.x), Math.abs(o.y - l.y));
        const x = 5;
        h.x === u.x ? b = {
          x: f < 0 ? u.x - x + m : u.x + x - m,
          y: p < 0 ? u.y - m : u.y + m
        } : b = {
          x: f < 0 ? u.x - m : u.x + m,
          y: p < 0 ? u.y - x + m : u.y + x - m
        };
      } else it.debug("Corner point skipping fixing", Math.abs(o.x - l.x), Math.abs(o.y - l.y));
      a.push(b, d);
    } else a.push(t[n]);
    return a;
  }, "fixCorners");
  M6 = v(function(t, e, a, n, l, o, h) {
    var _a2;
    const { handDrawnSeed: u } = Pt();
    let d = e.points, f = false;
    const p = l;
    var m = o;
    const b = [];
    for (const X in e.cssCompiledStyles) D_(X) || b.push(e.cssCompiledStyles[X]);
    m.intersect && p.intersect && (d = d.slice(1, e.points.length - 1), d.unshift(p.intersect(d[0])), it.debug("Last point APA12", e.start, "-->", e.end, d[d.length - 1], m, m.intersect(d[d.length - 1])), d.push(m.intersect(d[d.length - 1]))), e.toCluster && (it.info("to cluster abc88", a.get(e.toCluster)), d = xx(e.points, a.get(e.toCluster).node), f = true), e.fromCluster && (it.debug("from cluster abc88", a.get(e.fromCluster), JSON.stringify(d, null, 2)), d = xx(d.reverse(), a.get(e.fromCluster).node).reverse(), f = true);
    let x = d.filter((X) => !Number.isNaN(X.y));
    x = E6(x);
    let _ = uu;
    switch (_ = Bu, e.curve) {
      case "linear":
        _ = Bu;
        break;
      case "basis":
        _ = uu;
        break;
      case "cardinal":
        _ = z2;
        break;
      case "bumpX":
        _ = O2;
        break;
      case "bumpY":
        _ = D2;
        break;
      case "catmullRom":
        _ = q2;
        break;
      case "monotoneX":
        _ = P2;
        break;
      case "monotoneY":
        _ = G2;
        break;
      case "natural":
        _ = X2;
        break;
      case "step":
        _ = V2;
        break;
      case "stepAfter":
        _ = Q2;
        break;
      case "stepBefore":
        _ = Z2;
        break;
      default:
        _ = uu;
    }
    const { x: S, y: w } = E5(e), k = hL().x(S).y(w).curve(_);
    let A;
    switch (e.thickness) {
      case "normal":
        A = "edge-thickness-normal";
        break;
      case "thick":
        A = "edge-thickness-thick";
        break;
      case "invisible":
        A = "edge-thickness-invisible";
        break;
      default:
        A = "edge-thickness-normal";
    }
    switch (e.pattern) {
      case "solid":
        A += " edge-pattern-solid";
        break;
      case "dotted":
        A += " edge-pattern-dotted";
        break;
      case "dashed":
        A += " edge-pattern-dashed";
        break;
      default:
        A += " edge-pattern-solid";
    }
    let L, $ = k(x);
    const O = Array.isArray(e.style) ? e.style : e.style ? [
      e.style
    ] : [];
    let W = O.find((X) => X == null ? void 0 : X.startsWith("stroke:"));
    if (e.look === "handDrawn") {
      const X = yt.svg(t);
      Object.assign([], x);
      const at = X.path($, {
        roughness: 0.3,
        seed: u
      });
      A += " transition", L = jt(at).select("path").attr("id", e.id).attr("class", " " + A + (e.classes ? " " + e.classes : "")).attr("style", O ? O.reduce((V, G) => V + ";" + G, "") : "");
      let rt = L.attr("d");
      L.attr("d", rt), t.node().appendChild(L.node());
    } else {
      const X = b.join(";"), at = O ? O.reduce((G, E) => G + E + ";", "") : "";
      let rt = "";
      e.animate && (rt = " edge-animation-fast"), e.animation && (rt = " edge-animation-" + e.animation);
      const V = X ? X + ";" + at + ";" : at;
      L = t.append("path").attr("d", $).attr("id", e.id).attr("class", " " + A + (e.classes ? " " + e.classes : "") + (rt ?? "")).attr("style", V), W = (_a2 = V.match(/stroke:([^;]+)/)) == null ? void 0 : _a2[1];
    }
    let j = "";
    (Pt().flowchart.arrowMarkerAbsolute || Pt().state.arrowMarkerAbsolute) && (j = t2(true)), it.info("arrowTypeStart", e.arrowTypeStart), it.info("arrowTypeEnd", e.arrowTypeEnd), S6(L, e, j, h, n, W);
    const et = Math.floor(d.length / 2), nt = d[et];
    tr.isLabelCoordinateInPath(nt, L.attr("d")) || (f = true);
    let lt = {};
    return f && (lt.updatedPath = d), lt.originalPath = e.points, lt;
  }, "insertEdge");
  B6 = v((t, e, a, n) => {
    e.forEach((l) => {
      G6[l](t, a, n);
    });
  }, "insertMarkers");
  L6 = v((t, e, a) => {
    it.trace("Making markers for ", a), t.append("defs").append("marker").attr("id", a + "_" + e + "-extensionStart").attr("class", "marker extension " + e).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z"), t.append("defs").append("marker").attr("id", a + "_" + e + "-extensionEnd").attr("class", "marker extension " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z");
  }, "extension");
  O6 = v((t, e, a) => {
    t.append("defs").append("marker").attr("id", a + "_" + e + "-compositionStart").attr("class", "marker composition " + e).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), t.append("defs").append("marker").attr("id", a + "_" + e + "-compositionEnd").attr("class", "marker composition " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
  }, "composition");
  D6 = v((t, e, a) => {
    t.append("defs").append("marker").attr("id", a + "_" + e + "-aggregationStart").attr("class", "marker aggregation " + e).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), t.append("defs").append("marker").attr("id", a + "_" + e + "-aggregationEnd").attr("class", "marker aggregation " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
  }, "aggregation");
  R6 = v((t, e, a) => {
    t.append("defs").append("marker").attr("id", a + "_" + e + "-dependencyStart").attr("class", "marker dependency " + e).attr("refX", 6).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z"), t.append("defs").append("marker").attr("id", a + "_" + e + "-dependencyEnd").attr("class", "marker dependency " + e).attr("refX", 13).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
  }, "dependency");
  $6 = v((t, e, a) => {
    t.append("defs").append("marker").attr("id", a + "_" + e + "-lollipopStart").attr("class", "marker lollipop " + e).attr("refX", 13).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6), t.append("defs").append("marker").attr("id", a + "_" + e + "-lollipopEnd").attr("class", "marker lollipop " + e).attr("refX", 1).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6);
  }, "lollipop");
  N6 = v((t, e, a) => {
    t.append("marker").attr("id", a + "_" + e + "-pointEnd").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", 5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 8).attr("markerHeight", 8).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), t.append("marker").attr("id", a + "_" + e + "-pointStart").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", 4.5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 8).attr("markerHeight", 8).attr("orient", "auto").append("path").attr("d", "M 0 5 L 10 10 L 10 0 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
  }, "point");
  z6 = v((t, e, a) => {
    t.append("marker").attr("id", a + "_" + e + "-circleEnd").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", 11).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), t.append("marker").attr("id", a + "_" + e + "-circleStart").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", -1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
  }, "circle");
  F6 = v((t, e, a) => {
    t.append("marker").attr("id", a + "_" + e + "-crossEnd").attr("class", "marker cross " + e).attr("viewBox", "0 0 11 11").attr("refX", 12).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0"), t.append("marker").attr("id", a + "_" + e + "-crossStart").attr("class", "marker cross " + e).attr("viewBox", "0 0 11 11").attr("refX", -1).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");
  }, "cross");
  q6 = v((t, e, a) => {
    t.append("defs").append("marker").attr("id", a + "_" + e + "-barbEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 14).attr("markerUnits", "userSpaceOnUse").attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
  }, "barb");
  H6 = v((t, e, a) => {
    t.append("defs").append("marker").attr("id", a + "_" + e + "-onlyOneStart").attr("class", "marker onlyOne " + e).attr("refX", 0).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("d", "M9,0 L9,18 M15,0 L15,18"), t.append("defs").append("marker").attr("id", a + "_" + e + "-onlyOneEnd").attr("class", "marker onlyOne " + e).attr("refX", 18).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("d", "M3,0 L3,18 M9,0 L9,18");
  }, "only_one");
  U6 = v((t, e, a) => {
    const n = t.append("defs").append("marker").attr("id", a + "_" + e + "-zeroOrOneStart").attr("class", "marker zeroOrOne " + e).attr("refX", 0).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto");
    n.append("circle").attr("fill", "white").attr("cx", 21).attr("cy", 9).attr("r", 6), n.append("path").attr("d", "M9,0 L9,18");
    const l = t.append("defs").append("marker").attr("id", a + "_" + e + "-zeroOrOneEnd").attr("class", "marker zeroOrOne " + e).attr("refX", 30).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto");
    l.append("circle").attr("fill", "white").attr("cx", 9).attr("cy", 9).attr("r", 6), l.append("path").attr("d", "M21,0 L21,18");
  }, "zero_or_one");
  j6 = v((t, e, a) => {
    t.append("defs").append("marker").attr("id", a + "_" + e + "-oneOrMoreStart").attr("class", "marker oneOrMore " + e).attr("refX", 18).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("d", "M0,18 Q 18,0 36,18 Q 18,36 0,18 M42,9 L42,27"), t.append("defs").append("marker").attr("id", a + "_" + e + "-oneOrMoreEnd").attr("class", "marker oneOrMore " + e).attr("refX", 27).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("d", "M3,9 L3,27 M9,18 Q27,0 45,18 Q27,36 9,18");
  }, "one_or_more");
  Y6 = v((t, e, a) => {
    const n = t.append("defs").append("marker").attr("id", a + "_" + e + "-zeroOrMoreStart").attr("class", "marker zeroOrMore " + e).attr("refX", 18).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto");
    n.append("circle").attr("fill", "white").attr("cx", 48).attr("cy", 18).attr("r", 6), n.append("path").attr("d", "M0,18 Q18,0 36,18 Q18,36 0,18");
    const l = t.append("defs").append("marker").attr("id", a + "_" + e + "-zeroOrMoreEnd").attr("class", "marker zeroOrMore " + e).attr("refX", 39).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto");
    l.append("circle").attr("fill", "white").attr("cx", 9).attr("cy", 18).attr("r", 6), l.append("path").attr("d", "M21,18 Q39,0 57,18 Q39,36 21,18");
  }, "zero_or_more");
  I6 = v((t, e, a) => {
    t.append("defs").append("marker").attr("id", a + "_" + e + "-requirement_arrowEnd").attr("refX", 20).attr("refY", 10).attr("markerWidth", 20).attr("markerHeight", 20).attr("orient", "auto").append("path").attr("d", `M0,0
      L20,10
      M20,10
      L0,20`);
  }, "requirement_arrow");
  P6 = v((t, e, a) => {
    const n = t.append("defs").append("marker").attr("id", a + "_" + e + "-requirement_containsStart").attr("refX", 0).attr("refY", 10).attr("markerWidth", 20).attr("markerHeight", 20).attr("orient", "auto").append("g");
    n.append("circle").attr("cx", 10).attr("cy", 10).attr("r", 9).attr("fill", "none"), n.append("line").attr("x1", 1).attr("x2", 19).attr("y1", 10).attr("y2", 10), n.append("line").attr("y1", 1).attr("y2", 19).attr("x1", 10).attr("x2", 10);
  }, "requirement_contains");
  G6 = {
    extension: L6,
    composition: O6,
    aggregation: D6,
    dependency: R6,
    lollipop: $6,
    point: N6,
    circle: z6,
    cross: F6,
    barb: q6,
    only_one: H6,
    zero_or_one: U6,
    one_or_more: j6,
    zero_or_more: Y6,
    requirement_arrow: I6,
    requirement_contains: P6
  };
  W6 = B6;
  X6 = {
    common: El,
    getConfig: Xe,
    insertCluster: r6,
    insertEdge: M6,
    insertEdgeLabel: w6,
    insertMarkers: W6,
    insertNode: ew,
    interpolateToCurve: Hg,
    labelHelper: At,
    log: it,
    positionEdgeLabel: T6
  };
  So = {};
  rw = v((t) => {
    for (const e of t) So[e.name] = e;
  }, "registerLayoutLoaders");
  V6 = v(() => {
    rw([
      {
        name: "dagre",
        loader: v(async () => await Wt(() => import("./dagre-5GWH7T2D-BMBbZLgK.js"), __vite__mapDeps([0,1,2,3,4,5])), "loader")
      },
      {
        name: "cose-bilkent",
        loader: v(async () => await Wt(() => import("./cose-bilkent-S5V4N54A-BN6UDCHq.js"), __vite__mapDeps([6,7])), "loader")
      }
    ]);
  }, "registerDefaultLayoutLoaders");
  V6();
  let aw, nw, lw, Z6, Q6, K6, J6, sw, l0;
  Oz = v(async (t, e) => {
    if (!(t.layoutAlgorithm in So)) throw new Error(`Unknown layout algorithm: ${t.layoutAlgorithm}`);
    const a = So[t.layoutAlgorithm];
    return (await a.loader()).render(t, e, X6, {
      algorithm: a.algorithm
    });
  }, "render");
  Dz = v((t = "", { fallback: e = "dagre" } = {}) => {
    if (t in So) return t;
    if (e in So) return it.warn(`Layout algorithm ${t} is not registered. Using ${e} as fallback.`), e;
    throw new Error(`Both layout algorithms ${t} and ${e} are not registered.`);
  }, "getRegisteredLayoutAlgorithm");
  aw = "comm";
  nw = "rule";
  lw = "decl";
  Z6 = "@import";
  Q6 = "@namespace";
  K6 = "@keyframes";
  J6 = "@layer";
  sw = Math.abs;
  l0 = String.fromCharCode;
  function ow(t) {
    return t.trim();
  }
  function mu(t, e, a) {
    return t.replace(e, a);
  }
  function t8(t, e, a) {
    return t.indexOf(e, a);
  }
  function bl(t, e) {
    return t.charCodeAt(e) | 0;
  }
  function kl(t, e, a) {
    return t.slice(e, a);
  }
  function gr(t) {
    return t.length;
  }
  function e8(t) {
    return t.length;
  }
  function iu(t, e) {
    return e.push(t), t;
  }
  var Th = 1, Al = 1, cw = 0, Yi = 0, ve = 0, Dl = "";
  function s0(t, e, a, n, l, o, h, u) {
    return {
      value: t,
      root: e,
      parent: a,
      type: n,
      props: l,
      children: o,
      line: Th,
      column: Al,
      length: h,
      return: "",
      siblings: u
    };
  }
  function i8() {
    return ve;
  }
  function r8() {
    return ve = Yi > 0 ? bl(Dl, --Yi) : 0, Al--, ve === 10 && (Al = 1, Th--), ve;
  }
  function ir() {
    return ve = Yi < cw ? bl(Dl, Yi++) : 0, Al++, ve === 10 && (Al = 1, Th++), ve;
  }
  function Ea() {
    return bl(Dl, Yi);
  }
  function yu() {
    return Yi;
  }
  function kh(t, e) {
    return kl(Dl, t, e);
  }
  function Co(t) {
    switch (t) {
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      case 59:
      case 123:
      case 125:
        return 4;
      case 58:
        return 3;
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function a8(t) {
    return Th = Al = 1, cw = gr(Dl = t), Yi = 0, [];
  }
  function n8(t) {
    return Dl = "", t;
  }
  function sp(t) {
    return ow(kh(Yi - 1, Jp(t === 91 ? t + 2 : t === 40 ? t + 1 : t)));
  }
  function l8(t) {
    for (; (ve = Ea()) && ve < 33; ) ir();
    return Co(t) > 2 || Co(ve) > 3 ? "" : " ";
  }
  function s8(t, e) {
    for (; --e && ir() && !(ve < 48 || ve > 102 || ve > 57 && ve < 65 || ve > 70 && ve < 97); ) ;
    return kh(t, yu() + (e < 6 && Ea() == 32 && ir() == 32));
  }
  function Jp(t) {
    for (; ir(); ) switch (ve) {
      case t:
        return Yi;
      case 34:
      case 39:
        t !== 34 && t !== 39 && Jp(ve);
        break;
      case 40:
        t === 41 && Jp(t);
        break;
      case 92:
        ir();
        break;
    }
    return Yi;
  }
  function o8(t, e) {
    for (; ir() && t + ve !== 57; ) if (t + ve === 84 && Ea() === 47) break;
    return "/*" + kh(e, Yi - 1) + "*" + l0(t === 47 ? t : ir());
  }
  function c8(t) {
    for (; !Co(Ea()); ) ir();
    return kh(t, Yi);
  }
  function u8(t) {
    return n8(bu("", null, null, null, [
      ""
    ], t = a8(t), 0, [
      0
    ], t));
  }
  function bu(t, e, a, n, l, o, h, u, d) {
    for (var f = 0, p = 0, m = h, b = 0, x = 0, _ = 0, S = 1, w = 1, k = 1, A = 0, L = "", $ = l, O = o, W = n, j = L; w; ) switch (_ = A, A = ir()) {
      case 40:
        if (_ != 108 && bl(j, m - 1) == 58) {
          t8(j += mu(sp(A), "&", "&\f"), "&\f", sw(f ? u[f - 1] : 0)) != -1 && (k = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        j += sp(A);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        j += l8(_);
        break;
      case 92:
        j += s8(yu() - 1, 7);
        continue;
      case 47:
        switch (Ea()) {
          case 42:
          case 47:
            iu(h8(o8(ir(), yu()), e, a, d), d), (Co(_ || 1) == 5 || Co(Ea() || 1) == 5) && gr(j) && kl(j, -1, void 0) !== " " && (j += " ");
            break;
          default:
            j += "/";
        }
        break;
      case 123 * S:
        u[f++] = gr(j) * k;
      case 125 * S:
      case 59:
      case 0:
        switch (A) {
          case 0:
          case 125:
            w = 0;
          case 59 + p:
            k == -1 && (j = mu(j, /\f/g, "")), x > 0 && (gr(j) - m || S === 0 && _ === 47) && iu(x > 32 ? Sx(j + ";", n, a, m - 1, d) : Sx(mu(j, " ", "") + ";", n, a, m - 2, d), d);
            break;
          case 59:
            j += ";";
          default:
            if (iu(W = _x(j, e, a, f, p, l, u, L, $ = [], O = [], m, o), o), A === 123) if (p === 0) bu(j, e, W, W, $, o, m, u, O);
            else {
              switch (b) {
                case 99:
                  if (bl(j, 3) === 110) break;
                case 108:
                  if (bl(j, 2) === 97) break;
                default:
                  p = 0;
                case 100:
                case 109:
                case 115:
              }
              p ? bu(t, W, W, n && iu(_x(t, W, W, 0, 0, l, u, L, l, $ = [], m, O), O), l, O, m, u, n ? $ : O) : bu(j, W, W, W, [
                ""
              ], O, 0, u, O);
            }
        }
        f = p = x = 0, S = k = 1, L = j = "", m = h;
        break;
      case 58:
        m = 1 + gr(j), x = _;
      default:
        if (S < 1) {
          if (A == 123) --S;
          else if (A == 125 && S++ == 0 && r8() == 125) continue;
        }
        switch (j += l0(A), A * S) {
          case 38:
            k = p > 0 ? 1 : (j += "\f", -1);
            break;
          case 44:
            u[f++] = (gr(j) - 1) * k, k = 1;
            break;
          case 64:
            Ea() === 45 && (j += sp(ir())), b = Ea(), p = m = gr(L = j += c8(yu())), A++;
            break;
          case 45:
            _ === 45 && gr(j) == 2 && (S = 0);
        }
    }
    return o;
  }
  function _x(t, e, a, n, l, o, h, u, d, f, p, m) {
    for (var b = l - 1, x = l === 0 ? o : [
      ""
    ], _ = e8(x), S = 0, w = 0, k = 0; S < n; ++S) for (var A = 0, L = kl(t, b + 1, b = sw(w = h[S])), $ = t; A < _; ++A) ($ = ow(w > 0 ? x[A] + " " + L : mu(L, /&\f/g, x[A]))) && (d[k++] = $);
    return s0(t, e, a, l === 0 ? nw : u, d, f, p, m);
  }
  function h8(t, e, a, n) {
    return s0(t, e, a, aw, l0(i8()), kl(t, 2, -2), 0, n);
  }
  function Sx(t, e, a, n, l) {
    return s0(t, e, a, lw, kl(t, 0, n), kl(t, n + 1, -1), n, l);
  }
  function tg(t, e) {
    for (var a = "", n = 0; n < t.length; n++) a += e(t[n], n, t, e) || "";
    return a;
  }
  function f8(t, e, a, n) {
    switch (t.type) {
      case J6:
        if (t.children.length) break;
      case Z6:
      case Q6:
      case lw:
        return t.return = t.return || t.value;
      case aw:
        return "";
      case K6:
        return t.return = t.value + "{" + tg(t.children, n) + "}";
      case nw:
        if (!gr(t.value = t.props.join(","))) return "";
    }
    return gr(a = tg(t.children, n)) ? t.return = t.value + "{" + a + "}" : "";
  }
  var d8 = z_(Object.keys, Object), p8 = Object.prototype, g8 = p8.hasOwnProperty;
  m8 = function(t) {
    if (!gh(t)) return d8(t);
    var e = [];
    for (var a in Object(t)) g8.call(t, a) && a != "constructor" && e.push(a);
    return e;
  };
  let eg, ig, ag, Cx, y8, wx, Tx, kx, Ax, b8, x8, v8, _8, S8;
  eg = Tn(vr, "DataView");
  ig = Tn(vr, "Promise");
  rg = Tn(vr, "Set");
  ag = Tn(vr, "WeakMap");
  Cx = "[object Map]";
  y8 = "[object Object]";
  wx = "[object Promise]";
  Tx = "[object Set]";
  kx = "[object WeakMap]";
  Ax = "[object DataView]";
  b8 = wn(eg);
  x8 = wn(vo);
  v8 = wn(ig);
  _8 = wn(rg);
  S8 = wn(ag);
  cn = Bl;
  (eg && cn(new eg(new ArrayBuffer(1))) != Ax || vo && cn(new vo()) != Cx || ig && cn(ig.resolve()) != wx || rg && cn(new rg()) != Tx || ag && cn(new ag()) != kx) && (cn = function(t) {
    var e = Bl(t), a = e == y8 ? t.constructor : void 0, n = a ? wn(a) : "";
    if (n) switch (n) {
      case b8:
        return Ax;
      case x8:
        return Cx;
      case v8:
        return wx;
      case _8:
        return Tx;
      case S8:
        return kx;
    }
    return e;
  });
  var C8 = "[object Map]", w8 = "[object Set]", T8 = Object.prototype, k8 = T8.hasOwnProperty;
  Ex = function(t) {
    if (t == null) return true;
    if (mh(t) && (Yu(t) || typeof t == "string" || typeof t.splice == "function" || Fg(t) || qg(t) || ju(t))) return !t.length;
    var e = cn(t);
    if (e == C8 || e == w8) return !t.size;
    if (gh(t)) return !m8(t).length;
    for (var a in t) if (k8.call(t, a)) return false;
    return true;
  };
  var uw = "c4", A8 = v((t) => /^\s*C4Context|C4Container|C4Component|C4Dynamic|C4Deployment/.test(t), "detector"), E8 = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./c4Diagram-FPNF74CW-DuluuK2U.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([8,9]));
    return {
      id: uw,
      diagram: t
    };
  }, "loader"), M8 = {
    id: uw,
    detector: A8,
    loader: E8
  }, B8 = M8, hw = "flowchart", L8 = v((t, e) => {
    var _a2, _b2;
    return ((_a2 = e == null ? void 0 : e.flowchart) == null ? void 0 : _a2.defaultRenderer) === "dagre-wrapper" || ((_b2 = e == null ? void 0 : e.flowchart) == null ? void 0 : _b2.defaultRenderer) === "elk" ? false : /^\s*graph/.test(t);
  }, "detector"), O8 = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./flowDiagram-PVAE7QVJ-C30bQQiE.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([10,11,12,13,14]));
    return {
      id: hw,
      diagram: t
    };
  }, "loader"), D8 = {
    id: hw,
    detector: L8,
    loader: O8
  }, R8 = D8, fw = "flowchart-v2", $8 = v((t, e) => {
    var _a2, _b2, _c2;
    return ((_a2 = e == null ? void 0 : e.flowchart) == null ? void 0 : _a2.defaultRenderer) === "dagre-d3" ? false : (((_b2 = e == null ? void 0 : e.flowchart) == null ? void 0 : _b2.defaultRenderer) === "elk" && (e.layout = "elk"), /^\s*graph/.test(t) && ((_c2 = e == null ? void 0 : e.flowchart) == null ? void 0 : _c2.defaultRenderer) === "dagre-wrapper" ? true : /^\s*flowchart/.test(t));
  }, "detector"), N8 = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./flowDiagram-PVAE7QVJ-C30bQQiE.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([10,11,12,13,14]));
    return {
      id: fw,
      diagram: t
    };
  }, "loader"), z8 = {
    id: fw,
    detector: $8,
    loader: N8
  }, F8 = z8, dw = "er", q8 = v((t) => /^\s*erDiagram/.test(t), "detector"), H8 = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./erDiagram-AWTI2OKA-BQnN4uid.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([15,12,13,14]));
    return {
      id: dw,
      diagram: t
    };
  }, "loader"), U8 = {
    id: dw,
    detector: q8,
    loader: H8
  }, j8 = U8, pw = "gitGraph", Y8 = v((t) => /^\s*gitGraph/.test(t), "detector"), I8 = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./gitGraphDiagram-NY62KEGX-DYHTqPbW.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([16,17,18,19,2,4,5]));
    return {
      id: pw,
      diagram: t
    };
  }, "loader"), P8 = {
    id: pw,
    detector: Y8,
    loader: I8
  }, G8 = P8, gw = "gantt", W8 = v((t) => /^\s*gantt/.test(t), "detector"), X8 = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./ganttDiagram-OWAHRB6G-CS3lCdvA.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([20,21,22,23]));
    return {
      id: gw,
      diagram: t
    };
  }, "loader"), V8 = {
    id: gw,
    detector: W8,
    loader: X8
  }, Z8 = V8, mw = "info", Q8 = v((t) => /^\s*info/.test(t), "detector"), K8 = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./infoDiagram-STP46IZ2-58lAvSvK.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([24,19,2,4,5]));
    return {
      id: mw,
      diagram: t
    };
  }, "loader"), J8 = {
    id: mw,
    detector: Q8,
    loader: K8
  }, yw = "pie", t$ = v((t) => /^\s*pie/.test(t), "detector"), e$ = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./pieDiagram-ADFJNKIX-C9GZZgA3.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([25,17,19,2,4,5,26,27,22]));
    return {
      id: yw,
      diagram: t
    };
  }, "loader"), i$ = {
    id: yw,
    detector: t$,
    loader: e$
  }, bw = "quadrantChart", r$ = v((t) => /^\s*quadrantChart/.test(t), "detector"), a$ = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./quadrantDiagram-LMRXKWRM-UPRoinb8.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([28,21,22,23]));
    return {
      id: bw,
      diagram: t
    };
  }, "loader"), n$ = {
    id: bw,
    detector: r$,
    loader: a$
  }, l$ = n$, xw = "xychart", s$ = v((t) => /^\s*xychart(-beta)?/.test(t), "detector"), o$ = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./xychartDiagram-6GGTOJPD-D7vcgLJd.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([29,22,27,21,23]));
    return {
      id: xw,
      diagram: t
    };
  }, "loader"), c$ = {
    id: xw,
    detector: s$,
    loader: o$
  }, u$ = c$, vw = "requirement", h$ = v((t) => /^\s*requirement(Diagram)?/.test(t), "detector"), f$ = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./requirementDiagram-4UW4RH46-DSfmKJty.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([30,12,13]));
    return {
      id: vw,
      diagram: t
    };
  }, "loader"), d$ = {
    id: vw,
    detector: h$,
    loader: f$
  }, p$ = d$, _w = "sequence", g$ = v((t) => /^\s*sequenceDiagram/.test(t), "detector"), m$ = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./sequenceDiagram-C3RYC4MD-CorXJhN6.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([31,9,18]));
    return {
      id: _w,
      diagram: t
    };
  }, "loader"), y$ = {
    id: _w,
    detector: g$,
    loader: m$
  }, b$ = y$, Sw = "class", x$ = v((t, e) => {
    var _a2;
    return ((_a2 = e == null ? void 0 : e.class) == null ? void 0 : _a2.defaultRenderer) === "dagre-wrapper" ? false : /^\s*classDiagram/.test(t);
  }, "detector"), v$ = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./classDiagram-KNZD7YFC-BXauZT2J.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([32,33,11,12,13]));
    return {
      id: Sw,
      diagram: t
    };
  }, "loader"), _$ = {
    id: Sw,
    detector: x$,
    loader: v$
  }, S$ = _$, Cw = "classDiagram", C$ = v((t, e) => {
    var _a2;
    return /^\s*classDiagram/.test(t) && ((_a2 = e == null ? void 0 : e.class) == null ? void 0 : _a2.defaultRenderer) === "dagre-wrapper" ? true : /^\s*classDiagram-v2/.test(t);
  }, "detector"), w$ = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./classDiagram-v2-RKCZMP56-BXauZT2J.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([34,33,11,12,13]));
    return {
      id: Cw,
      diagram: t
    };
  }, "loader"), T$ = {
    id: Cw,
    detector: C$,
    loader: w$
  }, k$ = T$, ww = "state", A$ = v((t, e) => {
    var _a2;
    return ((_a2 = e == null ? void 0 : e.state) == null ? void 0 : _a2.defaultRenderer) === "dagre-wrapper" ? false : /^\s*stateDiagram/.test(t);
  }, "detector"), E$ = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./stateDiagram-KXAO66HF-CCGvXDza.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([35,36,12,13,1,2,3,4]));
    return {
      id: ww,
      diagram: t
    };
  }, "loader"), M$ = {
    id: ww,
    detector: A$,
    loader: E$
  }, B$ = M$, Tw = "stateDiagram", L$ = v((t, e) => {
    var _a2;
    return !!(/^\s*stateDiagram-v2/.test(t) || /^\s*stateDiagram/.test(t) && ((_a2 = e == null ? void 0 : e.state) == null ? void 0 : _a2.defaultRenderer) === "dagre-wrapper");
  }, "detector"), O$ = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./stateDiagram-v2-UMBNRL4Z-Uy3D9xC-.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([37,36,12,13]));
    return {
      id: Tw,
      diagram: t
    };
  }, "loader"), D$ = {
    id: Tw,
    detector: L$,
    loader: O$
  }, R$ = D$, kw = "journey", $$ = v((t) => /^\s*journey/.test(t), "detector"), N$ = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./journeyDiagram-BIP6EPQ6-DRM6TPn8.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([38,9,11,26]));
    return {
      id: kw,
      diagram: t
    };
  }, "loader"), z$ = {
    id: kw,
    detector: $$,
    loader: N$
  }, F$ = z$, q$ = v((t, e, a) => {
    it.debug(`rendering svg for syntax error
`);
    const n = vL(e), l = n.append("g");
    n.attr("viewBox", "0 0 2412 512"), e2(n, 100, 512, true), l.append("path").attr("class", "error-icon").attr("d", "m411.313,123.313c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32-9.375,9.375-20.688-20.688c-12.484-12.5-32.766-12.5-45.25,0l-16,16c-1.261,1.261-2.304,2.648-3.31,4.051-21.739-8.561-45.324-13.426-70.065-13.426-105.867,0-192,86.133-192,192s86.133,192 192,192 192-86.133 192-192c0-24.741-4.864-48.327-13.426-70.065 1.402-1.007 2.79-2.049 4.051-3.31l16-16c12.5-12.492 12.5-32.758 0-45.25l-20.688-20.688 9.375-9.375 32.001-31.999zm-219.313,100.687c-52.938,0-96,43.063-96,96 0,8.836-7.164,16-16,16s-16-7.164-16-16c0-70.578 57.422-128 128-128 8.836,0 16,7.164 16,16s-7.164,16-16,16z"), l.append("path").attr("class", "error-icon").attr("d", "m459.02,148.98c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l16,16c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16.001-16z"), l.append("path").attr("class", "error-icon").attr("d", "m340.395,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16-16c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l15.999,16z"), l.append("path").attr("class", "error-icon").attr("d", "m400,64c8.844,0 16-7.164 16-16v-32c0-8.836-7.156-16-16-16-8.844,0-16,7.164-16,16v32c0,8.836 7.156,16 16,16z"), l.append("path").attr("class", "error-icon").attr("d", "m496,96.586h-32c-8.844,0-16,7.164-16,16 0,8.836 7.156,16 16,16h32c8.844,0 16-7.164 16-16 0-8.836-7.156-16-16-16z"), l.append("path").attr("class", "error-icon").attr("d", "m436.98,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688l32-32c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32c-6.251,6.25-6.251,16.375-0.001,22.625z"), l.append("text").attr("class", "error-text").attr("x", 1440).attr("y", 250).attr("font-size", "150px").style("text-anchor", "middle").text("Syntax error in text"), l.append("text").attr("class", "error-text").attr("x", 1250).attr("y", 400).attr("font-size", "100px").style("text-anchor", "middle").text(`mermaid version ${a}`);
  }, "draw"), Aw = {
    draw: q$
  }, H$ = Aw, U$ = {
    db: {},
    renderer: Aw,
    parser: {
      parse: v(() => {
      }, "parse")
    }
  }, j$ = U$, Ew = "flowchart-elk", Y$ = v((t, e = {}) => {
    var _a2;
    return /^\s*flowchart-elk/.test(t) || /^\s*(flowchart|graph)/.test(t) && ((_a2 = e == null ? void 0 : e.flowchart) == null ? void 0 : _a2.defaultRenderer) === "elk" ? (e.layout = "elk", true) : false;
  }, "detector"), I$ = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./flowDiagram-PVAE7QVJ-C30bQQiE.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([10,11,12,13,14]));
    return {
      id: Ew,
      diagram: t
    };
  }, "loader"), P$ = {
    id: Ew,
    detector: Y$,
    loader: I$
  }, G$ = P$, Mw = "timeline", W$ = v((t) => /^\s*timeline/.test(t), "detector"), X$ = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./timeline-definition-XQNQX7LJ-BvZySmlk.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([39,26]));
    return {
      id: Mw,
      diagram: t
    };
  }, "loader"), V$ = {
    id: Mw,
    detector: W$,
    loader: X$
  }, Z$ = V$, Bw = "mindmap", Q$ = v((t) => /^\s*mindmap/.test(t), "detector"), K$ = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./mindmap-definition-Q6HEUPPD-DW5BEfvJ.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([40,12,13]));
    return {
      id: Bw,
      diagram: t
    };
  }, "loader"), J$ = {
    id: Bw,
    detector: Q$,
    loader: K$
  }, tN = J$, Lw = "kanban", eN = v((t) => /^\s*kanban/.test(t), "detector"), iN = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./kanban-definition-6OIFK2YF-UP2RNqUs.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([41,11]));
    return {
      id: Lw,
      diagram: t
    };
  }, "loader"), rN = {
    id: Lw,
    detector: eN,
    loader: iN
  }, aN = rN, Ow = "sankey", nN = v((t) => /^\s*sankey(-beta)?/.test(t), "detector"), lN = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./sankeyDiagram-GR3RE2ED-DTLA6Z8n.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([42,27,22]));
    return {
      id: Ow,
      diagram: t
    };
  }, "loader"), sN = {
    id: Ow,
    detector: nN,
    loader: lN
  }, oN = sN, Dw = "packet", cN = v((t) => /^\s*packet(-beta)?/.test(t), "detector"), uN = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./diagram-S2PKOQOG-D95U7Eg2.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([43,17,19,2,4,5]));
    return {
      id: Dw,
      diagram: t
    };
  }, "loader"), hN = {
    id: Dw,
    detector: cN,
    loader: uN
  }, Rw = "radar", fN = v((t) => /^\s*radar-beta/.test(t), "detector"), dN = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./diagram-QEK2KX5R-COm1ZZfD.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([44,17,19,2,4,5]));
    return {
      id: Rw,
      diagram: t
    };
  }, "loader"), pN = {
    id: Rw,
    detector: fN,
    loader: dN
  }, $w = "block", gN = v((t) => /^\s*block(-beta)?/.test(t), "detector"), mN = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./blockDiagram-QIGZ2CNN-AMClBncs.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([45,11,5,2,1,14]));
    return {
      id: $w,
      diagram: t
    };
  }, "loader"), yN = {
    id: $w,
    detector: gN,
    loader: mN
  }, bN = yN, Nw = "architecture", xN = v((t) => /^\s*architecture/.test(t), "detector"), vN = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./architectureDiagram-W76B3OCA-CJxIfoJw.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([46,17,19,2,4,5,7]));
    return {
      id: Nw,
      diagram: t
    };
  }, "loader"), _N = {
    id: Nw,
    detector: xN,
    loader: vN
  }, SN = _N, zw = "treemap", CN = v((t) => /^\s*treemap/.test(t), "detector"), wN = v(async () => {
    const { diagram: t } = await Wt(async () => {
      const { diagram: e } = await import("./diagram-N5W7TBWH-C6wYlEUW.js");
      return {
        diagram: e
      };
    }, __vite__mapDeps([47,13,17,19,2,4,5,23,27,22]));
    return {
      id: zw,
      diagram: t
    };
  }, "loader"), TN = {
    id: zw,
    detector: CN,
    loader: wN
  }, Mx = false, Ah = v(() => {
    Mx || (Mx = true, Cu("error", j$, (t) => t.toLowerCase().trim() === "error"), Cu("---", {
      db: {
        clear: v(() => {
        }, "clear")
      },
      styles: {},
      renderer: {
        draw: v(() => {
        }, "draw")
      },
      parser: {
        parse: v(() => {
          throw new Error("Diagrams beginning with --- are not valid. If you were trying to use a YAML front-matter, please ensure that you've correctly opened and closed the YAML front-matter with un-indented `---` blocks");
        }, "parse")
      },
      init: v(() => null, "init")
    }, (t) => t.toLowerCase().trimStart().startsWith("---")), fp(G$, tN, SN), fp(B8, aN, k$, S$, j8, Z8, J8, i$, p$, b$, F8, R8, Z$, G8, R$, B$, F$, l$, oN, hN, u$, bN, pN, TN));
  }, "addDiagrams"), kN = v(async () => {
    it.debug("Loading registered diagrams");
    const e = (await Promise.allSettled(Object.entries(mn).map(async ([a, { detector: n, loader: l }]) => {
      if (l) try {
        mp(a);
      } catch {
        try {
          const { diagram: o, id: h } = await l();
          Cu(h, o, n);
        } catch (o) {
          throw it.error(`Failed to load external diagram with key ${a}. Removing from detectors.`), delete mn[a], o;
        }
      }
    }))).filter((a) => a.status === "rejected");
    if (e.length > 0) {
      it.error(`Failed to load ${e.length} external diagrams`);
      for (const a of e) it.error(a);
      throw new Error(`Failed to load ${e.length} external diagrams`);
    }
  }, "loadRegisteredDiagrams"), AN = "graphics-document document";
  function Fw(t, e) {
    t.attr("role", AN), e !== "" && t.attr("aria-roledescription", e);
  }
  v(Fw, "setA11yDiagramInfo");
  function qw(t, e, a, n) {
    if (t.insert !== void 0) {
      if (a) {
        const l = `chart-desc-${n}`;
        t.attr("aria-describedby", l), t.insert("desc", ":first-child").attr("id", l).text(a);
      }
      if (e) {
        const l = `chart-title-${n}`;
        t.attr("aria-labelledby", l), t.insert("title", ":first-child").attr("id", l).text(e);
      }
    }
  }
  v(qw, "addSVGa11yTitleDescription");
  var ng = (_j = class {
    constructor(e, a, n, l, o) {
      this.type = e, this.text = a, this.db = n, this.parser = l, this.renderer = o;
    }
    static async fromText(e, a = {}) {
      var _a2, _b2;
      const n = Xe(), l = cg(e, n);
      e = k4(e) + `
`;
      try {
        mp(l);
      } catch {
        const f = QA(l);
        if (!f) throw new jx(`Diagram ${l} not found.`);
        const { id: p, diagram: m } = await f();
        Cu(p, m);
      }
      const { db: o, parser: h, renderer: u, init: d } = mp(l);
      return h.parser && (h.parser.yy = o), (_a2 = o.clear) == null ? void 0 : _a2.call(o), d == null ? void 0 : d(n), a.title && ((_b2 = o.setDiagramTitle) == null ? void 0 : _b2.call(o, a.title)), await h.parse(e), new _j(l, e, o, h, u);
    }
    async render(e, a) {
      await this.renderer.draw(this.text, e, a, this);
    }
    getParser() {
      return this.parser;
    }
    getType() {
      return this.type;
    }
  }, v(_j, "Diagram"), _j), Bx = [], EN = v(() => {
    Bx.forEach((t) => {
      t();
    }), Bx = [];
  }, "attachFunctions"), MN = v((t) => t.replace(/^\s*%%(?!{)[^\n]+\n?/gm, "").trimStart(), "cleanupComments");
  function Uw(t) {
    const e = t.match(Ux);
    if (!e) return {
      text: t,
      metadata: {}
    };
    let a = A5(e[1], {
      schema: k5
    }) ?? {};
    a = typeof a == "object" && !Array.isArray(a) ? a : {};
    const n = {};
    return a.displayMode && (n.displayMode = a.displayMode.toString()), a.title && (n.title = a.title.toString()), a.config && (n.config = a.config), {
      text: t.slice(e[0].length),
      metadata: n
    };
  }
  v(Uw, "extractFrontMatter");
  var BN = v((t) => t.replace(/\r\n?/g, `
`).replace(/<(\w+)([^>]*)>/g, (e, a, n) => "<" + a + n.replace(/="([^"]*)"/g, "='$1'") + ">"), "cleanupText"), LN = v((t) => {
    const { text: e, metadata: a } = Uw(t), { displayMode: n, title: l, config: o = {} } = a;
    return n && (o.gantt || (o.gantt = {}), o.gantt.displayMode = n), {
      title: l,
      config: o,
      text: e
    };
  }, "processFrontmatter"), ON = v((t) => {
    const e = tr.detectInit(t) ?? {}, a = tr.detectDirective(t, "wrap");
    return Array.isArray(a) ? e.wrap = a.some(({ type: n }) => n === "wrap") : (a == null ? void 0 : a.type) === "wrap" && (e.wrap = true), {
      text: d4(t),
      directive: e
    };
  }, "processDirectives");
  function o0(t) {
    const e = BN(t), a = LN(e), n = ON(a.text), l = Pg(a.config, n.directive);
    return t = MN(n.text), {
      code: t,
      title: a.title,
      config: l
    };
  }
  v(o0, "preprocessDiagram");
  function jw(t) {
    const e = new TextEncoder().encode(t), a = Array.from(e, (n) => String.fromCodePoint(n)).join("");
    return btoa(a);
  }
  v(jw, "toBase64");
  var DN = 5e4, RN = "graph TB;a[Maximum text size in diagram exceeded];style a fill:#faa", $N = "sandbox", NN = "loose", zN = "http://www.w3.org/2000/svg", FN = "http://www.w3.org/1999/xlink", qN = "http://www.w3.org/1999/xhtml", HN = "100%", UN = "100%", jN = "border:0;margin:0;", YN = "margin:0", IN = "allow-top-navigation-by-user-activation allow-popups", PN = 'The "iframe" tag is not supported by your browser.', GN = [
    "foreignobject"
  ], WN = [
    "dominant-baseline"
  ];
  function c0(t) {
    const e = o0(t);
    return _u(), dE(e.config ?? {}), e;
  }
  v(c0, "processAndSetConfigs");
  async function Yw(t, e) {
    Ah();
    try {
      const { code: a, config: n } = c0(t);
      return {
        diagramType: (await Pw(a)).type,
        config: n
      };
    } catch (a) {
      if (e == null ? void 0 : e.suppressErrors) return false;
      throw a;
    }
  }
  v(Yw, "parse");
  var Lx = v((t, e, a = []) => `
.${t} ${e} { ${a.join(" !important; ")} !important; }`, "cssImportantStyles"), XN = v((t, e = /* @__PURE__ */ new Map()) => {
    var _a2;
    let a = "";
    if (t.themeCSS !== void 0 && (a += `
${t.themeCSS}`), t.fontFamily !== void 0 && (a += `
:root { --mermaid-font-family: ${t.fontFamily}}`), t.altFontFamily !== void 0 && (a += `
:root { --mermaid-alt-font-family: ${t.altFontFamily}}`), e instanceof Map) {
      const h = t.htmlLabels ?? ((_a2 = t.flowchart) == null ? void 0 : _a2.htmlLabels) ? [
        "> *",
        "span"
      ] : [
        "rect",
        "polygon",
        "ellipse",
        "circle",
        "path"
      ];
      e.forEach((u) => {
        Ex(u.styles) || h.forEach((d) => {
          a += Lx(u.id, d, u.styles);
        }), Ex(u.textStyles) || (a += Lx(u.id, "tspan", ((u == null ? void 0 : u.textStyles) || []).map((d) => d.replace("color", "fill"))));
      });
    }
    return a;
  }, "createCssStyles"), VN = v((t, e, a, n) => {
    const l = XN(t, a), o = OE(e, l, t.themeVariables);
    return tg(u8(`${n}{${o}}`), f8);
  }, "createUserStyles"), ZN = v((t = "", e, a) => {
    let n = t;
    return !a && !e && (n = n.replace(/marker-end="url\([\d+./:=?A-Za-z-]*?#/g, 'marker-end="url(#')), n = kn(n), n = n.replace(/<br>/g, "<br/>"), n;
  }, "cleanUpSvgCode"), QN = v((t = "", e) => {
    var _a2, _b2;
    const a = ((_b2 = (_a2 = e == null ? void 0 : e.viewBox) == null ? void 0 : _a2.baseVal) == null ? void 0 : _b2.height) ? e.viewBox.baseVal.height + "px" : UN, n = jw(`<body style="${YN}">${t}</body>`);
    return `<iframe style="width:${HN};height:${a};${jN}" src="data:text/html;charset=UTF-8;base64,${n}" sandbox="${IN}">
  ${PN}
</iframe>`;
  }, "putIntoIFrame"), Ox = v((t, e, a, n, l) => {
    const o = t.append("div");
    o.attr("id", a), n && o.attr("style", n);
    const h = o.append("svg").attr("id", e).attr("width", "100%").attr("xmlns", zN);
    return l && h.attr("xmlns:xlink", l), h.append("g"), t;
  }, "appendDivSvgG");
  function lg(t, e) {
    return t.append("iframe").attr("id", e).attr("style", "width: 100%; height: 100%;").attr("sandbox", "");
  }
  v(lg, "sandboxedIframe");
  var KN = v((t, e, a, n) => {
    var _a2, _b2, _c2;
    (_a2 = t.getElementById(e)) == null ? void 0 : _a2.remove(), (_b2 = t.getElementById(a)) == null ? void 0 : _b2.remove(), (_c2 = t.getElementById(n)) == null ? void 0 : _c2.remove();
  }, "removeExistingElements"), JN = v(async function(t, e, a) {
    var _a2, _b2, _c2, _d2, _e2, _f2;
    Ah();
    const n = c0(e);
    e = n.code;
    const l = Xe();
    it.debug(l), e.length > ((l == null ? void 0 : l.maxTextSize) ?? DN) && (e = RN);
    const o = "#" + t, h = "i" + t, u = "#" + h, d = "d" + t, f = "#" + d, p = v(() => {
      const rt = jt(b ? u : f).node();
      rt && "remove" in rt && rt.remove();
    }, "removeTempElements");
    let m = jt("body");
    const b = l.securityLevel === $N, x = l.securityLevel === NN, _ = l.fontFamily;
    if (a !== void 0) {
      if (a && (a.innerHTML = ""), b) {
        const at = lg(jt(a), h);
        m = jt(at.nodes()[0].contentDocument.body), m.node().style.margin = 0;
      } else m = jt(a);
      Ox(m, t, d, `font-family: ${_}`, FN);
    } else {
      if (KN(document, t, d, h), b) {
        const at = lg(jt("body"), h);
        m = jt(at.nodes()[0].contentDocument.body), m.node().style.margin = 0;
      } else m = jt("body");
      Ox(m, t, d);
    }
    let S, w;
    try {
      S = await ng.fromText(e, {
        title: n.title
      });
    } catch (at) {
      if (l.suppressErrorRendering) throw p(), at;
      S = await ng.fromText("error"), w = at;
    }
    const k = m.select(f).node(), A = S.type, L = k.firstChild, $ = L.firstChild, O = (_b2 = (_a2 = S.renderer).getClasses) == null ? void 0 : _b2.call(_a2, e, S), W = VN(l, A, O, o), j = document.createElement("style");
    j.innerHTML = W, L.insertBefore(j, $);
    try {
      await S.renderer.draw(e, t, Jb.version, S);
    } catch (at) {
      throw l.suppressErrorRendering ? p() : H$.draw(e, t, Jb.version), at;
    }
    const et = m.select(`${f} svg`), nt = (_d2 = (_c2 = S.db).getAccTitle) == null ? void 0 : _d2.call(_c2), lt = (_f2 = (_e2 = S.db).getAccDescription) == null ? void 0 : _f2.call(_e2);
    Gw(A, et, nt, lt), m.select(`[id="${t}"]`).selectAll("foreignobject > *").attr("xmlns", qN);
    let X = m.select(f).node().innerHTML;
    if (it.debug("config.arrowMarkerAbsolute", l.arrowMarkerAbsolute), X = ZN(X, b, Ee(l.arrowMarkerAbsolute)), b) {
      const at = m.select(f + " svg").node();
      X = QN(X, at);
    } else x || (X = xl.sanitize(X, {
      ADD_TAGS: GN,
      ADD_ATTR: WN,
      HTML_INTEGRATION_POINTS: {
        foreignobject: true
      }
    }));
    if (EN(), w) throw w;
    return p(), {
      diagramType: A,
      svg: X,
      bindFunctions: S.db.bindFunctions
    };
  }, "render");
  function Iw(t = {}) {
    var _a2;
    const e = ke({}, t);
    (e == null ? void 0 : e.fontFamily) && !((_a2 = e.themeVariables) == null ? void 0 : _a2.fontFamily) && (e.themeVariables || (e.themeVariables = {}), e.themeVariables.fontFamily = e.fontFamily), hE(e), (e == null ? void 0 : e.theme) && e.theme in Xr ? e.themeVariables = Xr[e.theme].getThemeVariables(e.themeVariables) : e && (e.themeVariables = Xr.default.getThemeVariables(e.themeVariables));
    const a = typeof e == "object" ? uE(e) : Wx();
    og(a.logLevel), Ah();
  }
  v(Iw, "initialize");
  var Pw = v((t, e = {}) => {
    const { code: a } = o0(t);
    return ng.fromText(a, e);
  }, "getDiagramFromText");
  function Gw(t, e, a, n) {
    Fw(e, t), qw(e, a, n, e.attr("id"));
  }
  v(Gw, "addA11yInfo");
  var Sn = Object.freeze({
    render: JN,
    parse: Yw,
    getDiagramFromText: Pw,
    initialize: Iw,
    getConfig: Xe,
    setConfig: Xx,
    getSiteConfig: Wx,
    updateSiteConfig: fE,
    reset: v(() => {
      _u();
    }, "reset"),
    globalReset: v(() => {
      _u(vl);
    }, "globalReset"),
    defaultConfig: vl
  });
  og(Xe().logLevel);
  _u(Xe());
  var tz = v((t, e, a) => {
    it.warn(t), Ig(t) ? (a && a(t.str, t.hash), e.push({
      ...t,
      message: t.str,
      error: t
    })) : (a && a(t), t instanceof Error && e.push({
      str: t.message,
      message: t.message,
      hash: t.name,
      error: t
    }));
  }, "handleError"), Ww = v(async function(t = {
    querySelector: ".mermaid"
  }) {
    try {
      await ez(t);
    } catch (e) {
      if (Ig(e) && it.error(e.str), Kr.parseError && Kr.parseError(e), !t.suppressErrors) throw it.error("Use the suppressErrors option to suppress these errors"), e;
    }
  }, "run"), ez = v(async function({ postRenderCallback: t, querySelector: e, nodes: a } = {
    querySelector: ".mermaid"
  }) {
    const n = Sn.getConfig();
    it.debug(`${t ? "" : "No "}Callback function found`);
    let l;
    if (a) l = a;
    else if (e) l = document.querySelectorAll(e);
    else throw new Error("Nodes and querySelector are both undefined");
    it.debug(`Found ${l.length} diagrams`), (n == null ? void 0 : n.startOnLoad) !== void 0 && (it.debug("Start On Load: " + (n == null ? void 0 : n.startOnLoad)), Sn.updateSiteConfig({
      startOnLoad: n == null ? void 0 : n.startOnLoad
    }));
    const o = new tr.InitIDGenerator(n.deterministicIds, n.deterministicIDSeed);
    let h;
    const u = [];
    for (const d of Array.from(l)) {
      if (it.info("Rendering diagram: " + d.id), d.getAttribute("data-processed")) continue;
      d.setAttribute("data-processed", "true");
      const f = `mermaid-${o.next()}`;
      h = d.innerHTML, h = gS(tr.entityDecode(h)).trim().replace(/<br\s*\/?>/gi, "<br/>");
      const p = tr.detectInit(h);
      p && it.debug("Detected early reinit: ", p);
      try {
        const { svg: m, bindFunctions: b } = await Qw(f, h, d);
        d.innerHTML = m, t && await t(f), b && b(d);
      } catch (m) {
        tz(m, u, Kr.parseError);
      }
    }
    if (u.length > 0) throw u[0];
  }, "runThrowsErrors"), Xw = v(function(t) {
    Sn.initialize(t);
  }, "initialize"), iz = v(async function(t, e, a) {
    it.warn("mermaid.init is deprecated. Please use run instead."), t && Xw(t);
    const n = {
      postRenderCallback: a,
      querySelector: ".mermaid"
    };
    typeof e == "string" ? n.querySelector = e : e && (e instanceof HTMLElement ? n.nodes = [
      e
    ] : n.nodes = e), await Ww(n);
  }, "init"), rz = v(async (t, { lazyLoad: e = true } = {}) => {
    Ah(), fp(...t), e === false && await kN();
  }, "registerExternalDiagrams"), Vw = v(function() {
    if (Kr.startOnLoad) {
      const { startOnLoad: t } = Sn.getConfig();
      t && Kr.run().catch((e) => it.error("Mermaid failed to initialize", e));
    }
  }, "contentLoaded");
  typeof document < "u" && window.addEventListener("load", Vw, false);
  var az = v(function(t) {
    Kr.parseError = t;
  }, "setParseErrorHandler"), th = [], op = false, Zw = v(async () => {
    if (!op) {
      for (op = true; th.length > 0; ) {
        const t = th.shift();
        if (t) try {
          await t();
        } catch (e) {
          it.error("Error executing queue", e);
        }
      }
      op = false;
    }
  }, "executeQueue"), nz = v(async (t, e) => new Promise((a, n) => {
    const l = v(() => new Promise((o, h) => {
      Sn.parse(t, e).then((u) => {
        o(u), a(u);
      }, (u) => {
        var _a2;
        it.error("Error parsing", u), (_a2 = Kr.parseError) == null ? void 0 : _a2.call(Kr, u), h(u), n(u);
      });
    }), "performCall");
    th.push(l), Zw().catch(n);
  }), "parse"), Qw = v((t, e, a) => new Promise((n, l) => {
    const o = v(() => new Promise((h, u) => {
      Sn.render(t, e, a).then((d) => {
        h(d), n(d);
      }, (d) => {
        var _a2;
        it.error("Error parsing", d), (_a2 = Kr.parseError) == null ? void 0 : _a2.call(Kr, d), u(d), l(d);
      });
    }), "performCall");
    th.push(o), Zw().catch(l);
  }), "render"), lz = v(() => Object.keys(mn).map((t) => ({
    id: t
  })), "getRegisteredDiagramsMetadata"), Kr = {
    startOnLoad: true,
    mermaidAPI: Sn,
    parse: nz,
    render: Qw,
    init: iz,
    run: Ww,
    registerExternalDiagrams: rz,
    registerLayoutLoaders: rw,
    initialize: Xw,
    parseError: void 0,
    contentLoaded: Vw,
    setParseErrorHandler: az,
    detectType: cg,
    registerIconPacks: BR,
    getRegisteredDiagramsMetadata: lz
  }, cp = Kr;
  async function sz() {
    const t = await fetch("/health");
    if (!t.ok) throw new Error("health failed");
    return (await t.json()).status;
  }
  async function oz(t, e) {
    const a = await fetch("/chat/stream", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        prompt: t
      })
    });
    if (!a.ok || !a.body) throw new Error(`stream failed: ${a.status}`);
    const n = a.body.getReader(), l = new TextDecoder();
    let o = "";
    for (; ; ) {
      const { done: h, value: u } = await n.read();
      if (h) break;
      o += l.decode(u, {
        stream: true
      });
      const d = o.split(`

`);
      o = d.pop() || "";
      for (const f of d) {
        const p = f.trim();
        if (!p) continue;
        const m = p.indexOf("data:"), b = m >= 0 ? p.slice(m + 5).trim() : p;
        try {
          const x = JSON.parse(b);
          e(x);
        } catch {
        }
      }
    }
  }
  async function cz() {
    const t = await fetch("/diagram");
    if (!t.ok) throw new Error("diagram failed");
    return t.json();
  }
  function uz() {
    const [t, e] = Qi.useState(""), [a, n] = Qi.useState([]), [l, o] = Qi.useState("unknown"), [h, u] = Qi.useState("");
    Qi.useEffect(() => {
      cp.initialize({
        startOnLoad: false,
        securityLevel: "loose",
        theme: "default"
      });
    }, []);
    const d = Qi.useCallback(async () => {
      try {
        const m = await sz();
        o(m);
      } catch {
        o("unreachable");
      }
    }, []);
    Qi.useEffect(() => {
      d();
    }, [
      d
    ]);
    const f = Qi.useCallback(async () => {
      n((m) => [
        ...m,
        `> ${t}`
      ]);
      try {
        await oz(t, (m) => {
          if (m.error) {
            n((x) => [
              ...x,
              `Error: ${m.error}`
            ]);
            return;
          }
          const b = m.step_name ? `${m.step_name} (${m.agent_name ?? ""}): ${m.step_result ?? ""}` : m.step_result ?? "";
          b && n((x) => [
            ...x,
            b
          ]);
        });
      } catch (m) {
        n((b) => [
          ...b,
          `Stream failed: ${(m == null ? void 0 : m.message) ?? m}`
        ]);
      }
    }, [
      t
    ]), p = Qi.useCallback(async () => {
      try {
        const m = await cz();
        u("");
        const b = document.getElementById("mermaid-diagram");
        if (!b) return;
        try {
          cp.parse(m.diagram);
        } catch (_) {
          u((_ == null ? void 0 : _.message) || "Invalid Mermaid diagram"), b.innerHTML = "";
          return;
        }
        const { svg: x } = await cp.render("workflowDiagram", m.diagram);
        b.innerHTML = x;
      } catch (m) {
        u((m == null ? void 0 : m.message) || "Failed to load diagram");
      }
    }, []);
    return Qi.useEffect(() => {
      p();
    }, [
      p
    ]), Ai.jsxs("div", {
      style: {
        maxWidth: 900,
        margin: "0 auto",
        padding: 16
      },
      children: [
        Ai.jsx("h2", {
          children: "Maestro Workflow UI"
        }),
        Ai.jsxs("div", {
          style: {
            marginBottom: 8
          },
          children: [
            "Health: ",
            l
          ]
        }),
        Ai.jsxs("div", {
          style: {
            display: "flex",
            gap: 8,
            marginBottom: 12
          },
          children: [
            Ai.jsx("input", {
              style: {
                flex: 1,
                padding: 8
              },
              placeholder: "Enter your prompt",
              value: t,
              onChange: (m) => e(m.target.value)
            }),
            Ai.jsx("button", {
              onClick: f,
              children: "Send"
            })
          ]
        }),
        Ai.jsx("div", {
          style: {
            border: "1px solid #ddd",
            padding: 8,
            minHeight: 160
          },
          children: a.map((m, b) => Ai.jsx("div", {
            style: {
              whiteSpace: "pre-wrap"
            },
            children: m
          }, b))
        }),
        Ai.jsx("h4", {
          style: {
            marginTop: 16
          },
          children: "Workflow Diagram"
        }),
        h && Ai.jsxs("div", {
          style: {
            color: "crimson",
            marginBottom: 8
          },
          children: [
            "Diagram error: ",
            h
          ]
        }),
        Ai.jsx("div", {
          id: "mermaid-diagram",
          style: {
            minHeight: 120
          }
        })
      ]
    });
  }
  pA.createRoot(document.getElementById("root")).render(Ai.jsx(Qi.StrictMode, {
    children: Ai.jsx(uz, {})
  }));
})();
export {
  i2 as $,
  no as A,
  _A as B,
  UE as C,
  Pg as D,
  Xe as E,
  Gx as F,
  b4 as G,
  vL as H,
  Jb as I,
  k5 as J,
  rE as K,
  _l as L,
  fz as M,
  yh as N,
  t2 as O,
  ug as P,
  f1 as Q,
  hL as R,
  uu as S,
  y4 as T,
  To as U,
  ME as V,
  wo as W,
  mt as X,
  wt as Y,
  c4 as Z,
  v as _,
  __tla,
  $E as a,
  D_ as a$,
  sL as a0,
  O1 as a1,
  L1 as a2,
  Cz as a3,
  bz as a4,
  _z as a5,
  vz as a6,
  mz as a7,
  hl as a8,
  Cg as a9,
  n4 as aA,
  QO as aB,
  KD as aC,
  Ng as aD,
  Ex as aE,
  OR as aF,
  oL as aG,
  hz as aH,
  aA as aI,
  Oo as aJ,
  BR as aK,
  MR as aL,
  xg as aM,
  Aa as aN,
  T1 as aO,
  U3 as aP,
  fo as aQ,
  Cn as aR,
  l4 as aS,
  P_ as aT,
  fh as aU,
  mh as aV,
  Yu as aW,
  W_ as aX,
  I_ as aY,
  ND as aZ,
  vt as a_,
  Sz as aa,
  yz as ab,
  Tz as ac,
  wz as ad,
  xz as ae,
  r6 as af,
  ew as ag,
  Bz as ah,
  E5 as ai,
  Ee as aj,
  $a as ak,
  $g as al,
  AS as am,
  kn as an,
  J_ as ao,
  Lt as ap,
  yr as aq,
  W6 as ar,
  Mz as as,
  Lz as at,
  Az as au,
  xt as av,
  Ez as aw,
  M6 as ax,
  T6 as ay,
  w6 as az,
  RE as b,
  gi as b0,
  R3 as b1,
  bg as b2,
  m2 as b3,
  Ao as b4,
  x2 as b5,
  gz as b6,
  vA as b7,
  a4 as b8,
  QD as b9,
  rg as bA,
  s4 as bB,
  gh as bC,
  Wt as bD,
  FO as ba,
  zg as bb,
  OD as bc,
  o4 as bd,
  Bo as be,
  Bl as bf,
  Hu as bg,
  YD as bh,
  m8 as bi,
  Mo as bj,
  ju as bk,
  zD as bl,
  F_ as bm,
  UO as bn,
  jO as bo,
  cn as bp,
  Q1 as bq,
  YO as br,
  Fg as bs,
  HO as bt,
  GO as bu,
  Ll as bv,
  Ra as bw,
  G1 as bx,
  qg as by,
  H_ as bz,
  Pt as c,
  jt as d,
  e2 as e,
  ke as f,
  zE as g,
  Qr as h,
  ji as i,
  R5 as j,
  El as k,
  it as l,
  eS as m,
  dz as n,
  Dz as o,
  FE as p,
  qE as q,
  Oz as r,
  NE as s,
  A5 as t,
  tr as u,
  _6 as v,
  _4 as w,
  kz as x,
  DE as y,
  pz as z
};
